<!DOCTYPE html> <html lang=en style><!--
 Page saved with SingleFile 
 url: https://akawashiro.com/articles/how-device-file-in-linux-works 
 saved date: Sun May 05 2024 16:34:19 GMT+0800 (Singapore Standard Time)
--><meta charset=utf-8>
<meta http-equiv=X-UA-Compatible content="IE=edge">
<meta name=viewport content="width=device-width, initial-scale=1">
<title>How device file in Linux works | Akira Kawata</title>
<meta name=generator content="Jekyll v4.3.2">
<meta property=og:title content="How device file in Linux works">
<meta property=og:locale content=en_US>
<link rel=canonical href=https://akawashiro.com/articles/how-device-file-in-linux-works.html>
<meta property=og:url content=/articles/how-device-file-in-linux-works.html>
<meta property=og:site_name content="Akira Kawata">
<meta property=og:type content=website>
<meta name=twitter:card content=summary>
<meta property=twitter:title content="How device file in Linux works">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","headline":"How device file in Linux works","url":"/articles/how-device-file-in-linux-works.html"}</script>
<style>body,h1,h2,h3,h4,p,pre,ul{margin:0;padding:0}body{font:400 16px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";color:#111;background-color:#fdfdfd;-webkit-text-size-adjust:100%;-webkit-font-feature-settings:"kern"1;-moz-font-feature-settings:"kern"1;-o-font-feature-settings:"kern"1;font-feature-settings:"kern"1;font-kerning:normal;display:flex;min-height:100vh;flex-direction:column}h1,h2,h3,h4,p,ul,.highlight{margin-bottom:15px}main{display:block}ul{margin-left:30px}li>ul{margin-bottom:0}h1,h2,h3,h4{font-weight:400}a{color:#2a7ae2;text-decoration:none}a:visited{color:#1756a9}a:hover{color:#111;text-decoration:underline}pre,code{font-size:15px;border:1px solid #e8e8e8;border-radius:3px;background-color:#eef}code{padding:1px 5px}pre{padding:8px 12px;overflow-x:auto}pre>code{border:0;padding-right:0;padding-left:0}.wrapper{max-width:-webkit-calc(800px - (30px*2));max-width:calc(800px - 30px*2);margin-right:auto;margin-left:auto;padding-right:30px;padding-left:30px}@media screen and (max-width:800px){.wrapper{max-width:-webkit-calc(800px - (30px));max-width:calc(800px - (30px));padding-right:15px;padding-left:15px}}.footer-col-wrapper:after,.wrapper:after{content:"";display:table;clear:both}.site-header{border-top:5px solid #424242;border-bottom:1px solid #e8e8e8;min-height:55.95px;position:relative}.site-title{font-size:26px;font-weight:300;line-height:54px;letter-spacing:-1px;margin-bottom:0;float:left}.site-title,.site-title:visited{color:#424242}.site-nav{float:right;line-height:54px}@media screen and (max-width:600px){.site-nav{position:absolute;top:9px;right:15px;background-color:#fdfdfd;border:1px solid #e8e8e8;border-radius:5px;text-align:right}.site-nav label[for=nav-trigger]{display:block;float:right;width:36px;height:36px;z-index:2;cursor:pointer}.site-nav .menu-icon>svg{fill:#424242}}.site-footer{border-top:1px solid #e8e8e8;padding:30px 0}@media screen and (max-width:800px){}@media screen and (max-width:600px){}.page-content{padding:30px 0;flex:1}@media screen and (max-width:800px){}@media screen and (max-width:800px){}@media screen and (max-width:800px){}@media screen and (max-width:800px){}.highlighter-rouge .highlight{background:#eef}</style><link type=application/atom+xml rel=alternate href=https://akawashiro.com/feed.xml title="Akira Kawata"><style id=ctre_styles>@media (prefers-color-scheme:dark){}</style><meta name=referrer content=no-referrer><link type=image/x-icon rel="shortcut icon" href=data:,><style>.sf-hidden{display:none!important}</style><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body><header class=site-header>
 <div class=wrapper><a class=site-title rel=author href=https://akawashiro.com/>Akira Kawata</a><nav class=site-nav>
 <input type=checkbox id=nav-trigger class="nav-trigger sf-hidden">
 <label for=nav-trigger>
 <span class="menu-icon sf-hidden">
 <svg viewBox="0 0 18 15" width=18px height=15px>
 <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
 </svg>
 </span>
 </label>
 </nav></div>
</header>
<main class=page-content aria-label=Content>
 <div class=wrapper>
 <h1 id=how-device-file-in-linux-works->How device file in Linux works </h1>
<p>A device file in Linux is an interface for various devices in the form of files. Although we can read and write a device file just the same as a normal file, read and write requests to device control requests by device file mechanism.</p>
<p>This article explains how Linux kernel and kernel modules convert read and write requests to device control requests. Because a device file depends on both a device driver and file system, I start this article with a chapter on a device driver and then file system. Finally, I show how the file system connects a device file with a device driver.</p>
<p>I wrote this article mainly using <a href=https://www.oreilly.co.jp/books/9784873113135/>Understanding the Linux Kernel, 3rd Edition</a> and <a href=https://github.com/torvalds/linux/tree/v6.1>https://github.com/torvalds/linux/tree/v6.1</a>.</p>
<h2 id=table-of-contents->Table of contents </h2>
<ul>
 <li><a href=#device-driver>Device driver</a>
 <ul>
 <li><a href=#example-of-device-driver>Example of device driver</a></li>
 <li><a href=#what-we-can-see-in-read_writec>What we can see in <code class="language-plaintext highlighter-rouge">read_write.c</code></a></li>
 <li><a href=#insmod>insmod</a>
 <ul>
 <li><a href=#insmod-in-user-space>insmod in user space</a></li>
 <li><a href=#insmod-in-kernel-space>insmod in kernel space</a></li>
 </ul>
 </li>
 </ul>
 </li>
 <li><a href=#file>File</a>
 <ul>
 <li><a href=#vfsvirtual-file-system>VFS(Virtual File System)</a>
 <ul>
 <li><a href=#inode>inode</a></li>
 <li><a href=#inode-of-normal-files>inode of normal files</a></li>
 <li><a href=#inode-of-device-files>inode of device files</a></li>
 </ul>
 </li>
 </ul>
 </li>
 <li><a href=#connect-device-driver-and-device-file>Connect device driver and device file</a>
 <ul>
 <li><a href=#mknod>mknod</a>
 <ul>
 <li><a href=#mknod-in-user-space>mknod in user space</a></li>
 <li><a href=#mknod-in-kernel-space>mknod in kernel space</a></li>
 </ul>
 </li>
 </ul>
 </li>
 <li><a href=#reference>Reference</a></li>
 <li><a href=#contacts>Contacts</a></li>
</ul>
<h2 id=device-driver>Device driver</h2>
<p>A device driver is a collection of kernel routines. Each routine corresponds to one Virtual File System (VFS) operation, which I will explain later.</p>
<h3 id=example-of-device-driver>Example of device driver</h3>
<p>I show a small but complete example of device driver below. This example is composed of <code class="language-plaintext highlighter-rouge">read_write.c</code> and <code class="language-plaintext highlighter-rouge">Makefile</code>. These two files are from <a href=https://github.com/Johannes4Linux/Linux_Driver_Tutorial/tree/main/03_read_write>Johannes4Linux/Linux_Driver_Tutorial/03_read_write</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>/ *read_write.c * /
#include &lt;linux/cdev.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/uaccess.h&gt;

    MODULE_LICENSE("GPL");

#define DRIVER_MAJOR 333
#define DRIVER_NAME "read_write_driver"

static ssize_t driver_read(struct file *File, char *user_buffer, size_t count,
                           loff_t *offs) {
  user_buffer[0] = 'A';
  return 1;
}

static ssize_t driver_write(struct file *File, const char *user_buffer,
                            size_t count, loff_t *offs) {
  return 1;
}

static int driver_open(struct inode *device_file, struct file *instance) {
  printk("read_write_driver - open was called!\n");
  return 0;
}

static int driver_close(struct inode *device_file, struct file *instance) {
  printk("read_write_driver - close was called!\n");
  return 0;
}

static struct file_operations fops = {.open = driver_open,
                                      .release = driver_close,
                                      .read = driver_read,
                                      .write = driver_write};

static int __init ModuleInit(void) {
  printk("read_write_driver - ModuleInit was called!\n");
  register_chrdev(DRIVER_MAJOR, DRIVER_NAME, &amp;fops);
  return 0;
}

static void __exit ModuleExit(void) {
  printk("read_write_driver - ModuleExit was called!\n");
  unregister_chrdev(DRIVER_MAJOR, DRIVER_NAME);
}

module_init(ModuleInit);
module_exit(ModuleExit);
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code># Makefile
obj-m += read_write.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</code></pre></div></div>
<p>Use the below commands to build and install this example device driver example to your Linux. Then, you can read infinite <code class="language-plaintext highlighter-rouge">A</code> from the device file.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>$ make
$ sudo insmod read_write.ko
$ sudo mknod /dev/read_write c 333 1
$ cat /dev/read_write
AAAAAA...
</code></pre></div></div>
<h3 id=what-we-can-see-in-read_writec>What we can see in <code class="language-plaintext highlighter-rouge">read_write.c</code></h3>
<p>We can see in ``read_write.c`:</p>
<ul>
 <li>The major number of this device driver is <code class="language-plaintext highlighter-rouge">333</code>.
 <ul>
 <li>For your information, this major number <code class="language-plaintext highlighter-rouge">333</code> has no meaning. You can rewrite it with any arbitrary number.</li>
 </ul>
 </li>
 <li>A Device driver is just a collection of functions.</li>
 <li><code class="language-plaintext highlighter-rouge">open(2)</code>, <code class="language-plaintext highlighter-rouge">release(2)</code>, <code class="language-plaintext highlighter-rouge">read(2)</code> and <code class="language-plaintext highlighter-rouge">write(2)</code> are corresponds to <code class="language-plaintext highlighter-rouge">myDevice_open</code>, <code class="language-plaintext highlighter-rouge">driver_close</code>, <code class="language-plaintext highlighter-rouge">myDevice_read</code> and <code class="language-plaintext highlighter-rouge">driver_write</code>.</li>
</ul>
<p>Because <code class="language-plaintext highlighter-rouge">cat /dev/read_write</code> calls <code class="language-plaintext highlighter-rouge">driver_read</code> of this device driver, infinite <code class="language-plaintext highlighter-rouge">A</code>s are read from it.</p>
<h3 id=insmod>insmod</h3>
<p><code class="language-plaintext highlighter-rouge">insmod(8)</code> is a command to load a kernel module into the Linux kernel. In this section, I explain how <code class="language-plaintext highlighter-rouge">sudo insmod read_write.ko</code> load <code class="language-plaintext highlighter-rouge">read_write.ko</code> into the kernel.</p>
<h4 id=insmod-in-user-space>insmod in user space</h4>
<p><code class="language-plaintext highlighter-rouge">strace(1)</code> shows <code class="language-plaintext highlighter-rouge">insmod(8)</code> calls <code class="language-plaintext highlighter-rouge">finit_module(2)</code> system call.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code># strace insmod read_write.ko
...
openat(AT_FDCWD, "/home/akira/misc/linux-device-file/driver_for_article/read_write.ko", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1", 6)               = 6
lseek(3, 0, SEEK_SET)                   = 0
newfstatat(3, "", {st_mode=S_IFREG|0664, st_size=6936, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 6936, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fc8aae77000
finit_module(3, "", 0)                  = 0
munmap(0x7fc8aae77000, 6936)            = 0
close(3)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre></div></div>
<h4 id=insmod-in-kernel-space>insmod in kernel space</h4>
<p><code class="language-plaintext highlighter-rouge">finit_module(2)</code> is defined in Linux kernel at <a href=https://github.com/akawashiro/linux/blob/4aeb800558b98b2a39ee5d007730878e28da96ca/kernel/module/main.c#L2916>kernel/module/main.c#29l6</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>SYSCALL_DEFINE3(finit_module, int, fd, const char __user *, uargs, int, flags)
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">finit_module(2)</code> calls <a href=https://github.com/akawashiro/linux/blob/4aeb800558b98b2a39ee5d007730878e28da96ca/kernel/module/main.c#L2440>do_init_module</a> which initialise the kernel module.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>/*
 * This is where the real work happens.
 *
 * Keep it uninlined to provide a reliable breakpoint target, e.g. for the gdb
 * helper command 'lx-symbols'.
 */
static noinline int do_init_module(struct module *mod)
</code></pre></div></div>
<p><a href=https://github.com/akawashiro/linux/blob/4aeb800558b98b2a39ee5d007730878e28da96ca/kernel/module/main.c#L2440>do_init_module</a> calls <code class="language-plaintext highlighter-rouge">ModuleInit</code> in the device driver through <a href=https://github.com/akawashiro/linux/blob/4aeb800558b98b2a39ee5d007730878e28da96ca/kernel/module/main.c#L2455>ret = do_one_initcall(mod-&gt;init);</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>    /* Start the module */
    if (mod-&gt;init != NULL)
        ret = do_one_initcall(mod-&gt;init);
    if (ret &lt; 0) {
        goto fail_free_freeinit;
    }
</code></pre></div></div>
<p><a href=https://github.com/akawashiro/linux/blob/7c8da299ff040d55f3e2163e6725cb1eef7155a9/arch/x86/kernel/module.c#L131-L220>__apply_relocate_add</a> set <code class="language-plaintext highlighter-rouge">mod-&gt;init</code>. This function process relocation information in the kernel module as we can infer from its name. Although I tried to understand the relationship between relocation information in the kernel module and <code class="language-plaintext highlighter-rouge">mod-&gt;init</code> by inserting many <code class="language-plaintext highlighter-rouge">printk</code>, I failed. Please tell me if you know it.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>static int __apply_relocate_add(Elf64_Shdr *sechdrs,
           const char *strtab,
           unsigned int symindex,
           unsigned int relsec,
           struct module *me,
           void *(*write)(void *dest, const void *src, size_t len))
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">ModuleInit</code>, called through <code class="language-plaintext highlighter-rouge">mod-&gt;init</code>, calls <a href=https://github.com/akawashiro/linux/blob/7c8da299ff040d55f3e2163e6725cb1eef7155a9/fs/char_dev.c#L247-L302>__register_chrdev</a> and <a href=https://github.com/akawashiro/linux/blob/7c8da299ff040d55f3e2163e6725cb1eef7155a9/drivers/base/map.c#L32-L66>kobj_map</a>. <a href=https://github.com/akawashiro/linux/blob/7c8da299ff040d55f3e2163e6725cb1eef7155a9/drivers/base/map.c#L32-L66>kobj_map</a> register the kernel module device to <a href=https://github.com/akawashiro/linux/blob/7c8da299ff040d55f3e2163e6725cb1eef7155a9/fs/char_dev.c#L28>cdev_map</a>. This is the end of loading process of the kernel module.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>int kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range,
         struct module *module, kobj_probe_t *probe,
         int (*lock)(dev_t, void *), void *data)
{
    ...
    mutex_lock(domain-&gt;lock);
    for (i = 0, p -= n; i &lt; n; i++, p++, index++) {
        struct probe **s = &amp;domain-&gt;probes[index % 255];
        while (*s &amp;&amp; (*s)-&gt;range &lt; range)
            s = &amp;(*s)-&gt;next;
        p-&gt;next = *s;
        *s = p;
    }
    ...
}
</code></pre></div></div>
<h2 id=file>File</h2>
<p>This section explains “file” of “device file”.</p>
<h3 id=vfsvirtual-file-system>VFS(Virtual File System)</h3>
<p>VFS is a software layer in the Linux kernel that handles all standard UNIX filesystem system calls. It offers <code class="language-plaintext highlighter-rouge">open(2)</code>, <code class="language-plaintext highlighter-rouge">close(2)</code>, <code class="language-plaintext highlighter-rouge">write(2)</code> and etc. Owing to this software layer, users can use the same software for different file systems such as <code class="language-plaintext highlighter-rouge">ext4</code>, <code class="language-plaintext highlighter-rouge">NFS</code>, <code class="language-plaintext highlighter-rouge">proc</code>. For example, <code class="language-plaintext highlighter-rouge">cat(1)</code> can do both <code class="language-plaintext highlighter-rouge">cat /proc/self/maps</code> and <code class="language-plaintext highlighter-rouge">cat ./README.md</code>. However, <code class="language-plaintext highlighter-rouge">cat /proc/self/maps</code> shows memory map, and <code class="language-plaintext highlighter-rouge">cat ./README.md</code> shows a part of the disk.</p>
<p>VFS is implemented in an objected-oriented way using struct and function pointers.</p>
<h4 id=inode>inode</h4>
<p>inode object in VFS is an object that represents “normal files”. It is defined in <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/include/linux/fs.h#L588-L703>include/linux/fs.h</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>struct inode {
    umode_t         i_mode;
    unsigned short      i_opflags;
    kuid_t          i_uid;
    kgid_t          i_gid;
    unsigned int        i_flags;
  ...
  union {
        struct pipe_inode_info  *i_pipe;
        struct cdev     *i_cdev;
        char            *i_link;
        unsigned        i_dir_seq;
    };
  ...
};
</code></pre></div></div>
<p>Other objects in VFS are superblock object which holds information of the filesystem itself, file objects which have information of opened file and process, d entry objects which have information on directories.</p>
<h4 id=inode-of-normal-files>inode of normal files</h4>
<p><code class="language-plaintext highlighter-rouge">stat(1)</code> shows the inode information of the file, which corresponds to <code class="language-plaintext highlighter-rouge">struct inode</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>[@goshun](master)~/misc/linux-device-file
&gt; stat README.md
  File: README.md
  Size: 20              Blocks: 8          IO Block: 4096   regular file
Device: fd01h/64769d    Inode: 49676330    Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/   akira)   Gid: ( 1000/   akira)
Access: 2023-01-28 11:19:15.104727788 +0900
Modify: 2023-01-28 11:19:13.748734093 +0900
Change: 2023-01-28 11:19:13.748734093 +0900
 Birth: 2023-01-28 11:19:13.748734093 +0900
</code></pre></div></div>
<h4 id=inode-of-device-files>inode of device files</h4>
<p>Because a device file is just a file, it has inode also. To find device files on your computer, you can use <code class="language-plaintext highlighter-rouge">ls -il</code>. Character device files start with <code class="language-plaintext highlighter-rouge">c</code>, and block device files starts with <code class="language-plaintext highlighter-rouge">b</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>[@goshun]/dev
&gt; ls -il /dev/nvme0*
201 crw------- 1 root root 240, 0  1月 29 19:02 /dev/nvme0
319 brw-rw---- 1 root disk 259, 0  1月 29 19:02 /dev/nvme0n1
320 brw-rw---- 1 root disk 259, 1  1月 29 19:02 /dev/nvme0n1p1
321 brw-rw---- 1 root disk 259, 2  1月 29 19:02 /dev/nvme0n1p2
322 brw-rw---- 1 root disk 259, 3  1月 29 19:02 /dev/nvme0n1p3
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>[@goshun](master)~/misc/linux-device-file
&gt; stat /dev/nvme0n1
  File: /dev/nvme0n1
  Size: 0               Blocks: 0          IO Block: 4096   block special file
Device: 5h/5d   Inode: 319         Links: 1     Device type: 103,0
Access: (0660/brw-rw----)  Uid: (    0/    root)   Gid: (    6/    disk)
Access: 2023-01-28 10:03:26.964000726 +0900
Modify: 2023-01-28 10:03:26.960000726 +0900
Change: 2023-01-28 10:03:26.960000726 +0900
 Birth: -
</code></pre></div></div>
<h2 id=connect-device-driver-and-device-file>Connect device driver and device file</h2>
<h3 id=mknod>mknod</h3>
<p><code class="language-plaintext highlighter-rouge">mknod(1)</code> is a command to make a special file such as a character device file or a block device file. I made <code class="language-plaintext highlighter-rouge">/dev/read_write</code> using <code class="language-plaintext highlighter-rouge">sudo mknod /dev/read_write c 333 1</code> in <a href=#example-of-device-driver>Example of device driver</a>. <a href=https://man7.org/linux/man-pages/man2/mknod.2.html>mknod(2)</a> is a system call used in <code class="language-plaintext highlighter-rouge">mknod(1)</code> and used to make a node on filesystems.</p>
<h4 id=mknod-in-user-space>mknod in user space</h4>
<p>Let’s check how <code class="language-plaintext highlighter-rouge">mknod(2)</code> are called using <code class="language-plaintext highlighter-rouge">strace(1)</code>. I show the output of <code class="language-plaintext highlighter-rouge">strace mknod /dev/read_write c 333 1</code> below. Because <code class="language-plaintext highlighter-rouge">0x14d</code> is <code class="language-plaintext highlighter-rouge">333</code> in decimal,<code class="language-plaintext highlighter-rouge">mknod(2)</code> make an inode with <code class="language-plaintext highlighter-rouge">333</code> major number and <code class="language-plaintext highlighter-rouge">1</code> minor number.</p>
<p>As a side note, <code class="language-plaintext highlighter-rouge">mknod(2)</code> and <code class="language-plaintext highlighter-rouge">mknodat(2)</code> are almost the same. The only difference is <code class="language-plaintext highlighter-rouge">mknod(2)</code> takes a relative path, although <code class="language-plaintext highlighter-rouge">mknodat(2)</code> takes an absolute path.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code># strace mknod /dev/read_write c 333 1
...
close(3)                                = 0
mknodat(AT_FDCWD, "/dev/read_write", S_IFCHR|0666, makedev(0x14d, 0x1)) = 0
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre></div></div>
<h4 id=mknod-in-kernel-space>mknod in kernel space</h4>
<p><code class="language-plaintext highlighter-rouge">mknodat(2)</code> in kernel space starts from <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/namei.c#L3939-L3988>do_mknodat</a>. From now, I follow all code relating to the connection between a device file and a device driver. From now, the device is a character device, and the filesystem is ext4 for simplicity.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>static int do_mknodat(int dfd, struct filename *name, umode_t mode,
        unsigned int dev)
</code></pre></div></div>
<p><a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/namei.c#L3939-L3988>do_mknodat</a> calls <code class="language-plaintext highlighter-rouge">vfs_mknod</code> in <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/namei.c#L3970-L3972>fs/namei.c#L3970-L3972</a> to make a character device or a block device.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>        case S_IFCHR: case S_IFBLK:
            error = vfs_mknod(mnt_userns, path.dentry-&gt;d_inode,
                      dentry, mode, new_decode_dev(dev));
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">vfs_mknod</code> is defined at <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/namei.c#L3874-L3891>fs/namei.c#L3874-L3891</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>/**
 * vfs_mknod - create device node or file
 * @mnt_userns: user namespace of the mount the inode was found from
 * @dir:    inode of @dentry
 * @dentry: pointer to dentry of the base directory
 * @mode:   mode of the new device node or file
 * @dev:    device number of device to create
 *
 * Create a device node or file.
 *
 * If the inode has been found through an idmapped mount the user namespace of
 * the vfsmount must be passed through @mnt_userns. This function will then take
 * care to map the inode according to @mnt_userns before checking permissions.
 * On non-idmapped mounts or if permission checking is to be performed on the
 * raw inode simply passs init_user_ns.
 */
int vfs_mknod(struct user_namespace *mnt_userns, struct inode *dir,
          struct dentry *dentry, umode_t mode, dev_t dev)
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">vfs_mknod</code> calls <code class="language-plaintext highlighter-rouge">mknod</code> of dentry. Although implementation of <code class="language-plaintext highlighter-rouge">mknod</code> are different depending on filesystems, we follow <code class="language-plaintext highlighter-rouge">mknod</code> of <code class="language-plaintext highlighter-rouge">ext4</code> in this article. <code class="language-plaintext highlighter-rouge">vfs_mknod</code> calls <code class="language-plaintext highlighter-rouge">mknod</code> at <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/namei.c#L3915>fs/namei.c#L3915</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>    error = dir-&gt;i_op-&gt;mknod(mnt_userns, dir, dentry, mode, dev);
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">mknod</code> of <code class="language-plaintext highlighter-rouge">ext4</code> is defined at <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/ext4/namei.c#L4191>fs/ext4/namei.c#L4191</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>const struct inode_operations ext4_dir_inode_operations = {
    ...
    .mknod      = ext4_mknod,
    ...
};
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">ext4_mknod</code> is defined at <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/ext4/namei.c#L2830-L2862>fs/ext4/namei.c#L2830-L2862</a>. <code class="language-plaintext highlighter-rouge">init_special_inode</code> may have something to do with device initilization.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>static int ext4_mknod(struct user_namespace *mnt_userns, struct inode *dir,
              struct dentry *dentry, umode_t mode, dev_t rdev)
{
    ...
        init_special_inode(inode, inode-&gt;i_mode, rdev);
    ...
}
</code></pre></div></div>
<p>For character devices, <code class="language-plaintext highlighter-rouge">def_chr_fops</code> is set at <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/inode.c#L2291-L2309>fs/inode.c#L2291-L2309</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)
{
    inode-&gt;i_mode = mode;
    if (S_ISCHR(mode)) {
        inode-&gt;i_fop = &amp;def_chr_fops;
        inode-&gt;i_rdev = rdev;
    } else if (S_ISBLK(mode)) {
    ...
  }
}
EXPORT_SYMBOL(init_special_inode);
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">def_chr_fops</code> is defined at <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/char_dev.c#L447-L455>fs/char_dev.c#L447-L455</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>/*
 * Dummy default file-operations: the only thing this does
 * is contain the open that then fills in the correct operations
 * depending on the special file...
 */
const struct file_operations def_chr_fops = {
    .open = chrdev_open,
    .llseek = noop_llseek,
};
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">chrdev_open</code> searches device driver in <code class="language-plaintext highlighter-rouge">kobj_lookup</code> defined at <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/fs/char_dev.c#L370-L424>fs/char_dev.c#L370-L424</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>/*
 * Called every time a character special file is opened
 */
static int chrdev_open(struct inode *inode, struct file *filp)
{
...
        kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);
...
}
</code></pre></div></div>
<p>Finally, we reached <a href=https://github.com/akawashiro/linux/blob/7c8da299ff040d55f3e2163e6725cb1eef7155a9/drivers/base/map.c#L32-L66>kobj_map</a> which we have seen in <code class="language-plaintext highlighter-rouge">insmod</code>. <a href=https://github.com/akawashiro/linux/blob/830b3c68c1fb1e9176028d02ef86f3cf76aa2476/drivers/base/map.c#L95-L133>drivers/base/map.c#L95-L133</a> connects a device driver to a device file.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>struct kobject *kobj_lookup(struct kobj_map *domain, dev_t dev, int *index)
{
    struct kobject *kobj;
    struct probe *p;
    unsigned long best = ~0UL;

retry:
    mutex_lock(domain-&gt;lock);
    for (p = domain-&gt;probes[MAJOR(dev) % 255]; p; p = p-&gt;next) {
        struct kobject *(*probe)(dev_t, int *, void *);
        struct module *owner;
        void *data;

        if (p-&gt;dev &gt; dev || p-&gt;dev + p-&gt;range - 1 &lt; dev)
            continue;
        if (p-&gt;range - 1 &gt;= best)
            break;
        if (!try_module_get(p-&gt;owner))
            continue;
        owner = p-&gt;owner;
        data = p-&gt;data;
        probe = p-&gt;get;
        best = p-&gt;range - 1;
        *index = dev - p-&gt;dev;
        if (p-&gt;lock &amp;&amp; p-&gt;lock(dev, data) &lt; 0) {
            module_put(owner);
            continue;
        }
        mutex_unlock(domain-&gt;lock);
        kobj = probe(dev, index, data);
        /* Currently -&gt;owner protects _only_ -&gt;probe() itself. */
        module_put(owner);
        if (kobj)
            return kobj;
        goto retry;
    }
    mutex_unlock(domain-&gt;lock);
    return NULL;
}

</code></pre></div></div>
<p>At last, I confirm my understanding by patching the Linux kernel. I added a <code class="language-plaintext highlighter-rouge">printk</code> at <a href=https://github.com/akawashiro/linux/blob/4aeb800558b98b2a39ee5d007730878e28da96ca/drivers/base/map.c#L114-L115>drivers/base/map.c#L114-L115</a>, installed custom kernel and made a device driver just same as <a href=#example-of-device-driver>Example of device driver</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>&gt; git diff --patch "device-file-experiment~1"
diff --git a/drivers/base/map.c b/drivers/base/map.c
index 83aeb09ca161..57037223932e 100644
--- a/drivers/base/map.c
+++ b/drivers/base/map.c
@@ -111,6 +111,8 @@ struct kobject *kobj_lookup(struct kobj_map *domain, dev_t dev, int *index)
                        break;
                if (!try_module_get(p-&gt;owner))
                        continue;
+
+               printk("%s:%d MAJOR(dev)=%u MINOR(dev)=%u\n", __FILE__, __LINE__, MAJOR(dev), MINOR(dev));
                owner = p-&gt;owner;
                data = p-&gt;data;
                probe = p-&gt;get;
</code></pre></div></div>
<p>I show the <code class="language-plaintext highlighter-rouge">dmesg -wH</code> result when <code class="language-plaintext highlighter-rouge">cat /dev/read_write</code>. You can see that <code class="language-plaintext highlighter-rouge">read_write_driver</code> is called when <code class="language-plaintext highlighter-rouge">cat(2)</code> open <code class="language-plaintext highlighter-rouge">/dev/read_write</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code># dmesg -wH
...
[ +18.898110] drivers/base/map.c:115 MAJOR(dev)=136 MINOR(dev)=2
[ +10.920752] drivers/base/map.c:115 MAJOR(dev)=136 MINOR(dev)=3
[  +9.170364] loop0: detected capacity change from 0 to 8
[  +1.212845] drivers/base/map.c:115 MAJOR(dev)=333 MINOR(dev)=1
[  +0.000010] read_write_driver - open was called!
[  +2.141643] read_write_driver - close was called!
</code></pre></div></div>
<h2 id=reference>Reference</h2>
<ul>
 <li><a href=https://www.oreilly.co.jp/books/9784873113135/>Understanding the Linux Kernel, 3rd Edition</a></li>
 <li><a href=https://github.com/Johannes4Linux/Linux_Driver_Tutorial>Johannes4Linux/Linux_Driver_Tutorial</a></li>
 <li><a href=https://man7.org/linux/man-pages/man2/init_module.2.html>init_module(2) — Linux manual page</a></li>
 <li><a href=https://qiita.com/hon_no_mushi/items/9865febd245afd887d26>linux kernel における insmod の裏側を確認</a></li>
 <li><a href=https://github.com/torvalds/linux/tree/v6.1>https://github.com/torvalds/linux/tree/v6.1</a></li>
 <li><a href=https://qiita.com/iwatake2222/items/1fdd2e0faaaa868a2db2>組み込み Linux デバイスドライバの作り方</a></li>
 <li><a href=https://qiita.com/rarul/items/308d4eef138b511aa233>Linux のドライバの初期化が呼ばれる流れ</a></li>
</ul>
<h2 id=contacts>Contacts</h2>
<p>If you find any bug in this article, please get in touch with me at <a href=https://twitter.com/a_kawashiro>twitter.com/a_kawashiro</a>. You can find other contact information at <a href=https://akawashiro.github.io/>https://akawashiro.github.io/</a>.</p>
 </div>
 </main><footer class="site-footer h-card">
</footer>
