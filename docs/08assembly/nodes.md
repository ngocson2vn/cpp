# x86-64 architecture
The x86-64 architecture was originally proposed and designed by AMD.<br/>
AMD announced the extension in 1999 under the name AMD64, and it was first implemented in their Opteron processors in April 2003. Intel, at the time, was focused on a different, incompatible 64-bit architecture called Itanium (IA-64), which was not backward-compatible with existing 32-bit x86 software and ultimately failed to gain widespread market adoption. 

Because of the superior backward compatibility and market success of AMD's design, Intel eventually licensed the architecture from AMD and released its own compatible implementation under various names, including IA-32e, EM64T, and finally, Intel 64. 

The generic, vendor-neutral name for this instruction set is **x86-64** (or sometimes just x64).

# Linux x64 Calling Convention
[Linux x64 Calling Convention： Stack Frame ｜ Red Team Notes (1_22_2025 4：44：27 PM).html](./Linux%20x64%20Calling%20Convention：%20Stack%20Frame%20｜%20Red%20Team%20Notes%20(1_22_2025%204：44：27%20PM).html)

The calling convention defines where arguments go, who saves which registers, and where return values are placed.<br/>
Below are the common conventions you’re likely to encounter.<br/>
## x86-64 (AMD64)
- System V AMD64 ABI (Linux, macOS, BSD):
  - Integer/pointer return: `RAX`
  - 128-bit integer (e.g., `__int128`): `RDX:RAX` (low in `RAX`, high in `RDX`)
  - Floating-point (float/double): `XMM0`
  - Long double (80-bit): `ST0` (x87) on some systems; on modern SysV it’s usually in `XMM0`/`ST0` depending on compiler options/ABI
  - Small structs:
    - If they fit in 1–2 eightbyte units and are classified as INTEGER/SSE per the ABI, they’re returned in `RAX`/`RDX` or `XMM0`/`XMM1`.
  - Large structs: caller passes a hidden pointer to return area; callee writes to it and returns that pointer in `RAX` (or just uses the hidden pointer).
<br/>


For example,
```C++
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./main --model-dir ./models/dvf_snapshot_test_r1224885_0 --input-dir /data00/ho'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fc5386093e9 in _sony_ciface_run_final_11d7d57_87 () from /tmp/tempfile-n193-085-131-9d7a92e0-2513381-645173c54db02
[Current thread is 1 (Thread 0x7fc439ffb000 (LWP 2513500))]
(gdb) bt
#0  0x00007fc5386093e9 in _sony_ciface_run_final_11d7d57_87 () from /tmp/tempfile-n193-085-131-9d7a92e0-2513381-645173c54db02
#1  0x00000000042e7904 in operators::framework::auto_gen::sonyMLIROpKernel::Compute (this=0x17026a20, ctx=0x7fc439faf310) at erdos/operators/framework/tf/auto_fusion/dyn_auto_gen_kernel.cpp:483
#2  0x00007fc5c65bec56 in tensorflow::BaseGPUDevice::Compute(tensorflow::OpKernel*, tensorflow::OpKernelContext*) () from ./lib/libtensorflow_framework.so.2
#3  0x00007fc5c66b2b56 in tensorflow::(anonymous namespace)::ExecutorState<tensorflow::PropagatorState>::Process(tensorflow::PropagatorState::TaggedNode, long) () from ./lib/libtensorflow_framework.so.2
#4  0x00007fc5c66b3be8 in std::_Function_handler<void (), tensorflow::(anonymous namespace)::ExecutorState<tensorflow::PropagatorState>::RunTask<tensorflow::(anonymous namespace)::ExecutorState<tensorflow::PropagatorState>::ScheduleReady(absl::lts_2020_09_23::InlinedVector<tensorflow::PropagatorState::TaggedNode, 8ul, std::allocator<tensorflow::PropagatorState::TaggedNode> >*, tensorflow::PropagatorState::TaggedNodeReadyQueue*)::{lambda()#2}>(tensorflow::(anonymous namespace)::ExecutorState<tensorflow::PropagatorState>::ScheduleReady(absl::lts_2020_09_23::InlinedVector<tensorflow::PropagatorState::TaggedNode, 8ul, std::allocator<tensorflow::PropagatorState::TaggedNode> >*, tensorflow::PropagatorState::TaggedNodeReadyQueue*)::{lambda()#2}&&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) () from ./lib/libtensorflow_framework.so.2
#5  0x00007fc61f82eb26 in Eigen::ThreadPoolTempl<tensorflow::thread::EigenEnvironment>::WorkerLoop(int) () from ./lib/libtensorflow_cc.so.2
#6  0x00007fc61f82c123 in std::_Function_handler<void (), tensorflow::thread::EigenEnvironment::CreateThread(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) () from ./lib/libtensorflow_cc.so.2
#7  0x00007fc5c6981b55 in tensorflow::(anonymous namespace)::PThread::ThreadFn(void*) () from ./lib/libtensorflow_framework.so.2
#8  0x00007fc5aba75ca9 in start_thread (arg=0x7fc439ffb000) at pthread_create.c:486
#9  0x00007fc5a955571f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
(gdb) f 0
#0  0x00007fc5386093e9 in _sony_ciface_run_final_11d7d57_87 () from /tmp/tempfile-n193-085-131-9d7a92e0-2513381-645173c54db02
(gdb) disassemble 
Dump of assembler code for function _sony_ciface_run_final_11d7d57_87:
   0x00007fc5386093a0 <+0>:     push   %r15
   0x00007fc5386093a2 <+2>:     push   %r14
   0x00007fc5386093a4 <+4>:     push   %r13
   0x00007fc5386093a6 <+6>:     push   %r12
   0x00007fc5386093a8 <+8>:     push   %rbx
   0x00007fc5386093a9 <+9>:     mov    %rsi,%r14
   0x00007fc5386093ac <+12>:    mov    %rdi,%rbx
   0x00007fc5386093af <+15>:    mov    (%rdx),%rax
   0x00007fc5386093b2 <+18>:    mov    0x18(%rax),%r12
   0x00007fc5386093b6 <+22>:    mov    0x20(%rax),%r13
   0x00007fc5386093ba <+26>:    mov    $0x4,%r15d
   0x00007fc5386093c0 <+32>:    mov    $0x4,%esi
   0x00007fc5386093c5 <+37>:    mov    $0x4,%edx
   0x00007fc5386093ca <+42>:    mov    %r14,%rdi
   0x00007fc5386093cd <+45>:    mov    $0xffffffff,%ecx
   0x00007fc5386093d2 <+50>:    xor    %r8d,%r8d
   0x00007fc5386093d5 <+53>:    xor    %r9d,%r9d
   0x00007fc5386093d8 <+56>:    callq  0x7fc5385f22d0 <_sony_ciface_alloc@plt>
   0x00007fc5386093dd <+61>:    test   %rax,%rax
   0x00007fc5386093e0 <+64>:    je     0x7fc538609400 <_sony_ciface_run_final_11d7d57_87+96>
   0x00007fc5386093e2 <+66>:    mov    $0x1,%ecx
   0x00007fc5386093e7 <+71>:    xor    %edx,%edx
=> 0x00007fc5386093e9 <+73>:    mov    %r12d,(%rax)
   0x00007fc5386093ec <+76>:    mov    %r13d,0x4(%rax)
   0x00007fc5386093f0 <+80>:    movabs $0x2000000001,%rsi
   0x00007fc5386093fa <+90>:    mov    %rsi,0x8(%rax)
   0x00007fc5386093fe <+94>:    jmp    0x7fc53860941d <_sony_ciface_run_final_11d7d57_87+125>
   0x00007fc538609400 <+96>:    lea    0x1ca659(%rip),%rdx        # 0x7fc5387d3a60 <error_message_18271215307014969330>
   0x00007fc538609407 <+103>:   mov    %r14,%rdi
   0x00007fc53860940a <+106>:   mov    $0x8,%esi
   0x00007fc53860940f <+111>:   callq  0x7fc5385f2240 <_sony_ciface_report_error@plt>
   0x00007fc538609414 <+116>:   mov    $0x1,%ecx
   0x00007fc538609419 <+121>:   xor    %eax,%eax
   0x00007fc53860941b <+123>:   xor    %edx,%edx
   0x00007fc53860941d <+125>:   mov    %rax,(%rbx)
   0x00007fc538609420 <+128>:   mov    %rax,0x8(%rbx)
   0x00007fc538609424 <+132>:   mov    %rdx,0x10(%rbx)
   0x00007fc538609428 <+136>:   mov    %r15,0x18(%rbx)
   0x00007fc53860942c <+140>:   mov    %rcx,0x20(%rbx)
   0x00007fc538609430 <+144>:   pop    %rbx
   0x00007fc538609431 <+145>:   pop    %r12
   0x00007fc538609433 <+147>:   pop    %r13
   0x00007fc538609435 <+149>:   pop    %r14
   0x00007fc538609437 <+151>:   pop    %r15
   0x00007fc538609439 <+153>:   retq   
End of assembler dump.
(gdb) 
```
`0x00007fc5386093d8 <+56>:    callq  0x7fc5385f22d0 <_sony_ciface_alloc@plt>`
- Allocate a GPU buffer
- Store the address of the GPU buffer into `%rax`

`0x00007fc5386093dd <+61>:    test   %rax,%rax`
- Test whether `%rax` is zero or not
- If `%rax` is zero, set Zero Flag (ZF) = 1

`0x00007fc5386093e0 <+64>:    je     0x7fc538609400 <_sony_ciface_run_final_11d7d57_87+96>`
- Jump to `0x7fc538609400 <_sony_ciface_run_final_11d7d57_87+96>` if ZF=1


# %rip
The special %rip register stores the address of the next instruction to execute. If we jump to another instruction or call another function, %rip is updated. In particular, when we call another function, we must save the caller's next instruction to execute so that we can resume there when the callee finishes. The call instruction does this for us automatically by storing it on the stack, and the ret instruction pops the value off into %rip.

The %rip register on x86-64 is a special-purpose register that always holds the memory address of the next instruction to execute in the program's code segment. The processor increments %rip automatically after each instruction, and control flow instructions like branches set the value of %rip to change the next instruction.
Perhaps surprisingly, %rip also shows up when an assembly program refers to a global variable. See the sidebar under "Addressing modes" below to understand how %rip-relative addressing works.