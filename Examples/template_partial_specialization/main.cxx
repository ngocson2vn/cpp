namespace std {
    typedef unsigned long size_t;
    typedef long ptrdiff_t;
    typedef decltype(nullptr) nullptr_t;
}
namespace std {
    inline namespace __cxx11 {
    }
}
namespace __gnu_cxx {
    inline namespace __cxx11 {
    }
}
extern "C" {
    typedef unsigned long size_t;
    typedef __builtin_va_list va_list;
    typedef __builtin_va_list __gnuc_va_list;
    typedef unsigned char __u_char;
    typedef unsigned short __u_short;
    typedef unsigned int __u_int;
    typedef unsigned long __u_long;
    typedef signed char __int8_t;
    typedef unsigned char __uint8_t;
    typedef short __int16_t;
    typedef unsigned short __uint16_t;
    typedef int __int32_t;
    typedef unsigned int __uint32_t;
    typedef long __int64_t;
    typedef unsigned long __uint64_t;
    typedef __int8_t __int_least8_t;
    typedef __uint8_t __uint_least8_t;
    typedef __int16_t __int_least16_t;
    typedef __uint16_t __uint_least16_t;
    typedef __int32_t __int_least32_t;
    typedef __uint32_t __uint_least32_t;
    typedef __int64_t __int_least64_t;
    typedef __uint64_t __uint_least64_t;
    typedef long __quad_t;
    typedef unsigned long __u_quad_t;
    typedef long __intmax_t;
    typedef unsigned long __uintmax_t;
    typedef unsigned long __dev_t;
    typedef unsigned int __uid_t;
    typedef unsigned int __gid_t;
    typedef unsigned long __ino_t;
    typedef unsigned long __ino64_t;
    typedef unsigned int __mode_t;
    typedef unsigned long __nlink_t;
    typedef long __off_t;
    typedef long __off64_t;
    typedef int __pid_t;
    typedef struct {
        int __val[2];
    } __fsid_t;
    typedef long __clock_t;
    typedef unsigned long __rlim_t;
    typedef unsigned long __rlim64_t;
    typedef unsigned int __id_t;
    typedef long __time_t;
    typedef unsigned int __useconds_t;
    typedef long __suseconds_t;
    typedef int __daddr_t;
    typedef int __key_t;
    typedef int __clockid_t;
    typedef void *__timer_t;
    typedef long __blksize_t;
    typedef long __blkcnt_t;
    typedef long __blkcnt64_t;
    typedef unsigned long __fsblkcnt_t;
    typedef unsigned long __fsblkcnt64_t;
    typedef unsigned long __fsfilcnt_t;
    typedef unsigned long __fsfilcnt64_t;
    typedef long __fsword_t;
    typedef long __ssize_t;
    typedef long __syscall_slong_t;
    typedef unsigned long __syscall_ulong_t;
    typedef __off64_t __loff_t;
    typedef char *__caddr_t;
    typedef long __intptr_t;
    typedef unsigned int __socklen_t;
    typedef int __sig_atomic_t;
    typedef struct {
        int __count;
        union {
            unsigned int __wch;
            char __wchb[4];
        } __value;
    } __mbstate_t;
    typedef struct _G_fpos_t {
        __off_t __pos;
        __mbstate_t __state;
    } __fpos_t;
    typedef struct _G_fpos64_t {
        __off64_t __pos;
        __mbstate_t __state;
    } __fpos64_t;
    struct _IO_FILE;
    typedef struct _IO_FILE __FILE;
    struct _IO_FILE;
    typedef struct _IO_FILE FILE;
    struct _IO_FILE;
    struct _IO_marker;
    struct _IO_codecvt;
    struct _IO_wide_data;
    typedef void _IO_lock_t;
    struct _IO_FILE {
        int _flags;
        char *_IO_read_ptr;
        char *_IO_read_end;
        char *_IO_read_base;
        char *_IO_write_base;
        char *_IO_write_ptr;
        char *_IO_write_end;
        char *_IO_buf_base;
        char *_IO_buf_end;
        char *_IO_save_base;
        char *_IO_backup_base;
        char *_IO_save_end;
        struct _IO_marker *_markers;
        struct _IO_FILE *_chain;
        int _fileno;
        int _flags2;
        __off_t _old_offset;
        unsigned short _cur_column;
        signed char _vtable_offset;
        char _shortbuf[1];
        _IO_lock_t *_lock;
        __off64_t _offset;
        struct _IO_codecvt *_codecvt;
        struct _IO_wide_data *_wide_data;
        struct _IO_FILE *_freeres_list;
        void *_freeres_buf;
        size_t __pad5;
        int _mode;
        char _unused2[20];
    };
    typedef __ssize_t (cookie_read_function_t)(void *, char *, size_t);
    typedef __ssize_t (cookie_write_function_t)(void *, const char *, size_t);
    typedef int (cookie_seek_function_t)(void *, __off64_t *, int);
    typedef int (cookie_close_function_t)(void *);
    typedef struct _IO_cookie_io_functions_t {
        cookie_read_function_t *read;
        cookie_write_function_t *write;
        cookie_seek_function_t *seek;
        cookie_close_function_t *close;
    } cookie_io_functions_t;
    typedef __gnuc_va_list va_list;
    typedef __off_t off_t;
    typedef __off64_t off64_t;
    typedef __ssize_t ssize_t;
    typedef __fpos_t fpos_t;
    typedef __fpos64_t fpos64_t;
    extern FILE *stdin;
    extern FILE *stdout;
    extern FILE *stderr;
    extern int remove(const char *__filename) throw();
    extern int rename(const char *__old, const char *__new) throw();
    extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) throw();
    extern int renameat2(int __oldfd, const char *__old, int __newfd, const char *__new, unsigned int __flags) throw();
    extern FILE *tmpfile();
    extern FILE *tmpfile64();
    extern char *tmpnam(char *__s) throw();
    extern char *tmpnam_r(char *__s) throw();
    extern char *tempnam(const char *__dir, const char *__pfx) throw() __attribute__((malloc));
    extern int fclose(FILE *__stream);
    extern int fflush(FILE *__stream);
    extern int fflush_unlocked(FILE *__stream);
    extern int fcloseall();
    extern FILE *fopen(const char *__restrict __filename, const char *__restrict __modes);
    extern FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes);
    extern FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fdopen(int __fd, const char *__modes) throw();
    extern FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, cookie_io_functions_t __io_funcs) throw();
    extern FILE *fmemopen(void *__s, size_t __len, const char *__modes) throw();
    extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) throw();
    extern void setbuf(FILE *__restrict __stream, char *__restrict __buf) throw();
    extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) throw();
    extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf, size_t __size) throw();
    extern void setlinebuf(FILE *__stream) throw();
    extern int fprintf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int printf(const char *__restrict __format, ...);
    extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) throw();
    extern int vfprintf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg);
    extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);
    extern int vsprintf(char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw();
    extern int snprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, ...) throw() __attribute__((format(printf, 3, 4)));
    extern int vsnprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, __gnuc_va_list __arg) throw() __attribute__((format(printf, 3, 0)));
    extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, __gnuc_va_list __arg) throw() __attribute__((format(printf, 2, 0)));
    extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((format(printf, 2, 3)));
    extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((format(printf, 2, 3)));
    extern int vdprintf(int __fd, const char *__restrict __fmt, __gnuc_va_list __arg) __attribute__((format(printf, 2, 0)));
    extern int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((format(printf, 2, 3)));
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int scanf(const char *__restrict __format, ...);
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) throw();
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw() __attribute__((format(scanf, 2, 0)));
    extern int fgetc(FILE *__stream);
    extern int getc(FILE *__stream);
    extern int getchar();
    extern int getc_unlocked(FILE *__stream);
    extern int getchar_unlocked();
    extern int fgetc_unlocked(FILE *__stream);
    extern int fputc(int __c, FILE *__stream);
    extern int putc(int __c, FILE *__stream);
    extern int putchar(int __c);
    extern int fputc_unlocked(int __c, FILE *__stream);
    extern int putc_unlocked(int __c, FILE *__stream);
    extern int putchar_unlocked(int __c);
    extern int getw(FILE *__stream);
    extern int putw(int __w, FILE *__stream);
    extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern char *fgets_unlocked(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream);
    extern int fputs(const char *__restrict __s, FILE *__restrict __stream);
    extern int puts(const char *__s);
    extern int ungetc(int __c, FILE *__stream);
    extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);
    extern int fputs_unlocked(const char *__restrict __s, FILE *__restrict __stream);
    extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern int fseek(FILE *__stream, long __off, int __whence);
    extern long ftell(FILE *__stream);
    extern void rewind(FILE *__stream);
    extern int fseeko(FILE *__stream, __off_t __off, int __whence);
    extern __off_t ftello(FILE *__stream);
    extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos);
    extern int fsetpos(FILE *__stream, const fpos_t *__pos);
    extern int fseeko64(FILE *__stream, __off64_t __off, int __whence);
    extern __off64_t ftello64(FILE *__stream);
    extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos);
    extern int fsetpos64(FILE *__stream, const fpos64_t *__pos);
    extern void clearerr(FILE *__stream) throw();
    extern int feof(FILE *__stream) throw();
    extern int ferror(FILE *__stream) throw();
    extern void clearerr_unlocked(FILE *__stream) throw();
    extern int feof_unlocked(FILE *__stream) throw();
    extern int ferror_unlocked(FILE *__stream) throw();
    extern void perror(const char *__s);
    extern int sys_nerr;
    extern const char *const sys_errlist[];
    extern int _sys_nerr;
    extern const char *const _sys_errlist[];
    extern int fileno(FILE *__stream) throw();
    extern int fileno_unlocked(FILE *__stream) throw();
    extern FILE *popen(const char *__command, const char *__modes);
    extern int pclose(FILE *__stream);
    extern char *ctermid(char *__s) throw();
    extern char *cuserid(char *__s);
    struct obstack;
    extern int obstack_printf(struct obstack *__restrict __obstack, const char *__restrict __format, ...) throw() __attribute__((format(printf, 2, 3)));
    extern int obstack_vprintf(struct obstack *__restrict __obstack, const char *__restrict __format, __gnuc_va_list __args) throw() __attribute__((format(printf, 2, 0)));
    extern void flockfile(FILE *__stream) throw();
    extern int ftrylockfile(FILE *__stream) throw();
    extern void funlockfile(FILE *__stream) throw();
    extern int __uflow(FILE *);
    extern int __overflow(FILE *, int);
}
namespace std {
    using ::FILE;
    using ::fpos_t;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::printf;
    using ::putc;
    using ::putchar;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
}
namespace __gnu_cxx {
    using ::snprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsnprintf;
    using ::vsscanf;
}
namespace std {
    using ::__gnu_cxx::snprintf;
    using ::__gnu_cxx::vfscanf;
    using ::__gnu_cxx::vscanf;
    using ::__gnu_cxx::vsnprintf;
    using ::__gnu_cxx::vsscanf;
}
namespace std {
    template <typename> class allocator
template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char16_t>()         {
        }
        allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a)         {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char16_t>(const allocator<char16_t> &) noexcept;
        ~allocator<char16_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
        friend bool operator!=(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    }
template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char32_t>()         {
        }
        allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a)         {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char32_t>(const allocator<char32_t> &) noexcept;
        ~allocator<char32_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
        friend bool operator!=(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    }
template<> class allocator<std::pair<const int, int>> : public __allocator_base<std::pair<const int, int>> {
    public:
        typedef std::pair<const int, int> value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::pair<const int, int> *pointer;
        typedef const std::pair<const int, int> *const_pointer;
        typedef std::pair<const int, int> &reference;
        typedef const std::pair<const int, int> &const_reference;
        template <typename _Tp1> struct rebind
template<> struct rebind<std::__detail::_Hash_node<std::pair<const int, int>, false>> {
            typedef allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept;
        allocator(const std::allocator<std::pair<const int, int>> &__a) noexcept;
        std::allocator<std::pair<const int, int>> &operator=(const std::allocator<std::pair<const int, int>> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        ~allocator<pair<const int, int>>() noexcept;
        friend bool operator==(const std::allocator<std::pair<const int, int>> &, const std::allocator<std::pair<const int, int>> &) noexcept;
        friend bool operator!=(const std::allocator<std::pair<const int, int>> &, const std::allocator<std::pair<const int, int>> &) noexcept;
    }
template<> class allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> : public __allocator_base<std::__detail::_Hash_node<std::pair<const int, int>, false>> {
    public:
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> *pointer;
        typedef const std::__detail::_Hash_node<std::pair<const int, int>, false> *const_pointer;
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> &reference;
        typedef const std::__detail::_Hash_node<std::pair<const int, int>, false> &const_reference;
        template <typename _Tp1> struct rebind
template<> struct rebind<std::__detail::_Hash_node_base *> {
            typedef allocator<std::__detail::_Hash_node_base *> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept;
        allocator(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &__a) noexcept;
        std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &operator=(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>(const allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) noexcept;
        ~allocator<_Hash_node<pair<const int, int>, false>>() noexcept;
        friend bool operator==(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &, const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) noexcept;
        friend bool operator!=(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &, const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) noexcept;
    };
    template<> class allocator<void>;
    template <typename, typename> struct uses_allocator;
}
namespace std {
    template <class _CharT> struct char_traits;
    template<> struct char_traits<char>;
    template<> struct char_traits<wchar_t>;
    template<> struct char_traits<char16_t>;
    template<> struct char_traits<char32_t>;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string
template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char16_t, std::char_traits<char16_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>, __not_<is_convertible<const _Tp &, const char16_t *>>>::value, _Res>;
            static std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _M_sv;
            };
            explicit basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_wrapper __svw, const std::allocator<char16_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_create(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type &__capacity, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char16_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __req, char16_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end)             {
                typedef typename std::__is_integer<const char16_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __req, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_check(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_limit(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static void _S_copy(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            static void _S_assign(char16_t *__d, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _Iterator> static void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &);
            void _M_mutate(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            basic_string(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            template <typename = _RequireAllocator<std::allocator<char16_t>>> basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            template<> basic_string<std::allocator<char16_t>>(const char16_t *__s, const std::allocator<char16_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char16_t>>> basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str) noexcept;
            basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> basic_string(const _Tp &__t, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> explicit basic_string(const _Tp &__t, const std::allocator<char16_t> &__a);
            ~basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator=(const _Tp &__svt);
            operator __sv_type() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator begin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator end() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type size() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept [[nodiscard("")]];
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference front() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference front() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference back() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator+=(const _Tp &__svt);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            void push_back(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __p, char16_t __c);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __position);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __first, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_aux(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type copy(char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__s) noexcept;
            const char16_t *c_str() const noexcept;
            const char16_t *data() const noexcept             {
                return this->_M_data();
            }
            char16_t *data() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> substr(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            int compare(const char16_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char32_t, std::char_traits<char32_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>, __not_<is_convertible<const _Tp &, const char32_t *>>>::value, _Res>;
            static std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _M_sv;
            };
            explicit basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_wrapper __svw, const std::allocator<char32_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_create(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type &__capacity, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char32_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __req, char32_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end)             {
                typedef typename std::__is_integer<const char32_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __req, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_check(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_limit(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static void _S_copy(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            static void _S_assign(char32_t *__d, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _Iterator> static void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &);
            void _M_mutate(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            basic_string(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            template <typename = _RequireAllocator<std::allocator<char32_t>>> basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            template<> basic_string<std::allocator<char32_t>>(const char32_t *__s, const std::allocator<char32_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char32_t>>> basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str) noexcept;
            basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> basic_string(const _Tp &__t, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> explicit basic_string(const _Tp &__t, const std::allocator<char32_t> &__a);
            ~basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator=(const _Tp &__svt);
            operator __sv_type() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator begin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator end() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type size() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept [[nodiscard("")]];
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference front() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference front() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference back() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator+=(const _Tp &__svt);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            void push_back(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __p, char32_t __c);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __position);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __first, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_aux(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type copy(char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__s) noexcept;
            const char32_t *c_str() const noexcept;
            const char32_t *data() const noexcept             {
                return this->_M_data();
            }
            char32_t *data() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> substr(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            int compare(const char32_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
}
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef unsigned int wint_t;
typedef __mbstate_t mbstate_t;
struct __locale_struct {
    struct __locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern "C" {
    struct tm;
    extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(1, 2)));
    extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw() __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) throw();
    extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) throw();
    extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) throw();
    extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) throw();
    extern wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((malloc));
    extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw() __attribute__((pure));
    extern size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw() __attribute__((pure));
    extern size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
    extern size_t wcslen(const wchar_t *__s) throw() __attribute__((pure));
    extern wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) throw() __attribute__((pure));
    extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) throw() __attribute__((pure));
    extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((pure));
    extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) throw();
    extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wint_t btowc(int __c) throw();
    extern int wctob(wint_t __c) throw();
    extern int mbsinit(const mbstate_t *__ps) throw() __attribute__((pure));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) throw();
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) throw();
    extern size_t __mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern int wcwidth(wchar_t __c) throw();
    extern int wcswidth(const wchar_t *__s, size_t __n) throw();
    extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float32 wcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float64 wcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float32x wcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float64x wcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
    extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw();
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) throw();
    extern int fwide(__FILE *__fp, int __mode) throw();
    extern int fwprintf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wprintf(const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) throw();
    extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wscanf(const wchar_t *__restrict __format, ...);
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern wint_t fgetwc(__FILE *__stream);
    extern wint_t getwc(__FILE *__stream);
    extern wint_t getwchar();
    extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
    extern wint_t getwc_unlocked(__FILE *__stream);
    extern wint_t getwchar_unlocked();
    extern wint_t fgetwc_unlocked(__FILE *__stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) throw();
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) throw();
}
namespace std {
    using ::mbstate_t;
}
extern "C++" {
    namespace std {
        using ::wint_t;
        using ::btowc;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::fwprintf;
        using ::fwscanf;
        using ::getwc;
        using ::getwchar;
        using ::mbrlen;
        using ::mbrtowc;
        using ::mbsinit;
        using ::mbsrtowcs;
        using ::putwc;
        using ::putwchar;
        using ::swprintf;
        using ::swscanf;
        using ::ungetwc;
        using ::vfwprintf;
        using ::vfwscanf;
        using ::vswprintf;
        using ::vswscanf;
        using ::vwprintf;
        using ::vwscanf;
        using ::wcrtomb;
        using ::wcscat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcscpy;
        using ::wcscspn;
        using ::wcsftime;
        using ::wcslen;
        using ::wcsncat;
        using ::wcsncmp;
        using ::wcsncpy;
        using ::wcsrtombs;
        using ::wcsspn;
        using ::wcstod;
        using ::wcstof;
        using ::wcstok;
        using ::wcstol;
        using ::wcstoul;
        using ::wcsxfrm;
        using ::wctob;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wprintf;
        using ::wscanf;
        using ::wcschr;
        using ::wcspbrk;
        using ::wcsrchr;
        using ::wcsstr;
        using ::wmemchr;
        inline wchar_t *wcschr(wchar_t *__p, wchar_t __c)         {
            return wcschr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2)         {
            return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c)         {
            return wcsrchr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2)         {
            return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, std::size_t __n)         {
            return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
        }
    }
}
namespace __gnu_cxx {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
namespace std {
    using std::wcstof;
    using std::vfwscanf;
    using std::vswscanf;
    using std::vwscanf;
    using std::wcstold;
    using std::wcstoll;
    using std::wcstoull;
}
namespace std {
    typedef long streamoff;
    typedef std::ptrdiff_t streamsize;
    template <typename _StateT> class fpos {
    private:
        std::streamoff _M_off;
        _StateT _M_state;
    public:
        fpos<_StateT>() : _M_off(0), _M_state()         {
        }
        fpos<_StateT>(std::streamoff __off) : _M_off(__off), _M_state()         {
        }
        fpos<_StateT>(const fpos<_StateT> &) = default
        fpos<_StateT> &operator=(const fpos<_StateT> &) = default
        ~fpos<_StateT>() = default
        operator streamoff() const         {
            return this->_M_off;
        }
        void state(_StateT __st)         {
            this->_M_state = __st;
        }
        _StateT state() const         {
            return this->_M_state;
        }
        fpos<_StateT> &operator+=(std::streamoff __off)         {
            this->_M_off += __off;
            return *this;
        }
        fpos<_StateT> &operator-=(std::streamoff __off)         {
            this->_M_off -= __off;
            return *this;
        }
        fpos<_StateT> operator+(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos += __off;
            return __pos;
        }
        fpos<_StateT> operator-(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos -= __off;
            return __pos;
        }
        std::streamoff operator-(const fpos<_StateT> &__other) const         {
            return this->_M_off - __other._M_off;
        }
    };
    template <typename _StateT> inline bool operator==(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) == std::streamoff(__rhs);
    }
    template <typename _StateT> inline bool operator!=(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) != std::streamoff(__rhs);
    }
    typedef fpos<mbstate_t> streampos;
    typedef fpos<mbstate_t> wstreampos;
    typedef fpos<mbstate_t> u16streampos;
    typedef fpos<mbstate_t> u32streampos;
}
namespace std {
    class ios_base;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_filebuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ifstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ofstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_fstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    typedef basic_ios<char> ios;
    typedef basic_streambuf<char> streambuf;
    typedef basic_istream<char> istream;
    typedef basic_ostream<char> ostream;
    typedef basic_iostream<char> iostream;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_istringstream<char> istringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_filebuf<char> filebuf;
    typedef basic_ifstream<char> ifstream;
    typedef basic_ofstream<char> ofstream;
    typedef basic_fstream<char> fstream;
    typedef basic_ios<wchar_t> wios;
    typedef basic_streambuf<wchar_t> wstreambuf;
    typedef basic_istream<wchar_t> wistream;
    typedef basic_ostream<wchar_t> wostream;
    typedef basic_iostream<wchar_t> wiostream;
    typedef basic_stringbuf<wchar_t> wstringbuf;
    typedef basic_istringstream<wchar_t> wistringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;
    typedef basic_stringstream<wchar_t> wstringstream;
    typedef basic_filebuf<wchar_t> wfilebuf;
    typedef basic_ifstream<wchar_t> wifstream;
    typedef basic_ofstream<wchar_t> wofstream;
    typedef basic_fstream<wchar_t> wfstream;
}
extern "C++" {
    namespace std {
        class exception {
        public:
            exception() noexcept             {
            }
            virtual ~exception() noexcept;
            exception(const std::exception &) = default
            std::exception &operator=(const std::exception &) = default
            exception(std::exception &&) = default
            std::exception &operator=(std::exception &&) = default
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_exception : public std::exception {
        public:
            bad_exception() noexcept : std::exception()             {
            }
            virtual ~bad_exception() noexcept;
            virtual const char *what() const noexcept;
        };
        typedef void (*terminate_handler)();
        typedef void (*unexpected_handler)();
        std::terminate_handler set_terminate(std::terminate_handler) noexcept;
        std::terminate_handler get_terminate() noexcept;
        void terminate() noexcept;
        std::unexpected_handler set_unexpected(std::unexpected_handler) noexcept;
        std::unexpected_handler get_unexpected() noexcept;
        void unexpected();
        bool uncaught_exception() noexcept [[deprecated("")]] __attribute__((pure));
        int uncaught_exceptions() noexcept __attribute__((pure));
    }
    namespace __gnu_cxx {
        void __verbose_terminate_handler();
    }
}
typedef long ptrdiff_t;
typedef struct {
    long long __clang_max_align_nonce1 __attribute__((aligned(__alignof(long long))));
    long double __clang_max_align_nonce2 __attribute__((aligned(__alignof(long double))));
} max_align_t;
namespace std {
    class type_info;
}
namespace __cxxabiv1 {
    struct __cxa_refcounted_exception;
    extern "C" {
        void *__cxa_allocate_exception(size_t) noexcept;
        void __cxa_free_exception(void *) noexcept;
        __cxxabiv1::__cxa_refcounted_exception *__cxa_init_primary_exception(void *object, std::type_info *tinfo, void (*dest)(void *)) noexcept;
    }
}
namespace std {
    std::size_t _Hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
    std::size_t _Fnv_hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
}
extern "C++" {
    namespace __cxxabiv1 {
        class __class_type_info;
    }
    namespace std {
        class type_info {
        public:
            virtual ~type_info() noexcept;
            const char *name() const noexcept             {
                return this->__name[0] == '*' ? this->__name + 1 : this->__name;
            }
            bool before(const std::type_info &__arg) const noexcept             {
                return (this->__name[0] == '*' && __arg.__name[0] == '*') ? this->__name < __arg.__name : __builtin_strcmp(this->__name, __arg.__name) < 0;
            }
            bool operator==(const std::type_info &__arg) const noexcept             {
                return ((this->__name == __arg.__name) || (this->__name[0] != '*' && __builtin_strcmp(this->__name, __arg.__name) == 0));
            }
            bool operator!=(const std::type_info &__arg) const noexcept             {
                return !this->operator==(__arg);
            }
            std::size_t hash_code() const noexcept             {
                return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast<std::size_t>(3339675911UL));
            }
            virtual bool __is_pointer_p() const;
            virtual bool __is_function_p() const;
            virtual bool __do_catch(const std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
            virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target, void **__obj_ptr) const;
        protected:
            const char *__name;
            explicit type_info(const char *__n) : __name(__n)             {
            }
        private:
            std::type_info &operator=(const std::type_info &);
            type_info(const std::type_info &);
        };
        class bad_cast : public std::exception {
        public:
            bad_cast() noexcept : std::exception()             {
            }
            virtual ~bad_cast() noexcept;
            virtual const char *what() const noexcept;
        };
        class bad_typeid : public std::exception {
        public:
            bad_typeid() noexcept : std::exception()             {
            }
            virtual ~bad_typeid() noexcept;
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_alloc : public std::exception {
        public:
            bad_alloc() throw() : std::exception()             {
            }
            bad_alloc(const std::bad_alloc &) = default
            std::bad_alloc &operator=(const std::bad_alloc &) = default
            virtual ~bad_alloc() throw();
            virtual const char *what() const throw();
        };
        class bad_array_new_length : public std::bad_alloc {
        public:
            bad_array_new_length() throw() : std::bad_alloc()             {
            }
            virtual ~bad_array_new_length() throw();
            virtual const char *what() const throw();
        };
        enum class align_val_t : std::size_t {
        };
        struct nothrow_t {
            explicit nothrow_t() = default
        };
        extern const std::nothrow_t nothrow;
        typedef void (*new_handler)();
        std::new_handler set_new_handler(std::new_handler) throw();
        std::new_handler get_new_handler() noexcept;
    }
    void *operator new(std::size_t) [[nodiscard("")]];
    void *operator new[](std::size_t) [[nodiscard("")]];
    void operator delete(void *) noexcept;
    void operator delete[](void *) noexcept;
    void *operator new(std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void *operator new[](std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void operator delete(void *, const std::nothrow_t &) noexcept;
    void operator delete[](void *, const std::nothrow_t &) noexcept;
    void *operator new(std::size_t, std::align_val_t) [[nodiscard("")]];
    void *operator new(std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void operator delete(void *, std::align_val_t) noexcept;
    void operator delete(void *, std::align_val_t, const std::nothrow_t &) noexcept;
    void *operator new[](std::size_t, std::align_val_t) [[nodiscard("")]];
    void *operator new[](std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void operator delete[](void *, std::align_val_t) noexcept;
    void operator delete[](void *, std::align_val_t, const std::nothrow_t &) noexcept;
    inline void *operator new(std::size_t, void *__p) noexcept [[nodiscard("")]]     {
        return __p;
    }
    inline void *operator new[](std::size_t, void *__p) noexcept [[nodiscard("")]]     {
        return __p;
    }
    inline void operator delete(void *, void *) noexcept     {
    }
    inline void operator delete[](void *, void *) noexcept     {
    }
}
namespace std {
    template <typename _Tp> constexpr _Tp *launder(_Tp *__p) noexcept [[nodiscard("")]]     {
        return __builtin_launder(__p);
    }
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args...) noexcept(_NE)) = delete
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args..., ...) noexcept(_NE)) = delete
    void launder(void *) = delete
    void launder(const void *) = delete
    void launder(volatile void *) = delete
    void launder(const volatile void *) = delete
}
extern "C++" {
    namespace std {
        class type_info;
        namespace __exception_ptr {
            class exception_ptr;
        }
        using __exception_ptr::exception_ptr;
        std::__exception_ptr::exception_ptr current_exception() noexcept;
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex) noexcept;
        void rethrow_exception(std::__exception_ptr::exception_ptr);
        namespace __exception_ptr {
            using std::rethrow_exception;
            class exception_ptr {
                void *_M_exception_object;
                explicit exception_ptr(void *__e) noexcept;
                void _M_addref() noexcept;
                void _M_release() noexcept;
                void *_M_get() const noexcept __attribute__((pure));
                friend std::__exception_ptr::exception_ptr std::current_exception() noexcept;
                friend void std::rethrow_exception(std::__exception_ptr::exception_ptr);
                friend template <typename _Ex> std::__exception_ptr::exception_ptr std::make_exception_ptr(_Ex) noexcept;
            public:
                exception_ptr() noexcept;
                exception_ptr(const std::__exception_ptr::exception_ptr &) noexcept;
                exception_ptr(std::nullptr_t) noexcept : _M_exception_object(0)                 {
                }
                exception_ptr(std::__exception_ptr::exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object)                 {
                    __o._M_exception_object = 0;
                }
                std::__exception_ptr::exception_ptr &operator=(const std::__exception_ptr::exception_ptr &) noexcept;
                std::__exception_ptr::exception_ptr &operator=(std::__exception_ptr::exception_ptr &&__o) noexcept                 {
                    std::__exception_ptr::exception_ptr(static_cast<std::__exception_ptr::exception_ptr &&>(__o)).swap(*this);
                    return *this;
                }
                ~exception_ptr() noexcept;
                void swap(std::__exception_ptr::exception_ptr &) noexcept;
                explicit operator bool() const                 {
                    return this->_M_exception_object;
                }
                friend bool operator==(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
                const class std::type_info *__cxa_exception_type() const noexcept __attribute__((pure));
            };
            bool operator==(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
            bool operator!=(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
            inline void swap(std::__exception_ptr::exception_ptr &__lhs, std::__exception_ptr::exception_ptr &__rhs)             {
                __lhs.swap(__rhs);
            }
            template <typename _Ex> inline void __dest_thunk(void *__x)             {
                static_cast<_Ex *>(__x)->~_Ex();
            }
        }
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept         {
            void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
            (void)__cxxabiv1::__cxa_init_primary_exception(__e, const_cast<std::type_info *>(&typeid(__ex)), __exception_ptr::__dest_thunk<_Ex>);
            try {
                ::new (__e) _Ex((__ex));
                return std::__exception_ptr::exception_ptr(__e);
            } catch (...) {
                __cxxabiv1::__cxa_free_exception(__e);
                return current_exception();
            }
        }
    }
}
namespace std {
    template <typename _Tp> inline constexpr _Tp *__addressof(_Tp &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char *__addressof<char>(char &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char *__addressof<const char>(const char &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr wchar_t *__addressof<wchar_t>(wchar_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const wchar_t *__addressof<const wchar_t>(const wchar_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char16_t *__addressof<char16_t>(char16_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char16_t *__addressof<const char16_t>(const char16_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char32_t *__addressof<char32_t>(char32_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char32_t *__addressof<const char32_t>(const char32_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
}
namespace std {
    template <typename _Tp, _Tp __v> struct integral_constant {
        static constexpr _Tp value = __v;
        typedef _Tp value_type;
        typedef integral_constant<_Tp, __v> type;
        constexpr operator value_type() const noexcept         {
            return value;
        }
        constexpr std::integral_constant::value_type operator()() const noexcept         {
            return value;
        }
    };
template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        typedef bool value_type;
        typedef integral_constant<bool, true> type;
        constexpr operator value_type() const noexcept         {
            return value;
        }
        constexpr std::integral_constant<bool, true>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        typedef bool value_type;
        typedef integral_constant<bool, false> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, false>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long, 0> {
        static constexpr unsigned long value = 0UL;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 0UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 0>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long, 2> {
        static constexpr unsigned long value;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 2UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 2>::value_type operator()() const noexcept;
    };
    constexpr _Tp value;
    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;
    template <bool __v> using __bool_constant = integral_constant<bool, __v>;
    template <bool __v> using bool_constant = integral_constant<bool, __v>;
    template <bool, typename, typename> struct conditional
template<> struct conditional<true, std::is_integral<bool>, std::is_floating_point<bool>> {
        typedef std::is_integral<bool> type;
    }
template<> struct conditional<true, std::is_integral<int>, std::is_floating_point<int>> {
        typedef std::is_integral<int> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char>, std::is_rvalue_reference<char>> {
        typedef std::is_rvalue_reference<char> type;
    }
template<> struct conditional<false, std::is_reference<char>, std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    }
template<> struct conditional<false, std::is_function<char>, std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    }
template<> struct conditional<false, std::is_void<char>, std::__is_array_unknown_bounds<char>> {
        typedef std::__is_array_unknown_bounds<char> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char, 0>>, std::is_array<char>> {
        typedef std::is_array<char> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>> {
        typedef std::is_rvalue_reference<wchar_t> type;
    }
template<> struct conditional<false, std::is_reference<wchar_t>, std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    }
template<> struct conditional<false, std::is_function<wchar_t>, std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    }
template<> struct conditional<false, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> {
        typedef std::__is_array_unknown_bounds<wchar_t> type;
    }
template<> struct conditional<false, std::__not_<std::extent<wchar_t, 0>>, std::is_array<wchar_t>> {
        typedef std::is_array<wchar_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>> {
        typedef std::is_rvalue_reference<char16_t> type;
    }
template<> struct conditional<false, std::is_reference<char16_t>, std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    }
template<> struct conditional<false, std::is_function<char16_t>, std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    }
template<> struct conditional<false, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> {
        typedef std::__is_array_unknown_bounds<char16_t> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char16_t, 0>>, std::is_array<char16_t>> {
        typedef std::is_array<char16_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>> {
        typedef std::is_rvalue_reference<char32_t> type;
    }
template<> struct conditional<false, std::is_reference<char32_t>, std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    }
template<> struct conditional<false, std::is_function<char32_t>, std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    }
template<> struct conditional<false, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> {
        typedef std::__is_array_unknown_bounds<char32_t> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char32_t, 0>>, std::is_array<char32_t>> {
        typedef std::is_array<char32_t> type;
    }
template<> struct conditional<true, std::is_integral<unsigned int>, std::is_floating_point<unsigned int>> {
        typedef std::is_integral<unsigned int> type;
    }
template<> struct conditional<true, std::__not_<std::is_signed<unsigned int>>, std::is_arithmetic<unsigned int>> {
        typedef std::__not_<std::is_signed<unsigned int>> type;
    }
template<> struct conditional<false, std::is_void<const unsigned int &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    }
template<> struct conditional<false, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_array<std::basic_string_view<char, std::char_traits<char>>> type;
    }
template<> struct conditional<false, std::__and_<std::__not_<std::is_convertible<const unsigned int *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>, std::is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>> type;
    }
template<> struct conditional<true, std::is_integral<unsigned long>, std::is_floating_point<unsigned long>> {
        typedef std::is_integral<unsigned long> type;
    }
template<> struct conditional<true, std::__not_<std::is_signed<unsigned long>>, std::is_arithmetic<unsigned long>> {
        typedef std::__not_<std::is_signed<unsigned long>> type;
    }
template<> struct conditional<true, std::is_integral<unsigned long long>, std::is_floating_point<unsigned long long>> {
        typedef std::is_integral<unsigned long long> type;
    }
template<> struct conditional<true, std::__not_<std::is_signed<unsigned long long>>, std::is_arithmetic<unsigned long long>> {
        typedef std::__not_<std::is_signed<unsigned long long>> type;
    }
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    }
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>, std::is_convertible<const char *const &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>> type;
    }
template<> struct conditional<false, std::is_void<const char *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> type;
    }
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<char> *> type;
    }
template<> struct conditional<true, std::__not_<std::is_convertible<const char *const &, const char *>>, std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>> {
        typedef std::__not_<std::is_convertible<const char *const &, const char *>> type;
    }
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    }
template<> struct conditional<false, std::is_function<const char *>, std::is_array<const char *>> {
        typedef std::is_array<const char *> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> type;
    }
template<> struct conditional<false, std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
        typedef std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> type;
    }
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>, std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>> type;
    }
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<wchar_t> *> type;
    }
template<> struct conditional<true, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> {
        typedef std::is_array<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>> type;
    }
template<> struct conditional<false, std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>> {
        typedef std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>> type;
    }
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>, std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>> type;
    }
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> type;
    }
template<> struct conditional<true, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>, std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> {
        typedef std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char16_t *>, std::is_array<const char16_t *>> {
        typedef std::is_array<const char16_t *> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>> type;
    }
template<> struct conditional<false, std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>> {
        typedef std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>> type;
    }
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>, std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>> type;
    }
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> type;
    }
template<> struct conditional<true, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>, std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> {
        typedef std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char32_t *>, std::is_array<const char32_t *>> {
        typedef std::is_array<const char32_t *> type;
    }
template<> struct conditional<false, std::is_void<const char &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    }
template<> struct conditional<false, std::__and_<std::__not_<std::is_convertible<const char *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char &, const char *>>>, std::is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<std::allocator<char>>, std::is_rvalue_reference<std::allocator<char>>> {
        typedef std::is_rvalue_reference<std::allocator<char>> type;
    }
template<> struct conditional<false, std::is_reference<std::allocator<char>>, std::__or_<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
        typedef std::__or_<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> type;
    }
template<> struct conditional<false, std::is_function<std::allocator<char>>, std::__or_<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
        typedef std::__or_<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> type;
    }
template<> struct conditional<false, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> {
        typedef std::__is_array_unknown_bounds<std::allocator<char>> type;
    }
template<> struct conditional<false, std::__not_<std::extent<std::allocator<char>, 0>>, std::is_array<std::allocator<char>>> {
        typedef std::is_array<std::allocator<char>> type;
    }
template<> struct conditional<false, std::is_void<const int &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    }
template<> struct conditional<false, std::__and_<std::__not_<std::is_convertible<const int *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const int &, const char *>>>, std::is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>> type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, char &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>> type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, unsigned char &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>> type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, signed char &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>> type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<wchar_t> &>, std::__is_extractable<std::basic_istream<wchar_t> &, wchar_t &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &>> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<bool>, std::is_rvalue_reference<bool>> {
        typedef std::is_rvalue_reference<bool> type;
    }
template<> struct conditional<false, std::is_reference<bool>, std::__or_<std::is_function<bool>, std::is_void<bool>, std::__is_array_unknown_bounds<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_void<bool>, std::__is_array_unknown_bounds<bool>> type;
    }
template<> struct conditional<false, std::is_function<bool>, std::__or_<std::is_void<bool>, std::__is_array_unknown_bounds<bool>>> {
        typedef std::__or_<std::is_void<bool>, std::__is_array_unknown_bounds<bool>> type;
    }
template<> struct conditional<false, std::is_void<bool>, std::__is_array_unknown_bounds<bool>> {
        typedef std::__is_array_unknown_bounds<bool> type;
    }
template<> struct conditional<false, std::__not_<std::extent<bool, 0>>, std::is_array<bool>> {
        typedef std::is_array<bool> type;
    }
template<> struct conditional<true, std::is_copy_assignable<unsigned long>, std::is_copy_assignable<bool>> {
        typedef std::is_copy_assignable<unsigned long> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>> {
        typedef std::is_rvalue_reference<unsigned long> type;
    }
template<> struct conditional<false, std::is_reference<unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    }
template<> struct conditional<false, std::is_function<unsigned long>, std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    }
template<> struct conditional<false, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> {
        typedef std::__is_array_unknown_bounds<unsigned long> type;
    }
template<> struct conditional<false, std::__not_<std::extent<unsigned long, 0>>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    }
template<> struct conditional<true, const std::pair<bool, unsigned long> &, const std::__nonesuch &> {
        typedef const std::pair<bool, unsigned long> &type;
    }
template<> struct conditional<true, std::is_move_assignable<unsigned long>, std::is_move_assignable<bool>> {
        typedef std::is_move_assignable<unsigned long> type;
    }
template<> struct conditional<true, std::pair<bool, unsigned long> &&, std::__nonesuch &&> {
        typedef std::pair<bool, unsigned long> &&type;
    }
template<> struct conditional<true, std::is_constructible<unsigned long, const unsigned long &>, std::is_constructible<bool, const bool &>> {
        typedef std::is_constructible<unsigned long, const unsigned long &> type;
    }
template<> struct conditional<false, std::is_void<const bool &>, std::__or_<std::is_function<bool>, std::is_array<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_array<bool>> type;
    }
template<> struct conditional<false, std::is_function<bool>, std::is_array<bool>> {
        typedef std::is_array<bool> type;
    }
template<> struct conditional<true, std::is_convertible<const unsigned long &, unsigned long>, std::is_convertible<const bool &, bool>> {
        typedef std::is_convertible<const unsigned long &, unsigned long> type;
    }
template<> struct conditional<false, std::is_void<const unsigned long &>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    }
template<> struct conditional<false, std::is_function<unsigned long>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    }
template<> struct conditional<true, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> {
        typedef std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>> type;
    }
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>, std::is_constructible<bool, bool &&>> {
        typedef std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> type;
    }
template<> struct conditional<true, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>, std::is_constructible<unsigned long, const unsigned long &&>> {
        typedef std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>> type;
    }
template<> struct conditional<false, std::is_void<bool &&>, std::__or_<std::is_function<bool>, std::is_array<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_array<bool>> type;
    }
template<> struct conditional<true, std::is_convertible<const unsigned long &, unsigned long>, std::is_convertible<bool &&, bool>> {
        typedef std::is_convertible<const unsigned long &, unsigned long> type;
    }
template<> struct conditional<false, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> {
        typedef std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> type;
    }
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>>, std::is_constructible<bool, bool &&>> {
        typedef std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> type;
    }
template<> struct conditional<true, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>, std::is_constructible<unsigned long, const unsigned long &&>> {
        typedef std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> type;
    }
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>> type;
    }
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> type;
    }
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>, std::is_constructible<unsigned long, unsigned long &&>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>> type;
    }
template<> struct conditional<true, std::is_convertible<unsigned long &&, unsigned long>, std::is_convertible<const bool &, bool>> {
        typedef std::is_convertible<unsigned long &&, unsigned long> type;
    }
template<> struct conditional<false, std::is_void<unsigned long &&>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    }
template<> struct conditional<false, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> type;
    }
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> type;
    }
template<> struct conditional<true, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>, std::is_constructible<unsigned long, unsigned long &&>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> type;
    }
template<> struct conditional<true, std::is_constructible<unsigned long, unsigned long &&>, std::is_constructible<bool, bool &&>> {
        typedef std::is_constructible<unsigned long, unsigned long &&> type;
    }
template<> struct conditional<true, std::is_convertible<unsigned long &&, unsigned long>, std::is_convertible<bool &&, bool>> {
        typedef std::is_convertible<unsigned long &&, unsigned long> type;
    }
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>> type;
    }
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, int &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, int &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> type;
    }
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>, std::is_constructible<unsigned long, int &&>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>> type;
    }
template<> struct conditional<true, std::is_convertible<int &&, unsigned long>, std::is_convertible<const bool &, bool>> {
        typedef std::is_convertible<int &&, unsigned long> type;
    }
template<> struct conditional<false, std::is_void<int &&>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    }
template<> struct conditional<false, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> type;
    }
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, int &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, int &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> type;
    }
template<> struct conditional<true, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>, std::is_constructible<unsigned long, int &&>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> type;
    }
template<> struct conditional<true, std::is_constructible<unsigned long, int &&>, std::is_constructible<bool, bool &&>> {
        typedef std::is_constructible<unsigned long, int &&> type;
    }
template<> struct conditional<true, std::is_convertible<int &&, unsigned long>, std::is_convertible<bool &&, bool>> {
        typedef std::is_convertible<int &&, unsigned long> type;
    }
template<> struct conditional<true, std::__is_nothrow_invocable<const std::hash<int> &, const int &>, std::__is_fast_hash<std::hash<int>>> {
        typedef std::__is_nothrow_invocable<const std::hash<int> &, const int &> type;
    }
template<> struct conditional<true, std::__call_is_nothrow<std::__invoke_result<const std::hash<int> &, const int &>, const std::hash<int> &, const int &>, std::__is_invocable<const std::hash<int> &, const int &>> {
        typedef std::__call_is_nothrow<std::__invoke_result<const std::hash<int> &, const int &>, const std::hash<int> &, const int &> type;
    }
template<> struct conditional<true, std::pair<std::__detail::_Node_iterator<std::pair<const int, int>, false, false>, bool>, std::__detail::_Node_iterator<std::pair<const int, int>, false, false>> {
        typedef std::pair<std::__detail::_Node_iterator<std::pair<const int, int>, false, false>, bool> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const int>, std::is_rvalue_reference<const int>> {
        typedef std::is_rvalue_reference<const int> type;
    }
template<> struct conditional<false, std::is_reference<const int>, std::__or_<std::is_function<const int>, std::is_void<const int>, std::__is_array_unknown_bounds<const int>>> {
        typedef std::__or_<std::is_function<const int>, std::is_void<const int>, std::__is_array_unknown_bounds<const int>> type;
    }
template<> struct conditional<false, std::is_function<const int>, std::__or_<std::is_void<const int>, std::__is_array_unknown_bounds<const int>>> {
        typedef std::__or_<std::is_void<const int>, std::__is_array_unknown_bounds<const int>> type;
    }
template<> struct conditional<false, std::is_void<const int>, std::__is_array_unknown_bounds<const int>> {
        typedef std::__is_array_unknown_bounds<const int> type;
    }
template<> struct conditional<false, std::__not_<std::extent<const int, 0>>, std::is_array<const int>> {
        typedef std::is_array<const int> type;
    }
template<> struct conditional<false, std::is_copy_assignable<int>, std::is_copy_assignable<const int>> {
        typedef std::is_copy_assignable<const int> type;
    }
template<> struct conditional<false, const std::pair<const int, int> &, const std::__nonesuch &> {
        typedef const std::__nonesuch &type;
    }
template<> struct conditional<false, std::is_move_assignable<int>, std::is_move_assignable<const int>> {
        typedef std::is_move_assignable<const int> type;
    }
template<> struct conditional<false, std::pair<const int, int> &&, std::__nonesuch &&> {
        typedef std::__nonesuch &&type;
    }
template<> struct conditional<false, std::__detail::_Identity, std::__detail::_Select1st> {
        typedef std::__detail::_Select1st type;
    }
template<> struct conditional<true, std::__not_<std::integral_constant<bool, false>>, std::is_default_constructible<std::__detail::_Mod_range_hashing>> {
        typedef std::__not_<std::integral_constant<bool, false>> type;
    }
template<> struct conditional<false, std::pair<std::__detail::_Node_iterator<std::pair<const int, int>, false, false>, bool>, std::__detail::_Node_iterator<std::pair<const int, int>, false, false>> {
        typedef std::__detail::_Node_iterator<std::pair<const int, int>, false, false> type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[11], void>>, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>> type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, const char *const &, void>>, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>> type;
    }
template<> struct conditional<false, std::__undefined, char> {
        typedef char type;
    }
template<> struct conditional<false, std::__undefined, const char> {
        typedef const char type;
    }
template<> struct conditional<false, std::is_void<std::random_access_iterator_tag>, std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> {
        typedef std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> type;
    }
template<> struct conditional<false, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> {
        typedef std::is_array<std::input_iterator_tag> type;
    }
template<> struct conditional<false, std::is_void<char *const &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    }
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>, std::is_convertible<char *const &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>> type;
    }
template<> struct conditional<false, std::is_void<char *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> type;
    }
template<> struct conditional<true, std::__not_<std::is_convertible<char *const &, const char *>>, std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>> {
        typedef std::__not_<std::is_convertible<char *const &, const char *>> type;
    }
template<> struct conditional<false, std::is_void<char *const &>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    }
template<> struct conditional<false, std::is_void<wchar_t *const &>, std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> type;
    }
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>, std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>> type;
    }
template<> struct conditional<false, std::is_void<wchar_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>> type;
    }
template<> struct conditional<true, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>, std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_void<wchar_t *const &>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    }
template<> struct conditional<false, std::__undefined, wchar_t> {
        typedef wchar_t type;
    }
template<> struct conditional<false, std::__undefined, const wchar_t> {
        typedef const wchar_t type;
    }
template<> struct conditional<false, std::__undefined, char16_t> {
        typedef char16_t type;
    }
template<> struct conditional<false, std::__undefined, const char16_t> {
        typedef const char16_t type;
    }
template<> struct conditional<false, std::__undefined, char32_t> {
        typedef char32_t type;
    }
template<> struct conditional<false, std::__undefined, const char32_t> {
        typedef const char32_t type;
    }
template<> struct conditional<false, std::is_void<const std::__cxx11::basic_string<char> &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    }
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>>, std::is_convertible<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>> type;
    }
template<> struct conditional<false, std::is_void<const std::__cxx11::basic_string<char> *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> type;
    }
template<> struct conditional<false, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>> {
        typedef std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>> type;
    };
    template <typename _Type> struct __type_identity {
        using type = _Type;
    };
template<> struct __type_identity<char> {
        using type = char;
    };
template<> struct __type_identity<wchar_t> {
        using type = wchar_t;
    };
template<> struct __type_identity<char16_t> {
        using type = char16_t;
    };
template<> struct __type_identity<char32_t> {
        using type = char32_t;
    };
template<> struct __type_identity<std::allocator<char>> {
        using type = std::allocator<char>;
    };
template<> struct __type_identity<bool> {
        using type = bool;
    };
template<> struct __type_identity<unsigned long> {
        using type = unsigned long;
    };
template<> struct __type_identity<const int> {
        using type = const int;
    };
    template <typename _Tp> using __type_identity_t = typename __type_identity<_Tp>::type;
    template <typename ...> struct __or_
template<> struct __or_<<std::is_integral<bool>, std::is_floating_point<bool>>> : public conditional<is_integral<bool>::value, is_integral<bool>, is_floating_point<bool>>::type {
    }
template<> struct __or_<<std::is_integral<int>, std::is_floating_point<int>>> : public conditional<is_integral<int>::value, is_integral<int>, is_floating_point<int>>::type {
    }
template<> struct __or_<<std::is_reference<char>, std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public conditional<is_reference<char>::value, is_reference<char>, __or_<is_function<char>, is_void<char>, __is_array_unknown_bounds<char>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char>, std::is_rvalue_reference<char>>> : public conditional<is_lvalue_reference<char>::value, is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    }
template<> struct __or_<<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public conditional<is_function<char>::value, is_function<char>, __or_<is_void<char>, __is_array_unknown_bounds<char>>>::type {
    }
template<> struct __or_<<std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public conditional<is_void<char>::value, is_void<char>, __is_array_unknown_bounds<char>>::type {
    }
template<> struct __or_<<std::is_reference<wchar_t>, std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public conditional<is_reference<wchar_t>::value, is_reference<wchar_t>, __or_<is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>>> : public conditional<is_lvalue_reference<wchar_t>::value, is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    }
template<> struct __or_<<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public conditional<is_function<wchar_t>::value, is_function<wchar_t>, __or_<is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>>::type {
    }
template<> struct __or_<<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public conditional<is_void<wchar_t>::value, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>::type {
    }
template<> struct __or_<<std::is_reference<char16_t>, std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public conditional<is_reference<char16_t>::value, is_reference<char16_t>, __or_<is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>>> : public conditional<is_lvalue_reference<char16_t>::value, is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    }
template<> struct __or_<<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public conditional<is_function<char16_t>::value, is_function<char16_t>, __or_<is_void<char16_t>, __is_array_unknown_bounds<char16_t>>>::type {
    }
template<> struct __or_<<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public conditional<is_void<char16_t>::value, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>::type {
    }
template<> struct __or_<<std::is_reference<char32_t>, std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public conditional<is_reference<char32_t>::value, is_reference<char32_t>, __or_<is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>>> : public conditional<is_lvalue_reference<char32_t>::value, is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    }
template<> struct __or_<<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public conditional<is_function<char32_t>::value, is_function<char32_t>, __or_<is_void<char32_t>, __is_array_unknown_bounds<char32_t>>>::type {
    }
template<> struct __or_<<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public conditional<is_void<char32_t>::value, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>::type {
    }
template<> struct __or_<<std::is_integral<unsigned int>, std::is_floating_point<unsigned int>>> : public conditional<is_integral<unsigned int>::value, is_integral<unsigned int>, is_floating_point<unsigned int>>::type {
    }
template<> struct __or_<<std::is_void<const unsigned int &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public conditional<is_void<const unsigned int &>::value, is_void<const unsigned int &>, __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>>::type {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public conditional<is_function<basic_string_view<char, char_traits<char>>>::value, is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>::type {
    }
template<> struct __or_<<std::is_integral<unsigned long>, std::is_floating_point<unsigned long>>> : public conditional<is_integral<unsigned long>::value, is_integral<unsigned long>, is_floating_point<unsigned long>>::type {
    }
template<> struct __or_<<std::is_integral<unsigned long long>, std::is_floating_point<unsigned long long>>> : public conditional<is_integral<unsigned long long>::value, is_integral<unsigned long long>, is_floating_point<unsigned long long>>::type {
    }
template<> struct __or_<<std::is_void<const char *const &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public conditional<is_void<const char *const &>::value, is_void<const char *const &>, __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>>::type {
    }
template<> struct __or_<<std::is_void<const char *const *>, std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> : public conditional<is_void<const char *const *>::value, is_void<const char *const *>, __or_<is_function<const basic_string<char> *>, is_array<const basic_string<char> *>>>::type {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> : public conditional<is_function<const basic_string<char> *>::value, is_function<const basic_string<char> *>, is_array<const basic_string<char> *>>::type {
    }
template<> struct __or_<<std::is_void<const char *const &>, std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_void<const char *const &>::value, is_void<const char *const &>, __or_<is_function<const char *>, is_array<const char *>>>::type {
    }
template<> struct __or_<<std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_function<const char *>::value, is_function<const char *>, is_array<const char *>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *const &>, std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> : public conditional<is_void<const wchar_t *const &>::value, is_void<const wchar_t *const &>, __or_<is_function<basic_string_view<wchar_t, char_traits<wchar_t>>>, is_array<basic_string_view<wchar_t, char_traits<wchar_t>>>>>::type {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> : public conditional<is_function<basic_string_view<wchar_t, char_traits<wchar_t>>>::value, is_function<basic_string_view<wchar_t, char_traits<wchar_t>>>, is_array<basic_string_view<wchar_t, char_traits<wchar_t>>>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *const *>, std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>>> : public conditional<is_void<const wchar_t *const *>::value, is_void<const wchar_t *const *>, __or_<is_function<const basic_string<wchar_t> *>, is_array<const basic_string<wchar_t> *>>>::type {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>>> : public conditional<is_function<const basic_string<wchar_t> *>::value, is_function<const basic_string<wchar_t> *>, is_array<const basic_string<wchar_t> *>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *const &>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_void<const wchar_t *const &>::value, is_void<const wchar_t *const &>, __or_<is_function<const wchar_t *>, is_array<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_function<const wchar_t *>::value, is_function<const wchar_t *>, is_array<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *const &>, std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>>> : public conditional<is_void<const char16_t *const &>::value, is_void<const char16_t *const &>, __or_<is_function<basic_string_view<char16_t, char_traits<char16_t>>>, is_array<basic_string_view<char16_t, char_traits<char16_t>>>>>::type {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>>> : public conditional<is_function<basic_string_view<char16_t, char_traits<char16_t>>>::value, is_function<basic_string_view<char16_t, char_traits<char16_t>>>, is_array<basic_string_view<char16_t, char_traits<char16_t>>>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *const *>, std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> : public conditional<is_void<const char16_t *const *>::value, is_void<const char16_t *const *>, __or_<is_function<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>, is_array<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>>::type {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> : public conditional<is_function<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>::value, is_function<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>, is_array<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *const &>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public conditional<is_void<const char16_t *const &>::value, is_void<const char16_t *const &>, __or_<is_function<const char16_t *>, is_array<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public conditional<is_function<const char16_t *>::value, is_function<const char16_t *>, is_array<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *const &>, std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>>> : public conditional<is_void<const char32_t *const &>::value, is_void<const char32_t *const &>, __or_<is_function<basic_string_view<char32_t, char_traits<char32_t>>>, is_array<basic_string_view<char32_t, char_traits<char32_t>>>>>::type {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>>> : public conditional<is_function<basic_string_view<char32_t, char_traits<char32_t>>>::value, is_function<basic_string_view<char32_t, char_traits<char32_t>>>, is_array<basic_string_view<char32_t, char_traits<char32_t>>>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *const *>, std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> : public conditional<is_void<const char32_t *const *>::value, is_void<const char32_t *const *>, __or_<is_function<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>, is_array<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>>::type {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> : public conditional<is_function<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>::value, is_function<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>, is_array<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *const &>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public conditional<is_void<const char32_t *const &>::value, is_void<const char32_t *const &>, __or_<is_function<const char32_t *>, is_array<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public conditional<is_function<const char32_t *>::value, is_function<const char32_t *>, is_array<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public conditional<is_void<const char &>::value, is_void<const char &>, __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>>::type {
    }
template<> struct __or_<<std::is_reference<std::allocator<char>>, std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public conditional<is_reference<allocator<char>>::value, is_reference<allocator<char>>, __or_<is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<std::allocator<char>>, std::is_rvalue_reference<std::allocator<char>>>> : public conditional<is_lvalue_reference<allocator<char>>::value, is_lvalue_reference<allocator<char>>, is_rvalue_reference<allocator<char>>>::type {
    }
template<> struct __or_<<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public conditional<is_function<allocator<char>>::value, is_function<allocator<char>>, __or_<is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>>::type {
    }
template<> struct __or_<<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public conditional<is_void<allocator<char>>::value, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>::type {
    }
template<> struct __or_<<std::is_void<const int &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public conditional<is_void<const int &>::value, is_void<const int &>, __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>>::type {
    }
template<> struct __or_<<std::is_reference<bool>, std::is_function<bool>, std::is_void<bool>, std::__is_array_unknown_bounds<bool>>> : public conditional<is_reference<bool>::value, is_reference<bool>, __or_<is_function<bool>, is_void<bool>, __is_array_unknown_bounds<bool>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<bool>, std::is_rvalue_reference<bool>>> : public conditional<is_lvalue_reference<bool>::value, is_lvalue_reference<bool>, is_rvalue_reference<bool>>::type {
    }
template<> struct __or_<<std::is_function<bool>, std::is_void<bool>, std::__is_array_unknown_bounds<bool>>> : public conditional<is_function<bool>::value, is_function<bool>, __or_<is_void<bool>, __is_array_unknown_bounds<bool>>>::type {
    }
template<> struct __or_<<std::is_void<bool>, std::__is_array_unknown_bounds<bool>>> : public conditional<is_void<bool>::value, is_void<bool>, __is_array_unknown_bounds<bool>>::type {
    }
template<> struct __or_<<std::is_reference<unsigned long>, std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public conditional<is_reference<unsigned long>::value, is_reference<unsigned long>, __or_<is_function<unsigned long>, is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>>> : public conditional<is_lvalue_reference<unsigned long>::value, is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public conditional<is_function<unsigned long>::value, is_function<unsigned long>, __or_<is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public conditional<is_void<unsigned long>::value, is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>::type {
    }
template<> struct __or_<<std::is_void<const bool &>, std::is_function<bool>, std::is_array<bool>>> : public conditional<is_void<const bool &>::value, is_void<const bool &>, __or_<is_function<bool>, is_array<bool>>>::type {
    }
template<> struct __or_<<std::is_function<bool>, std::is_array<bool>>> : public conditional<is_function<bool>::value, is_function<bool>, is_array<bool>>::type {
    }
template<> struct __or_<<std::is_void<const unsigned long &>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_void<const unsigned long &>::value, is_void<const unsigned long &>, __or_<is_function<unsigned long>, is_array<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_function<unsigned long>::value, is_function<unsigned long>, is_array<unsigned long>>::type {
    }
template<> struct __or_<<std::is_void<bool &&>, std::is_function<bool>, std::is_array<bool>>> : public conditional<is_void<bool &&>::value, is_void<bool &&>, __or_<is_function<bool>, is_array<bool>>>::type {
    }
template<> struct __or_<<std::is_void<unsigned long &&>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_void<unsigned long &&>::value, is_void<unsigned long &&>, __or_<is_function<unsigned long>, is_array<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_void<int &&>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_void<int &&>::value, is_void<int &&>, __or_<is_function<unsigned long>, is_array<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_reference<const int>, std::is_function<const int>, std::is_void<const int>, std::__is_array_unknown_bounds<const int>>> : public conditional<is_reference<const int>::value, is_reference<const int>, __or_<is_function<const int>, is_void<const int>, __is_array_unknown_bounds<const int>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const int>, std::is_rvalue_reference<const int>>> : public conditional<is_lvalue_reference<const int>::value, is_lvalue_reference<const int>, is_rvalue_reference<const int>>::type {
    }
template<> struct __or_<<std::is_function<const int>, std::is_void<const int>, std::__is_array_unknown_bounds<const int>>> : public conditional<is_function<const int>::value, is_function<const int>, __or_<is_void<const int>, __is_array_unknown_bounds<const int>>>::type {
    }
template<> struct __or_<<std::is_void<const int>, std::__is_array_unknown_bounds<const int>>> : public conditional<is_void<const int>::value, is_void<const int>, __is_array_unknown_bounds<const int>>::type {
    }
template<> struct __or_<<std::__not_<std::integral_constant<bool, false>>, std::is_default_constructible<std::__detail::_Mod_range_hashing>>> : public conditional<__not_<integral_constant<bool, false>>::value, __not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>>::type {
    }
template<> struct __or_<<std::is_void<std::random_access_iterator_tag>, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public conditional<is_void<random_access_iterator_tag>::value, is_void<random_access_iterator_tag>, __or_<is_function<input_iterator_tag>, is_array<input_iterator_tag>>>::type {
    }
template<> struct __or_<<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public conditional<is_function<input_iterator_tag>::value, is_function<input_iterator_tag>, is_array<input_iterator_tag>>::type {
    }
template<> struct __or_<<std::is_void<char *const &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public conditional<is_void<char *const &>::value, is_void<char *const &>, __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>>::type {
    }
template<> struct __or_<<std::is_void<char *const *>, std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> : public conditional<is_void<char *const *>::value, is_void<char *const *>, __or_<is_function<const basic_string<char> *>, is_array<const basic_string<char> *>>>::type {
    }
template<> struct __or_<<std::is_void<char *const &>, std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_void<char *const &>::value, is_void<char *const &>, __or_<is_function<const char *>, is_array<const char *>>>::type {
    }
template<> struct __or_<<std::is_void<wchar_t *const &>, std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> : public conditional<is_void<wchar_t *const &>::value, is_void<wchar_t *const &>, __or_<is_function<basic_string_view<wchar_t, char_traits<wchar_t>>>, is_array<basic_string_view<wchar_t, char_traits<wchar_t>>>>>::type {
    }
template<> struct __or_<<std::is_void<wchar_t *const *>, std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>>> : public conditional<is_void<wchar_t *const *>::value, is_void<wchar_t *const *>, __or_<is_function<const basic_string<wchar_t> *>, is_array<const basic_string<wchar_t> *>>>::type {
    }
template<> struct __or_<<std::is_void<wchar_t *const &>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_void<wchar_t *const &>::value, is_void<wchar_t *const &>, __or_<is_function<const wchar_t *>, is_array<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const std::__cxx11::basic_string<char> &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public conditional<is_void<const basic_string<char> &>::value, is_void<const basic_string<char> &>, __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>>::type {
    }
template<> struct __or_<<std::is_void<const std::__cxx11::basic_string<char> *>, std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> : public conditional<is_void<const basic_string<char> *>::value, is_void<const basic_string<char> *>, __or_<is_function<const basic_string<char> *>, is_array<const basic_string<char> *>>>::type {
    };
    template<> struct __or_<> : public std::false_type {
    };
    template <typename _B1> struct __or_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __or_<_B1, _B2> : public conditional<_B1::value, _B1, _B2>::type {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __or_<_B1, _B2, _B3, _Bn...> : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type {
    };
    template <typename ...> struct __and_
template<> struct __and_<<std::is_array<char>, std::__not_<std::extent<char, 0>>>> : public conditional<is_array<char>::value, __not_<extent<char, 0>>, is_array<char>>::type {
    }
template<> struct __and_<<std::is_array<wchar_t>, std::__not_<std::extent<wchar_t, 0>>>> : public conditional<is_array<wchar_t>::value, __not_<extent<wchar_t, 0>>, is_array<wchar_t>>::type {
    }
template<> struct __and_<<std::is_array<char16_t>, std::__not_<std::extent<char16_t, 0>>>> : public conditional<is_array<char16_t>::value, __not_<extent<char16_t, 0>>, is_array<char16_t>>::type {
    }
template<> struct __and_<<std::is_array<char32_t>, std::__not_<std::extent<char32_t, 0>>>> : public conditional<is_array<char32_t>::value, __not_<extent<char32_t, 0>>, is_array<char32_t>>::type {
    }
template<> struct __and_<<std::is_arithmetic<unsigned int>, std::__not_<std::is_signed<unsigned int>>>> : public conditional<is_arithmetic<unsigned int>::value, __not_<is_signed<unsigned int>>, is_arithmetic<unsigned int>>::type {
    }
template<> struct __and_<<std::is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const unsigned int *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>> : public conditional<is_convertible<const unsigned int &, basic_string_view<char, char_traits<char>>>::value, __and_<__not_<is_convertible<const unsigned int *, const basic_string<char> *>>, __not_<is_convertible<const unsigned int &, const char *>>>, is_convertible<const unsigned int &, basic_string_view<char, char_traits<char>>>>::type {
    }
template<> struct __and_<<std::is_arithmetic<unsigned long>, std::__not_<std::is_signed<unsigned long>>>> : public conditional<is_arithmetic<unsigned long>::value, __not_<is_signed<unsigned long>>, is_arithmetic<unsigned long>>::type {
    }
template<> struct __and_<<std::is_arithmetic<unsigned long long>, std::__not_<std::is_signed<unsigned long long>>>> : public conditional<is_arithmetic<unsigned long long>::value, __not_<is_signed<unsigned long long>>, is_arithmetic<unsigned long long>>::type {
    }
template<> struct __and_<<std::is_convertible<const char *const &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>> : public conditional<is_convertible<const char *const &, basic_string_view<char, char_traits<char>>>::value, __and_<__not_<is_convertible<const char *const *, const basic_string<char> *>>, __not_<is_convertible<const char *const &, const char *>>>, is_convertible<const char *const &, basic_string_view<char, char_traits<char>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>> : public conditional<__not_<is_convertible<const char *const *, const basic_string<char> *>>::value, __not_<is_convertible<const char *const &, const char *>>, __not_<is_convertible<const char *const *, const basic_string<char> *>>>::type {
    }
template<> struct __and_<<std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>> : public conditional<is_convertible<const wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::value, __and_<__not_<is_convertible<const wchar_t *const *, const basic_string<wchar_t> *>>, __not_<is_convertible<const wchar_t *const &, const wchar_t *>>>, is_convertible<const wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>> : public conditional<__not_<is_convertible<const wchar_t *const *, const basic_string<wchar_t> *>>::value, __not_<is_convertible<const wchar_t *const &, const wchar_t *>>, __not_<is_convertible<const wchar_t *const *, const basic_string<wchar_t> *>>>::type {
    }
template<> struct __and_<<std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>> : public conditional<is_convertible<const char16_t *const &, basic_string_view<char16_t, char_traits<char16_t>>>::value, __and_<__not_<is_convertible<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>, __not_<is_convertible<const char16_t *const &, const char16_t *>>>, is_convertible<const char16_t *const &, basic_string_view<char16_t, char_traits<char16_t>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>> : public conditional<__not_<is_convertible<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>::value, __not_<is_convertible<const char16_t *const &, const char16_t *>>, __not_<is_convertible<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>>::type {
    }
template<> struct __and_<<std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>> : public conditional<is_convertible<const char32_t *const &, basic_string_view<char32_t, char_traits<char32_t>>>::value, __and_<__not_<is_convertible<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>, __not_<is_convertible<const char32_t *const &, const char32_t *>>>, is_convertible<const char32_t *const &, basic_string_view<char32_t, char_traits<char32_t>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>> : public conditional<__not_<is_convertible<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>::value, __not_<is_convertible<const char32_t *const &, const char32_t *>>, __not_<is_convertible<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>>::type {
    }
template<> struct __and_<<std::is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const char *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char &, const char *>>>> : public conditional<is_convertible<const char &, basic_string_view<char, char_traits<char>>>::value, __and_<__not_<is_convertible<const char *, const basic_string<char> *>>, __not_<is_convertible<const char &, const char *>>>, is_convertible<const char &, basic_string_view<char, char_traits<char>>>>::type {
    }
template<> struct __and_<<std::is_array<std::allocator<char>>, std::__not_<std::extent<std::allocator<char>, 0>>>> : public conditional<is_array<allocator<char>>::value, __not_<extent<allocator<char>, 0>>, is_array<allocator<char>>>::type {
    }
template<> struct __and_<<std::is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const int *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const int &, const char *>>>> : public conditional<is_convertible<const int &, basic_string_view<char, char_traits<char>>>::value, __and_<__not_<is_convertible<const int *, const basic_string<char> *>>, __not_<is_convertible<const int &, const char *>>>, is_convertible<const int &, basic_string_view<char, char_traits<char>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>, std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, char &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<char> &>>::value, __and_<__is_convertible_to_basic_istream<basic_istream<char> &>, __is_extractable<basic_istream<char> &, char &, void>>, __not_<is_lvalue_reference<basic_istream<char> &>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>, std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, unsigned char &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<char> &>>::value, __and_<__is_convertible_to_basic_istream<basic_istream<char> &>, __is_extractable<basic_istream<char> &, unsigned char &, void>>, __not_<is_lvalue_reference<basic_istream<char> &>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>, std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, signed char &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<char> &>>::value, __and_<__is_convertible_to_basic_istream<basic_istream<char> &>, __is_extractable<basic_istream<char> &, signed char &, void>>, __not_<is_lvalue_reference<basic_istream<char> &>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &>>, std::__is_convertible_to_basic_istream<std::basic_istream<wchar_t> &>, std::__is_extractable<std::basic_istream<wchar_t> &, wchar_t &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<wchar_t> &>>::value, __and_<__is_convertible_to_basic_istream<basic_istream<wchar_t> &>, __is_extractable<basic_istream<wchar_t> &, wchar_t &, void>>, __not_<is_lvalue_reference<basic_istream<wchar_t> &>>>::type {
    }
template<> struct __and_<<std::is_copy_assignable<bool>, std::is_copy_assignable<unsigned long>>> : public conditional<is_copy_assignable<bool>::value, is_copy_assignable<unsigned long>, is_copy_assignable<bool>>::type {
    }
template<> struct __and_<<std::is_array<bool>, std::__not_<std::extent<bool, 0>>>> : public conditional<is_array<bool>::value, __not_<extent<bool, 0>>, is_array<bool>>::type {
    }
template<> struct __and_<<std::is_array<unsigned long>, std::__not_<std::extent<unsigned long, 0>>>> : public conditional<is_array<unsigned long>::value, __not_<extent<unsigned long, 0>>, is_array<unsigned long>>::type {
    }
template<> struct __and_<<std::is_move_assignable<bool>, std::is_move_assignable<unsigned long>>> : public conditional<is_move_assignable<bool>::value, is_move_assignable<unsigned long>, is_move_assignable<bool>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, const bool &>, std::is_constructible<unsigned long, const unsigned long &>>> : public conditional<is_constructible<bool, const bool &>::value, is_constructible<unsigned long, const unsigned long &>, is_constructible<bool, const bool &>>::type {
    }
template<> struct __and_<<std::is_convertible<const bool &, bool>, std::is_convertible<const unsigned long &, unsigned long>>> : public conditional<is_convertible<const bool &, bool>::value, is_convertible<const unsigned long &, unsigned long>, is_convertible<const bool &, bool>>::type {
    }
template<> struct __and_<<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> : public conditional<is_convertible<bool &&, bool>::value, is_convertible<const unsigned long &, unsigned long>, is_convertible<bool &&, bool>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, bool &&>, std::is_constructible<unsigned long, const unsigned long &&>, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> : public conditional<is_constructible<bool, bool &&>::value, __and_<is_constructible<unsigned long, const unsigned long &&>, __and_<is_convertible<bool &&, bool>, is_convertible<const unsigned long &, unsigned long>>>, is_constructible<bool, bool &&>>::type {
    }
template<> struct __and_<<std::is_constructible<unsigned long, const unsigned long &&>, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> : public conditional<is_constructible<unsigned long, const unsigned long &&>::value, __and_<is_convertible<bool &&, bool>, is_convertible<const unsigned long &, unsigned long>>, is_constructible<unsigned long, const unsigned long &&>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, bool &&>, std::is_constructible<unsigned long, const unsigned long &&>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>>> : public conditional<is_constructible<bool, bool &&>::value, __and_<is_constructible<unsigned long, const unsigned long &&>, __not_<__and_<is_convertible<bool &&, bool>, is_convertible<const unsigned long &, unsigned long>>>>, is_constructible<bool, bool &&>>::type {
    }
template<> struct __and_<<std::is_constructible<unsigned long, const unsigned long &&>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>>> : public conditional<is_constructible<unsigned long, const unsigned long &&>::value, __not_<__and_<is_convertible<bool &&, bool>, is_convertible<const unsigned long &, unsigned long>>>, is_constructible<unsigned long, const unsigned long &&>>::type {
    }
template<> struct __and_<<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> : public conditional<is_convertible<const bool &, bool>::value, is_convertible<unsigned long &&, unsigned long>, is_convertible<const bool &, bool>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, const bool &>, std::is_constructible<unsigned long, unsigned long &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> : public conditional<is_constructible<bool, const bool &>::value, __and_<is_constructible<unsigned long, unsigned long &&>, __and_<is_convertible<const bool &, bool>, is_convertible<unsigned long &&, unsigned long>>>, is_constructible<bool, const bool &>>::type {
    }
template<> struct __and_<<std::is_constructible<unsigned long, unsigned long &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> : public conditional<is_constructible<unsigned long, unsigned long &&>::value, __and_<is_convertible<const bool &, bool>, is_convertible<unsigned long &&, unsigned long>>, is_constructible<unsigned long, unsigned long &&>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, const bool &>, std::is_constructible<unsigned long, unsigned long &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>>> : public conditional<is_constructible<bool, const bool &>::value, __and_<is_constructible<unsigned long, unsigned long &&>, __not_<__and_<is_convertible<const bool &, bool>, is_convertible<unsigned long &&, unsigned long>>>>, is_constructible<bool, const bool &>>::type {
    }
template<> struct __and_<<std::is_constructible<unsigned long, unsigned long &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>>> : public conditional<is_constructible<unsigned long, unsigned long &&>::value, __not_<__and_<is_convertible<const bool &, bool>, is_convertible<unsigned long &&, unsigned long>>>, is_constructible<unsigned long, unsigned long &&>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, bool &&>, std::is_constructible<unsigned long, unsigned long &&>>> : public conditional<is_constructible<bool, bool &&>::value, is_constructible<unsigned long, unsigned long &&>, is_constructible<bool, bool &&>>::type {
    }
template<> struct __and_<<std::is_convertible<bool &&, bool>, std::is_convertible<unsigned long &&, unsigned long>>> : public conditional<is_convertible<bool &&, bool>::value, is_convertible<unsigned long &&, unsigned long>, is_convertible<bool &&, bool>>::type {
    }
template<> struct __and_<<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> : public conditional<is_convertible<const bool &, bool>::value, is_convertible<int &&, unsigned long>, is_convertible<const bool &, bool>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, const bool &>, std::is_constructible<unsigned long, int &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> : public conditional<is_constructible<bool, const bool &>::value, __and_<is_constructible<unsigned long, int &&>, __and_<is_convertible<const bool &, bool>, is_convertible<int &&, unsigned long>>>, is_constructible<bool, const bool &>>::type {
    }
template<> struct __and_<<std::is_constructible<unsigned long, int &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> : public conditional<is_constructible<unsigned long, int &&>::value, __and_<is_convertible<const bool &, bool>, is_convertible<int &&, unsigned long>>, is_constructible<unsigned long, int &&>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, const bool &>, std::is_constructible<unsigned long, int &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>>> : public conditional<is_constructible<bool, const bool &>::value, __and_<is_constructible<unsigned long, int &&>, __not_<__and_<is_convertible<const bool &, bool>, is_convertible<int &&, unsigned long>>>>, is_constructible<bool, const bool &>>::type {
    }
template<> struct __and_<<std::is_constructible<unsigned long, int &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>>> : public conditional<is_constructible<unsigned long, int &&>::value, __not_<__and_<is_convertible<const bool &, bool>, is_convertible<int &&, unsigned long>>>, is_constructible<unsigned long, int &&>>::type {
    }
template<> struct __and_<<std::is_constructible<bool, bool &&>, std::is_constructible<unsigned long, int &&>>> : public conditional<is_constructible<bool, bool &&>::value, is_constructible<unsigned long, int &&>, is_constructible<bool, bool &&>>::type {
    }
template<> struct __and_<<std::is_convertible<bool &&, bool>, std::is_convertible<int &&, unsigned long>>> : public conditional<is_convertible<bool &&, bool>::value, is_convertible<int &&, unsigned long>, is_convertible<bool &&, bool>>::type {
    }
template<> struct __and_<<std::__is_fast_hash<std::hash<int>>, std::__is_nothrow_invocable<const std::hash<int> &, const int &>>> : public conditional<__is_fast_hash<hash<int>>::value, __is_nothrow_invocable<const hash<int> &, const int &>, __is_fast_hash<hash<int>>>::type {
    }
template<> struct __and_<<std::__is_invocable<const std::hash<int> &, const int &>, std::__call_is_nothrow<std::__invoke_result<const std::hash<int> &, const int &>, const std::hash<int> &, const int &>>> : public conditional<__is_invocable<const hash<int> &, const int &>::value, __call_is_nothrow<__invoke_result<const hash<int> &, const int &>, const hash<int> &, const int &>, __is_invocable<const hash<int> &, const int &>>::type {
    }
template<> struct __and_<<std::is_copy_assignable<const int>, std::is_copy_assignable<int>>> : public conditional<is_copy_assignable<const int>::value, is_copy_assignable<int>, is_copy_assignable<const int>>::type {
    }
template<> struct __and_<<std::is_array<const int>, std::__not_<std::extent<const int, 0>>>> : public conditional<is_array<const int>::value, __not_<extent<const int, 0>>, is_array<const int>>::type {
    }
template<> struct __and_<<std::is_move_assignable<const int>, std::is_move_assignable<int>>> : public conditional<is_move_assignable<const int>::value, is_move_assignable<int>, is_move_assignable<const int>>::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>>, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[11], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &>>::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[11], void>>, __not_<is_lvalue_reference<basic_ostream<char> &>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>>, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, const char *const &, void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &>>::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, const char *const &, void>>, __not_<is_lvalue_reference<basic_ostream<char> &>>>::type {
    }
template<> struct __and_<<std::is_convertible<char *const &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>> : public conditional<is_convertible<char *const &, basic_string_view<char, char_traits<char>>>::value, __and_<__not_<is_convertible<char *const *, const basic_string<char> *>>, __not_<is_convertible<char *const &, const char *>>>, is_convertible<char *const &, basic_string_view<char, char_traits<char>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>> : public conditional<__not_<is_convertible<char *const *, const basic_string<char> *>>::value, __not_<is_convertible<char *const &, const char *>>, __not_<is_convertible<char *const *, const basic_string<char> *>>>::type {
    }
template<> struct __and_<<std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>> : public conditional<is_convertible<wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::value, __and_<__not_<is_convertible<wchar_t *const *, const basic_string<wchar_t> *>>, __not_<is_convertible<wchar_t *const &, const wchar_t *>>>, is_convertible<wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>> : public conditional<__not_<is_convertible<wchar_t *const *, const basic_string<wchar_t> *>>::value, __not_<is_convertible<wchar_t *const &, const wchar_t *>>, __not_<is_convertible<wchar_t *const *, const basic_string<wchar_t> *>>>::type {
    }
template<> struct __and_<<std::is_convertible<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>>> : public conditional<is_convertible<const basic_string<char> &, basic_string_view<char, char_traits<char>>>::value, __and_<__not_<is_convertible<const basic_string<char> *, const basic_string<char> *>>, __not_<is_convertible<const basic_string<char> &, const char *>>>, is_convertible<const basic_string<char> &, basic_string_view<char, char_traits<char>>>>::type {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>>> : public conditional<__not_<is_convertible<const basic_string<char> *, const basic_string<char> *>>::value, __not_<is_convertible<const basic_string<char> &, const char *>>, __not_<is_convertible<const basic_string<char> *, const basic_string<char> *>>>::type {
    };
    template<> struct __and_<> : public std::true_type {
    };
    template <typename _B1> struct __and_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __and_<_B1, _B2> : public conditional<_B1::value, _B2, _B1>::type {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __and_<_B1, _B2, _B3, _Bn...> : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type {
    };
    template <typename _Pp> struct __not_ : public __bool_constant<!bool(_Pp::value)> {
    };
template<> struct __not_<std::is_signed<unsigned int>> : public __bool_constant<!bool(is_signed<unsigned int>::value)> {
    };
template<> struct __not_<std::is_signed<unsigned long>> : public __bool_constant<!bool(is_signed<unsigned long>::value)> {
    };
template<> struct __not_<std::is_signed<unsigned long long>> : public __bool_constant<!bool(is_signed<unsigned long long>::value)> {
    };
template<> struct __not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>> : public __bool_constant<!bool(is_convertible<const char *const *, const basic_string<char> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char *const &, const char *>> : public __bool_constant<!bool(is_convertible<const char *const &, const char *>::value)> {
    };
template<> struct __not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>> : public __bool_constant<!bool(is_convertible<const wchar_t *const *, const basic_string<wchar_t> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const wchar_t *const &, const wchar_t *>> : public __bool_constant<!bool(is_convertible<const wchar_t *const &, const wchar_t *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>> : public __bool_constant<!bool(is_convertible<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char16_t *const &, const char16_t *>> : public __bool_constant<!bool(is_convertible<const char16_t *const &, const char16_t *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>> : public __bool_constant<!bool(is_convertible<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char32_t *const &, const char32_t *>> : public __bool_constant<!bool(is_convertible<const char32_t *const &, const char32_t *>::value)> {
    };
template<> struct __not_<std::is_lvalue_reference<std::basic_istream<char> &>> : public __bool_constant<!bool(is_lvalue_reference<basic_istream<char> &>::value)> {
    };
template<> struct __not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &>> : public __bool_constant<!bool(is_lvalue_reference<basic_istream<wchar_t> &>::value)> {
    };
template<> struct __not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> : public __bool_constant<!bool(__and_<is_convertible<bool &&, bool>, is_convertible<const unsigned long &, unsigned long>>::value)> {
    };
template<> struct __not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> : public __bool_constant<!bool(__and_<is_convertible<const bool &, bool>, is_convertible<unsigned long &&, unsigned long>>::value)> {
    };
template<> struct __not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> : public __bool_constant<!bool(__and_<is_convertible<const bool &, bool>, is_convertible<int &&, unsigned long>>::value)> {
    };
template<> struct __not_<std::__and_<std::__is_fast_hash<std::hash<int>>, std::__is_nothrow_invocable<const std::hash<int> &, const int &>>> : public __bool_constant<!bool(__and_<__is_fast_hash<hash<int>>, __is_nothrow_invocable<const hash<int> &, const int &>>::value)> {
    };
template<> struct __not_<std::integral_constant<bool, false>> : public __bool_constant<!bool(integral_constant<bool, false>::value)> {
    };
template<> struct __not_<std::is_lvalue_reference<std::basic_ostream<char> &>> : public __bool_constant<!bool(is_lvalue_reference<basic_ostream<char> &>::value)> {
    };
template<> struct __not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>> : public __bool_constant<!bool(is_convertible<char *const *, const basic_string<char> *>::value)> {
    };
template<> struct __not_<std::is_convertible<char *const &, const char *>> : public __bool_constant<!bool(is_convertible<char *const &, const char *>::value)> {
    };
template<> struct __not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>> : public __bool_constant<!bool(is_convertible<wchar_t *const *, const basic_string<wchar_t> *>::value)> {
    };
template<> struct __not_<std::is_convertible<wchar_t *const &, const wchar_t *>> : public __bool_constant<!bool(is_convertible<wchar_t *const &, const wchar_t *>::value)> {
    };
template<> struct __not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>> : public __bool_constant<!bool(is_convertible<const basic_string<char> *, const basic_string<char> *>::value)> {
    };
    template <typename ..._Bn> constexpr bool __or_v = __or_<_Bn...>::value;
    template <typename ..._Bn> constexpr bool __and_v = __and_<_Bn...>::value;
    template <typename ..._Bn> struct conjunction : __and_<_Bn...> {
    };
    template <typename ..._Bn> struct disjunction : __or_<_Bn...> {
    };
    template <typename _Pp> struct negation : __not_<_Pp> {
    };
    template <typename ..._Bn> constexpr bool conjunction_v = conjunction<_Bn...>::value;
    template <typename ..._Bn> constexpr bool disjunction_v = disjunction<_Bn...>::value;
    template <typename _Pp> constexpr bool negation_v = negation<_Pp>::value;
    template <typename> struct is_reference
template<> struct is_reference<char> : public __or_<is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    }
template<> struct is_reference<wchar_t> : public __or_<is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    }
template<> struct is_reference<char16_t> : public __or_<is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    }
template<> struct is_reference<char32_t> : public __or_<is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    }
template<> struct is_reference<std::allocator<char>> : public __or_<is_lvalue_reference<allocator<char>>, is_rvalue_reference<allocator<char>>>::type {
    }
template<> struct is_reference<bool> : public __or_<is_lvalue_reference<bool>, is_rvalue_reference<bool>>::type {
    }
template<> struct is_reference<unsigned long> : public __or_<is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    }
template<> struct is_reference<const int> : public __or_<is_lvalue_reference<const int>, is_rvalue_reference<const int>>::type {
    };
    template <typename> struct is_function
template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    }
template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    }
template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    }
template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    }
template<> struct is_function<std::basic_string_view<char, std::char_traits<char>>> : public __bool_constant<!is_const<const basic_string_view<char, char_traits<char>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<char> *> : public __bool_constant<!is_const<const basic_string<char> *const>::value> {
    }
template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    }
template<> struct is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __bool_constant<!is_const<const basic_string_view<wchar_t, char_traits<wchar_t>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<wchar_t> *> : public __bool_constant<!is_const<const basic_string<wchar_t> *const>::value> {
    }
template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    }
template<> struct is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public __bool_constant<!is_const<const basic_string_view<char16_t, char_traits<char16_t>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public __bool_constant<!is_const<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *const>::value> {
    }
template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    }
template<> struct is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public __bool_constant<!is_const<const basic_string_view<char32_t, char_traits<char32_t>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public __bool_constant<!is_const<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *const>::value> {
    }
template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    }
template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    }
template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    }
template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    }
template<> struct is_function<const int> : public __bool_constant<!is_const<const const int>::value> {
    }
template<> struct is_function<std::input_iterator_tag> : public __bool_constant<!is_const<const input_iterator_tag>::value> {
    };
    template <typename> struct is_void
template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    }
template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    }
template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    }
template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    }
template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    }
template<> struct is_void<const unsigned int &> : public __is_void_helper<__remove_cv_t<const unsigned int &>>::type {
    }
template<> struct is_void<const char *const &> : public __is_void_helper<__remove_cv_t<const char *const &>>::type {
    }
template<> struct is_void<const char *const *> : public __is_void_helper<__remove_cv_t<const char *const *>>::type {
    }
template<> struct is_void<const wchar_t *const &> : public __is_void_helper<__remove_cv_t<const wchar_t *const &>>::type {
    }
template<> struct is_void<const wchar_t *const *> : public __is_void_helper<__remove_cv_t<const wchar_t *const *>>::type {
    }
template<> struct is_void<const char16_t *const &> : public __is_void_helper<__remove_cv_t<const char16_t *const &>>::type {
    }
template<> struct is_void<const char16_t *const *> : public __is_void_helper<__remove_cv_t<const char16_t *const *>>::type {
    }
template<> struct is_void<const char32_t *const &> : public __is_void_helper<__remove_cv_t<const char32_t *const &>>::type {
    }
template<> struct is_void<const char32_t *const *> : public __is_void_helper<__remove_cv_t<const char32_t *const *>>::type {
    }
template<> struct is_void<const char &> : public __is_void_helper<__remove_cv_t<const char &>>::type {
    }
template<> struct is_void<std::allocator<char>> : public __is_void_helper<__remove_cv_t<allocator<char>>>::type {
    }
template<> struct is_void<const int &> : public __is_void_helper<__remove_cv_t<const int &>>::type {
    }
template<> struct is_void<bool> : public __is_void_helper<__remove_cv_t<bool>>::type {
    }
template<> struct is_void<unsigned long> : public __is_void_helper<__remove_cv_t<unsigned long>>::type {
    }
template<> struct is_void<const bool &> : public __is_void_helper<__remove_cv_t<const bool &>>::type {
    }
template<> struct is_void<const unsigned long &> : public __is_void_helper<__remove_cv_t<const unsigned long &>>::type {
    }
template<> struct is_void<bool &&> : public __is_void_helper<__remove_cv_t<bool &&>>::type {
    }
template<> struct is_void<unsigned long &&> : public __is_void_helper<__remove_cv_t<unsigned long &&>>::type {
    }
template<> struct is_void<int &&> : public __is_void_helper<__remove_cv_t<int &&>>::type {
    }
template<> struct is_void<const int> : public __is_void_helper<__remove_cv_t<const int>>::type {
    }
template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    }
template<> struct is_void<std::random_access_iterator_tag> : public __is_void_helper<__remove_cv_t<random_access_iterator_tag>>::type {
    }
template<> struct is_void<char *const &> : public __is_void_helper<__remove_cv_t<char *const &>>::type {
    }
template<> struct is_void<char *const *> : public __is_void_helper<__remove_cv_t<char *const *>>::type {
    }
template<> struct is_void<wchar_t *const &> : public __is_void_helper<__remove_cv_t<wchar_t *const &>>::type {
    }
template<> struct is_void<wchar_t *const *> : public __is_void_helper<__remove_cv_t<wchar_t *const *>>::type {
    }
template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    }
template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    }
template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    }
template<> struct is_void<const std::__cxx11::basic_string<char> &> : public __is_void_helper<__remove_cv_t<const basic_string<char> &>>::type {
    }
template<> struct is_void<const std::__cxx11::basic_string<char> *> : public __is_void_helper<__remove_cv_t<const basic_string<char> *>>::type {
    };
    template <typename> struct __is_array_unknown_bounds
template<> struct __is_array_unknown_bounds<char> : public __and_<is_array<char>, __not_<extent<char>>> {
    }
template<> struct __is_array_unknown_bounds<wchar_t> : public __and_<is_array<wchar_t>, __not_<extent<wchar_t>>> {
    }
template<> struct __is_array_unknown_bounds<char16_t> : public __and_<is_array<char16_t>, __not_<extent<char16_t>>> {
    }
template<> struct __is_array_unknown_bounds<char32_t> : public __and_<is_array<char32_t>, __not_<extent<char32_t>>> {
    }
template<> struct __is_array_unknown_bounds<std::allocator<char>> : public __and_<is_array<std::allocator<char>>, __not_<extent<std::allocator<char>>>> {
    }
template<> struct __is_array_unknown_bounds<bool> : public __and_<is_array<bool>, __not_<extent<bool>>> {
    }
template<> struct __is_array_unknown_bounds<unsigned long> : public __and_<is_array<unsigned long>, __not_<extent<unsigned long>>> {
    }
template<> struct __is_array_unknown_bounds<const int> : public __and_<is_array<const int>, __not_<extent<const int>>> {
    };
    template <typename _Tp, std::size_t = sizeof(_Tp)> constexpr std::true_type __is_complete_or_unbounded(__type_identity<_Tp>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char, 1>(__type_identity<char>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<wchar_t, 4>(__type_identity<wchar_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char16_t, 2>(__type_identity<char16_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char32_t, 4>(__type_identity<char32_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<std::allocator<char>, 1>(__type_identity<std::allocator<char>>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<bool, 1>(__type_identity<bool>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<unsigned long, 8>(__type_identity<unsigned long>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const int, 4>(__type_identity<const int>)     {
        return {};
    }
    template <typename _TypeIdentity, typename _NestedType = typename _TypeIdentity::type> constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>, __is_array_unknown_bounds<_NestedType>>::type __is_complete_or_unbounded(_TypeIdentity)     {
        return {};
    }
    template<> constexpr typename __or_<is_reference<char>, is_function<char>, is_void<char>, __is_array_unknown_bounds<char>>::type __is_complete_or_unbounded<std::__type_identity<char>, char>(std::__type_identity<char>)    template<> constexpr typename __or_<is_reference<wchar_t>, is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>::type __is_complete_or_unbounded<std::__type_identity<wchar_t>, wchar_t>(std::__type_identity<wchar_t>)    template<> constexpr typename __or_<is_reference<char16_t>, is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>::type __is_complete_or_unbounded<std::__type_identity<char16_t>, char16_t>(std::__type_identity<char16_t>)    template<> constexpr typename __or_<is_reference<char32_t>, is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>::type __is_complete_or_unbounded<std::__type_identity<char32_t>, char32_t>(std::__type_identity<char32_t>)    template<> constexpr typename __or_<is_reference<allocator<char>>, is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>::type __is_complete_or_unbounded<std::__type_identity<std::allocator<char>>, std::allocator<char>>(std::__type_identity<std::allocator<char>>)    template<> constexpr typename __or_<is_reference<bool>, is_function<bool>, is_void<bool>, __is_array_unknown_bounds<bool>>::type __is_complete_or_unbounded<std::__type_identity<bool>, bool>(std::__type_identity<bool>)    template<> constexpr typename __or_<is_reference<unsigned long>, is_function<unsigned long>, is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>::type __is_complete_or_unbounded<std::__type_identity<unsigned long>, unsigned long>(std::__type_identity<unsigned long>)    template<> constexpr typename __or_<is_reference<const int>, is_function<const int>, is_void<const int>, __is_array_unknown_bounds<const int>>::type __is_complete_or_unbounded<std::__type_identity<const int>, const int>(std::__type_identity<const int>)    template <typename _Tp> struct __success_type {
        typedef _Tp type;
    };
template<> struct __success_type<unsigned long> {
        typedef unsigned long type;
    };
    struct __failure_type {
    };
    template <typename> struct remove_cv
template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    }
template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    }
template<> struct remove_cv<char16_t> {
        using type = char16_t;
    }
template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    }
template<> struct remove_cv<char32_t> {
        using type = char32_t;
    }
template<> struct remove_cv<void> {
        using type = void;
    }
template<> struct remove_cv<bool> {
        using type = bool;
    }
template<> struct remove_cv<int> {
        using type = int;
    }
template<> struct remove_cv<char> {
        using type = char;
    }
template<> struct remove_cv<const unsigned int &> {
        using type = const unsigned int &;
    }
template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    }
template<> struct remove_cv<unsigned long long> {
        using type = unsigned long long;
    }
template<> struct remove_cv<const char *const &> {
        using type = const char *const &;
    }
template<> struct remove_cv<const char *const *> {
        using type = const char *const *;
    }
template<> struct remove_cv<const wchar_t *const &> {
        using type = const wchar_t *const &;
    }
template<> struct remove_cv<const wchar_t *const *> {
        using type = const wchar_t *const *;
    }
template<> struct remove_cv<const char16_t *const &> {
        using type = const char16_t *const &;
    }
template<> struct remove_cv<const char16_t *const *> {
        using type = const char16_t *const *;
    }
template<> struct remove_cv<const char32_t *const &> {
        using type = const char32_t *const &;
    }
template<> struct remove_cv<const char32_t *const *> {
        using type = const char32_t *const *;
    }
template<> struct remove_cv<const char &> {
        using type = const char &;
    }
template<> struct remove_cv<std::allocator<char>> {
        using type = std::allocator<char>;
    }
template<> struct remove_cv<const int &> {
        using type = const int &;
    }
template<> struct remove_cv<const bool &> {
        using type = const bool &;
    }
template<> struct remove_cv<const unsigned long &> {
        using type = const unsigned long &;
    }
template<> struct remove_cv<bool &&> {
        using type = bool &&;
    }
template<> struct remove_cv<unsigned long &&> {
        using type = unsigned long &&;
    }
template<> struct remove_cv<int &&> {
        using type = int &&;
    }
template<> struct remove_cv<const std::hash<int>> {
        using type = std::hash<int>;
    }
template<> struct remove_cv<const int> {
        using type = int;
    }
template<> struct remove_cv<std::pair<const int, int>> {
        using type = std::pair<const int, int>;
    }
template<> struct remove_cv<const char> {
        using type = char;
    }
template<> struct remove_cv<std::random_access_iterator_tag> {
        using type = std::random_access_iterator_tag;
    }
template<> struct remove_cv<char *const &> {
        using type = char *const &;
    }
template<> struct remove_cv<char *const *> {
        using type = char *const *;
    }
template<> struct remove_cv<wchar_t *const &> {
        using type = wchar_t *const &;
    }
template<> struct remove_cv<wchar_t *const *> {
        using type = wchar_t *const *;
    }
template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    }
template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    }
template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    }
template<> struct remove_cv<const std::__cxx11::basic_string<char> &> {
        using type = const std::__cxx11::basic_string<char> &;
    }
template<> struct remove_cv<const std::__cxx11::basic_string<char> *> {
        using type = const std::__cxx11::basic_string<char> *;
    };
    template <typename _Tp> using __remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename> struct is_const
template<> struct is_const<wchar_t> : public std::false_type {
    }
template<> struct is_const<char16_t> : public std::false_type {
    }
template<> struct is_const<char32_t> : public std::false_type {
    }
template<> struct is_const<unsigned int> : public std::false_type {
    }
template<> struct is_const<unsigned short> : public std::false_type {
    }
template<> struct is_const<int> : public std::false_type {
    }
template<> struct is_const<const char> : public std::true_type {
    }
template<> struct is_const<const wchar_t> : public std::true_type {
    }
template<> struct is_const<const char16_t> : public std::true_type {
    }
template<> struct is_const<const char32_t> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<char, std::char_traits<char>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<char> *const> : public std::true_type {
    }
template<> struct is_const<const char *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<wchar_t> *const> : public std::true_type {
    }
template<> struct is_const<const wchar_t *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *const> : public std::true_type {
    }
template<> struct is_const<const char16_t *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *const> : public std::true_type {
    }
template<> struct is_const<const char32_t *const> : public std::true_type {
    }
template<> struct is_const<const std::allocator<char>> : public std::true_type {
    }
template<> struct is_const<const bool> : public std::true_type {
    }
template<> struct is_const<const unsigned long> : public std::true_type {
    }
template<> struct is_const<const int> : public std::true_type {
    }
template<> struct is_const<const std::input_iterator_tag> : public std::true_type {
    };
    template <typename> struct __is_void_helper : public std::false_type {
    };
template<> struct __is_void_helper<char> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t> : public std::false_type {
    };
template<> struct __is_void_helper<char16_t> : public std::false_type {
    };
template<> struct __is_void_helper<char32_t> : public std::false_type {
    };
template<> struct __is_void_helper<const unsigned int &> : public std::false_type {
    };
template<> struct __is_void_helper<const char *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const char &> : public std::false_type {
    };
template<> struct __is_void_helper<std::allocator<char>> : public std::false_type {
    };
template<> struct __is_void_helper<const int &> : public std::false_type {
    };
template<> struct __is_void_helper<bool> : public std::false_type {
    };
template<> struct __is_void_helper<unsigned long> : public std::false_type {
    };
template<> struct __is_void_helper<const bool &> : public std::false_type {
    };
template<> struct __is_void_helper<const unsigned long &> : public std::false_type {
    };
template<> struct __is_void_helper<bool &&> : public std::false_type {
    };
template<> struct __is_void_helper<unsigned long &&> : public std::false_type {
    };
template<> struct __is_void_helper<int &&> : public std::false_type {
    };
template<> struct __is_void_helper<int> : public std::false_type {
    };
template<> struct __is_void_helper<std::random_access_iterator_tag> : public std::false_type {
    };
template<> struct __is_void_helper<char *const &> : public std::false_type {
    };
template<> struct __is_void_helper<char *const *> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const std::__cxx11::basic_string<char> &> : public std::false_type {
    };
template<> struct __is_void_helper<const std::__cxx11::basic_string<char> *> : public std::false_type {
    };
    template<> struct __is_void_helper<void> : public std::true_type {
    };
    template <typename _Tp> struct is_void : public __is_void_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    };
template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    };
template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    };
template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    };
template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    };
template<> struct is_void<const unsigned int &> : public __is_void_helper<__remove_cv_t<const unsigned int &>>::type {
    };
template<> struct is_void<const char *const &> : public __is_void_helper<__remove_cv_t<const char *const &>>::type {
    };
template<> struct is_void<const char *const *> : public __is_void_helper<__remove_cv_t<const char *const *>>::type {
    };
template<> struct is_void<const wchar_t *const &> : public __is_void_helper<__remove_cv_t<const wchar_t *const &>>::type {
    };
template<> struct is_void<const wchar_t *const *> : public __is_void_helper<__remove_cv_t<const wchar_t *const *>>::type {
    };
template<> struct is_void<const char16_t *const &> : public __is_void_helper<__remove_cv_t<const char16_t *const &>>::type {
    };
template<> struct is_void<const char16_t *const *> : public __is_void_helper<__remove_cv_t<const char16_t *const *>>::type {
    };
template<> struct is_void<const char32_t *const &> : public __is_void_helper<__remove_cv_t<const char32_t *const &>>::type {
    };
template<> struct is_void<const char32_t *const *> : public __is_void_helper<__remove_cv_t<const char32_t *const *>>::type {
    };
template<> struct is_void<const char &> : public __is_void_helper<__remove_cv_t<const char &>>::type {
    };
template<> struct is_void<std::allocator<char>> : public __is_void_helper<__remove_cv_t<allocator<char>>>::type {
    };
template<> struct is_void<const int &> : public __is_void_helper<__remove_cv_t<const int &>>::type {
    };
template<> struct is_void<bool> : public __is_void_helper<__remove_cv_t<bool>>::type {
    };
template<> struct is_void<unsigned long> : public __is_void_helper<__remove_cv_t<unsigned long>>::type {
    };
template<> struct is_void<const bool &> : public __is_void_helper<__remove_cv_t<const bool &>>::type {
    };
template<> struct is_void<const unsigned long &> : public __is_void_helper<__remove_cv_t<const unsigned long &>>::type {
    };
template<> struct is_void<bool &&> : public __is_void_helper<__remove_cv_t<bool &&>>::type {
    };
template<> struct is_void<unsigned long &&> : public __is_void_helper<__remove_cv_t<unsigned long &&>>::type {
    };
template<> struct is_void<int &&> : public __is_void_helper<__remove_cv_t<int &&>>::type {
    };
template<> struct is_void<const int> : public __is_void_helper<__remove_cv_t<const int>>::type {
    };
template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    };
template<> struct is_void<std::random_access_iterator_tag> : public __is_void_helper<__remove_cv_t<random_access_iterator_tag>>::type {
    };
template<> struct is_void<char *const &> : public __is_void_helper<__remove_cv_t<char *const &>>::type {
    };
template<> struct is_void<char *const *> : public __is_void_helper<__remove_cv_t<char *const *>>::type {
    };
template<> struct is_void<wchar_t *const &> : public __is_void_helper<__remove_cv_t<wchar_t *const &>>::type {
    };
template<> struct is_void<wchar_t *const *> : public __is_void_helper<__remove_cv_t<wchar_t *const *>>::type {
    };
template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    };
template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    };
template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    };
template<> struct is_void<const std::__cxx11::basic_string<char> &> : public __is_void_helper<__remove_cv_t<const basic_string<char> &>>::type {
    };
template<> struct is_void<const std::__cxx11::basic_string<char> *> : public __is_void_helper<__remove_cv_t<const basic_string<char> *>>::type {
    };
    template <typename> struct __is_integral_helper : public std::false_type {
    };
    template<> struct __is_integral_helper<bool> : public std::true_type {
    };
    template<> struct __is_integral_helper<char> : public std::true_type {
    };
    template<> struct __is_integral_helper<signed char> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned char> : public std::true_type {
    };
    template<> struct __is_integral_helper<wchar_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char16_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char32_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<short> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned short> : public std::true_type {
    };
    template<> struct __is_integral_helper<int> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned int> : public std::true_type {
    };
    template<> struct __is_integral_helper<long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long> : public std::true_type {
    };
    template<> struct __is_integral_helper<long long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long long> : public std::true_type {
    };
    template <typename _Tp> struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_integral<wchar_t> : public __is_integral_helper<__remove_cv_t<wchar_t>>::type {
    };
template<> struct is_integral<unsigned int> : public __is_integral_helper<__remove_cv_t<unsigned int>>::type {
    };
template<> struct is_integral<char16_t> : public __is_integral_helper<__remove_cv_t<char16_t>>::type {
    };
template<> struct is_integral<unsigned short> : public __is_integral_helper<__remove_cv_t<unsigned short>>::type {
    };
template<> struct is_integral<char32_t> : public __is_integral_helper<__remove_cv_t<char32_t>>::type {
    };
template<> struct is_integral<bool> : public __is_integral_helper<__remove_cv_t<bool>>::type {
    };
template<> struct is_integral<int> : public __is_integral_helper<__remove_cv_t<int>>::type {
    };
template<> struct is_integral<unsigned long> : public __is_integral_helper<__remove_cv_t<unsigned long>>::type {
    };
template<> struct is_integral<unsigned long long> : public __is_integral_helper<__remove_cv_t<unsigned long long>>::type {
    };
    template <typename> struct __is_floating_point_helper : public std::false_type {
    };
    template<> struct __is_floating_point_helper<float> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<double> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<long double> : public std::true_type {
    };
    template <typename _Tp> struct is_floating_point : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct is_array : public std::false_type {
    };
template<> struct is_array<char> : public std::false_type {
    };
template<> struct is_array<wchar_t> : public std::false_type {
    };
template<> struct is_array<char16_t> : public std::false_type {
    };
template<> struct is_array<char32_t> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<char, std::char_traits<char>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<char> *> : public std::false_type {
    };
template<> struct is_array<const char *> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<wchar_t> *> : public std::false_type {
    };
template<> struct is_array<const wchar_t *> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public std::false_type {
    };
template<> struct is_array<const char16_t *> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public std::false_type {
    };
template<> struct is_array<const char32_t *> : public std::false_type {
    };
template<> struct is_array<std::allocator<char>> : public std::false_type {
    };
template<> struct is_array<bool> : public std::false_type {
    };
template<> struct is_array<unsigned long> : public std::false_type {
    };
template<> struct is_array<const int> : public std::false_type {
    };
template<> struct is_array<std::input_iterator_tag> : public std::false_type {
    };
    template <typename _Tp, std::size_t _Size> struct is_array<_Tp [_Size]> : public std::true_type {
    };
    template <typename _Tp> struct is_array<_Tp []> : public std::true_type {
    };
    template <typename> struct __is_pointer_helper : public std::false_type {
    };
    template <typename _Tp> struct __is_pointer_helper<_Tp *> : public std::true_type {
    };
    template <typename _Tp> struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct is_lvalue_reference : public std::false_type {
    };
template<> struct is_lvalue_reference<char> : public std::false_type {
    };
template<> struct is_lvalue_reference<wchar_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char16_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char32_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<std::allocator<char>> : public std::false_type {
    };
template<> struct is_lvalue_reference<std::basic_istream<char> &> : public std::true_type {
    };
template<> struct is_lvalue_reference<std::basic_istream<wchar_t> &> : public std::true_type {
    };
template<> struct is_lvalue_reference<bool> : public std::false_type {
    };
template<> struct is_lvalue_reference<unsigned long> : public std::false_type {
    };
template<> struct is_lvalue_reference<const int> : public std::false_type {
    };
template<> struct is_lvalue_reference<std::basic_ostream<char> &> : public std::true_type {
    };
    template <typename _Tp> struct is_lvalue_reference<_Tp &> : public std::true_type {
    };
    template <typename> struct is_rvalue_reference : public std::false_type {
    };
template<> struct is_rvalue_reference<char> : public std::false_type {
    };
template<> struct is_rvalue_reference<wchar_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char16_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char32_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<std::allocator<char>> : public std::false_type {
    };
template<> struct is_rvalue_reference<bool> : public std::false_type {
    };
template<> struct is_rvalue_reference<unsigned long> : public std::false_type {
    };
template<> struct is_rvalue_reference<const int> : public std::false_type {
    };
    template <typename _Tp> struct is_rvalue_reference<_Tp &&> : public std::true_type {
    };
    template <typename> struct __is_member_object_pointer_helper : public std::false_type {
    };
template<> struct __is_member_object_pointer_helper<std::hash<int>> : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public __not_<is_function<_Tp>>::type {
    };
    template <typename _Tp> struct is_member_object_pointer : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_member_object_pointer<const std::hash<int>> : public __is_member_object_pointer_helper<__remove_cv_t<const hash<int>>>::type {
    };
    template <typename> struct __is_member_function_pointer_helper : public std::false_type {
    };
template<> struct __is_member_function_pointer_helper<std::hash<int>> : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type {
    };
    template <typename _Tp> struct is_member_function_pointer : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_member_function_pointer<const std::hash<int>> : public __is_member_function_pointer_helper<__remove_cv_t<const hash<int>>>::type {
    };
    template <typename _Tp> struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {
    };
template<> struct is_enum<wchar_t> : public integral_constant<bool, __is_enum(wchar_t)> {
    };
template<> struct is_enum<unsigned int> : public integral_constant<bool, __is_enum(unsigned int)> {
    };
template<> struct is_enum<char16_t> : public integral_constant<bool, __is_enum(char16_t)> {
    };
template<> struct is_enum<unsigned short> : public integral_constant<bool, __is_enum(unsigned short)> {
    };
template<> struct is_enum<char32_t> : public integral_constant<bool, __is_enum(char32_t)> {
    };
template<> struct is_enum<int> : public integral_constant<bool, __is_enum(int)> {
    };
    template <typename _Tp> struct is_union : public integral_constant<bool, __is_union(_Tp)> {
    };
    template <typename _Tp> struct is_class : public integral_constant<bool, __is_class(_Tp)> {
    };
    template <typename _Tp> struct is_function : public __bool_constant<!is_const<const _Tp>::value> {
    };
template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    };
template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    };
template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    };
template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    };
template<> struct is_function<std::basic_string_view<char, std::char_traits<char>>> : public __bool_constant<!is_const<const basic_string_view<char, char_traits<char>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<char> *> : public __bool_constant<!is_const<const basic_string<char> *const>::value> {
    };
template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    };
template<> struct is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __bool_constant<!is_const<const basic_string_view<wchar_t, char_traits<wchar_t>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<wchar_t> *> : public __bool_constant<!is_const<const basic_string<wchar_t> *const>::value> {
    };
template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    };
template<> struct is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public __bool_constant<!is_const<const basic_string_view<char16_t, char_traits<char16_t>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public __bool_constant<!is_const<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *const>::value> {
    };
template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    };
template<> struct is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public __bool_constant<!is_const<const basic_string_view<char32_t, char_traits<char32_t>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public __bool_constant<!is_const<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *const>::value> {
    };
template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    };
template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    };
template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    };
template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    };
template<> struct is_function<const int> : public __bool_constant<!is_const<const const int>::value> {
    };
template<> struct is_function<std::input_iterator_tag> : public __bool_constant<!is_const<const input_iterator_tag>::value> {
    };
    template <typename _Tp> struct is_function<_Tp &> : public std::false_type {
    };
    template <typename _Tp> struct is_function<_Tp &&> : public std::false_type {
    };
    template <typename> struct __is_null_pointer_helper : public std::false_type {
    };
    template<> struct __is_null_pointer_helper<std::nullptr_t> : public std::true_type {
    };
    template <typename _Tp> struct is_null_pointer : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct __attribute__((deprecated(""))) __is_nullptr_t : public is_null_pointer<_Tp> {
    };
    template <typename _Tp> struct is_reference : public __or_<is_lvalue_reference<_Tp>, is_rvalue_reference<_Tp>>::type {
    };
template<> struct is_reference<char> : public __or_<is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    };
template<> struct is_reference<wchar_t> : public __or_<is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    };
template<> struct is_reference<char16_t> : public __or_<is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    };
template<> struct is_reference<char32_t> : public __or_<is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    };
template<> struct is_reference<std::allocator<char>> : public __or_<is_lvalue_reference<allocator<char>>, is_rvalue_reference<allocator<char>>>::type {
    };
template<> struct is_reference<bool> : public __or_<is_lvalue_reference<bool>, is_rvalue_reference<bool>>::type {
    };
template<> struct is_reference<unsigned long> : public __or_<is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    };
template<> struct is_reference<const int> : public __or_<is_lvalue_reference<const int>, is_rvalue_reference<const int>>::type {
    };
    template <typename _Tp> struct is_arithmetic : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {
    };
template<> struct is_arithmetic<bool> : public __or_<is_integral<bool>, is_floating_point<bool>>::type {
    };
template<> struct is_arithmetic<int> : public __or_<is_integral<int>, is_floating_point<int>>::type {
    };
template<> struct is_arithmetic<unsigned int> : public __or_<is_integral<unsigned int>, is_floating_point<unsigned int>>::type {
    };
template<> struct is_arithmetic<unsigned long> : public __or_<is_integral<unsigned long>, is_floating_point<unsigned long>>::type {
    };
template<> struct is_arithmetic<unsigned long long> : public __or_<is_integral<unsigned long long>, is_floating_point<unsigned long long>>::type {
    };
    template <typename _Tp> struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template <typename _Tp> struct is_object : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {
    };
    template <typename> struct is_member_pointer;
    template <typename _Tp> struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>, is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template <typename _Tp> struct is_compound : public __not_<is_fundamental<_Tp>>::type {
    };
    template <typename _Tp> struct __is_member_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public std::true_type {
    };
    template <typename _Tp> struct is_member_pointer : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename, typename> struct is_same
template<> struct is_same<std::pair<const int, int>, std::pair<const int, int>> : public integral_constant<bool, __is_same(std::pair<const int, int>, std::pair<const int, int>)> {
    }
template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    }
template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    }
template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    }
template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    }
template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    }
template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    }
template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    }
template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Tp, typename ..._Types> using __is_one_of = __or_<is_same<_Tp, _Types>...>;
    template <typename _Tp> using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>, signed char, short, int, long, long long>;
    template <typename _Tp> using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
    template <typename _Tp> using __is_standard_integer = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;
    template <typename ...> using __void_t = void;
    template <typename _Tp, typename = void> struct __is_referenceable : public std::false_type {
    };
template<> struct __is_referenceable<bool, void> : public std::true_type {
    };
template<> struct __is_referenceable<unsigned long, void> : public std::true_type {
    };
template<> struct __is_referenceable<const int, void> : public std::true_type {
    };
    template <typename _Tp> struct __is_referenceable<_Tp, __void_t<_Tp &>> : public std::true_type {
    };
    template <typename> struct is_const : public std::false_type {
    };
template<> struct is_const<wchar_t> : public std::false_type {
    };
template<> struct is_const<char16_t> : public std::false_type {
    };
template<> struct is_const<char32_t> : public std::false_type {
    };
template<> struct is_const<unsigned int> : public std::false_type {
    };
template<> struct is_const<unsigned short> : public std::false_type {
    };
template<> struct is_const<int> : public std::false_type {
    };
template<> struct is_const<const char> : public std::true_type {
    };
template<> struct is_const<const wchar_t> : public std::true_type {
    };
template<> struct is_const<const char16_t> : public std::true_type {
    };
template<> struct is_const<const char32_t> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<char, std::char_traits<char>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<char> *const> : public std::true_type {
    };
template<> struct is_const<const char *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<wchar_t> *const> : public std::true_type {
    };
template<> struct is_const<const wchar_t *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *const> : public std::true_type {
    };
template<> struct is_const<const char16_t *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *const> : public std::true_type {
    };
template<> struct is_const<const char32_t *const> : public std::true_type {
    };
template<> struct is_const<const std::allocator<char>> : public std::true_type {
    };
template<> struct is_const<const bool> : public std::true_type {
    };
template<> struct is_const<const unsigned long> : public std::true_type {
    };
template<> struct is_const<const int> : public std::true_type {
    };
template<> struct is_const<const std::input_iterator_tag> : public std::true_type {
    };
    template <typename _Tp> struct is_const<const _Tp> : public std::true_type {
    };
    template <typename> struct is_volatile : public std::false_type {
    };
template<> struct is_volatile<wchar_t> : public std::false_type {
    };
template<> struct is_volatile<char16_t> : public std::false_type {
    };
template<> struct is_volatile<char32_t> : public std::false_type {
    };
template<> struct is_volatile<unsigned int> : public std::false_type {
    };
template<> struct is_volatile<unsigned short> : public std::false_type {
    };
template<> struct is_volatile<int> : public std::false_type {
    };
    template <typename _Tp> struct is_volatile<volatile _Tp> : public std::true_type {
    };
    template <typename _Tp> struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char> : public integral_constant<bool, __is_trivial(char)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<wchar_t> : public integral_constant<bool, __is_trivial(wchar_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char16_t> : public integral_constant<bool, __is_trivial(char16_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char32_t> : public integral_constant<bool, __is_trivial(char32_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char> : public integral_constant<bool, __is_standard_layout(char)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<wchar_t> : public integral_constant<bool, __is_standard_layout(wchar_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char16_t> : public integral_constant<bool, __is_standard_layout(char16_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char32_t> : public integral_constant<bool, __is_standard_layout(char32_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_pod : public integral_constant<bool, __is_pod(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {
    };
    template <typename _Tp> struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
    };
    template <typename _Tp> struct is_final : public integral_constant<bool, __is_final(_Tp)> {
    };
    template <typename _Tp> struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {
    };
    template <typename _Tp, bool = is_arithmetic<_Tp>::value> struct __is_signed_helper : public std::false_type {
    };
template<> struct __is_signed_helper<bool, true> : public integral_constant<bool, bool(-1) < bool(0)> {
    };
template<> struct __is_signed_helper<int, true> : public integral_constant<bool, int(-1) < int(0)> {
    };
template<> struct __is_signed_helper<unsigned int, true> : public integral_constant<bool, unsigned int(-1) < unsigned int(0)> {
    };
template<> struct __is_signed_helper<unsigned long, true> : public integral_constant<bool, unsigned long(-1) < unsigned long(0)> {
    };
template<> struct __is_signed_helper<unsigned long long, true> : public integral_constant<bool, unsigned long long(-1) < unsigned long long(0)> {
    };
    template <typename _Tp> struct __is_signed_helper<_Tp, true> : public integral_constant<bool, _Tp(-1) < _Tp(0)> {
    };
    template <typename _Tp> struct is_signed : public __is_signed_helper<_Tp>::type {
    };
template<> struct is_signed<bool> : public __is_signed_helper<bool>::type {
    };
template<> struct is_signed<int> : public __is_signed_helper<int>::type {
    };
template<> struct is_signed<unsigned int> : public __is_signed_helper<unsigned int>::type {
    };
template<> struct is_signed<unsigned long> : public __is_signed_helper<unsigned long>::type {
    };
template<> struct is_signed<unsigned long long> : public __is_signed_helper<unsigned long long>::type {
    };
    template <typename _Tp> struct is_unsigned : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>> {
    };
template<> struct is_unsigned<unsigned int> : public __and_<is_arithmetic<unsigned int>, __not_<is_signed<unsigned int>>> {
    };
template<> struct is_unsigned<unsigned long> : public __and_<is_arithmetic<unsigned long>, __not_<is_signed<unsigned long>>> {
    };
template<> struct is_unsigned<unsigned long long> : public __and_<is_arithmetic<unsigned long long>, __not_<is_signed<unsigned long long>>> {
    };
    template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);
    template<> std::allocator<char> &__declval<std::allocator<char> &, std::allocator<char> &>(int);
    template<> const unsigned int &__declval<const unsigned int &, const unsigned int &>(int);
    template<> std::allocator<wchar_t> &__declval<std::allocator<wchar_t> &, std::allocator<wchar_t> &>(int);
    template<> std::allocator<char16_t> &__declval<std::allocator<char16_t> &, std::allocator<char16_t> &>(int);
    template<> std::allocator<char32_t> &__declval<std::allocator<char32_t> &, std::allocator<char32_t> &>(int);
    template<> const char *const &__declval<const char *const &, const char *const &>(int);
    template<> const char *const *&&__declval<const char *const *, const char *const *&&>(int);
    template<> const wchar_t *const &__declval<const wchar_t *const &, const wchar_t *const &>(int);
    template<> const wchar_t *const *&&__declval<const wchar_t *const *, const wchar_t *const *&&>(int);
    template<> const char16_t *const &__declval<const char16_t *const &, const char16_t *const &>(int);
    template<> const char16_t *const *&&__declval<const char16_t *const *, const char16_t *const *&&>(int);
    template<> const char32_t *const &__declval<const char32_t *const &, const char32_t *const &>(int);
    template<> const char32_t *const *&&__declval<const char32_t *const *, const char32_t *const *&&>(int);
    template<> const char &__declval<const char &, const char &>(int);
    template<> const int &__declval<const int &, const int &>(int);
    template<> std::basic_istream<char> *&&__declval<std::basic_istream<char> *, std::basic_istream<char> *&&>(int);
    template<> std::basic_istream<wchar_t> *&&__declval<std::basic_istream<wchar_t> *, std::basic_istream<wchar_t> *&&>(int);
    template<> const bool &__declval<const bool &, const bool &>(int);
    template<> const unsigned long &__declval<const unsigned long &, const unsigned long &>(int);
    template<> bool &&__declval<bool &&, bool &&>(int);
    template<> unsigned long &&__declval<unsigned long &&, unsigned long &&>(int);
    template<> int &&__declval<int &&, int &&>(int);
    template<> const std::hash<int> &__declval<const std::hash<int> &, const std::hash<int> &>(int);
    template<> const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &__declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &>(int);
    template<> const std::__detail::_Mod_range_hashing &__declval<const std::__detail::_Mod_range_hashing &, const std::__detail::_Mod_range_hashing &>(int);
    template<> const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &__declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &>(int);
    template<> std::basic_ostream<char> *&&__declval<std::basic_ostream<char> *, std::basic_ostream<char> *&&>(int);
    template<> std::random_access_iterator_tag &&__declval<std::random_access_iterator_tag, std::random_access_iterator_tag &&>(int);
    template<> char *const &__declval<char *const &, char *const &>(int);
    template<> char *const *&&__declval<char *const *, char *const *&&>(int);
    template<> wchar_t *const &__declval<wchar_t *const &, wchar_t *const &>(int);
    template<> wchar_t *const *&&__declval<wchar_t *const *, wchar_t *const *&&>(int);
    template<> const std::__cxx11::basic_string<char> &__declval<const std::__cxx11::basic_string<char> &, const std::__cxx11::basic_string<char> &>(int);
    template<> const std::__cxx11::basic_string<char> *&&__declval<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *&&>(int);
    template <typename _Tp> _Tp __declval(long);
    template<> std::allocator<char> &__declval<std::allocator<char> &>(long);
    template<> const unsigned int &__declval<const unsigned int &>(long);
    template<> std::allocator<wchar_t> &__declval<std::allocator<wchar_t> &>(long);
    template<> std::allocator<char16_t> &__declval<std::allocator<char16_t> &>(long);
    template<> std::allocator<char32_t> &__declval<std::allocator<char32_t> &>(long);
    template<> const char *const &__declval<const char *const &>(long);
    template<> const char *const *__declval<const char *const *>(long);
    template<> const wchar_t *const &__declval<const wchar_t *const &>(long);
    template<> const wchar_t *const *__declval<const wchar_t *const *>(long);
    template<> const char16_t *const &__declval<const char16_t *const &>(long);
    template<> const char16_t *const *__declval<const char16_t *const *>(long);
    template<> const char32_t *const &__declval<const char32_t *const &>(long);
    template<> const char32_t *const *__declval<const char32_t *const *>(long);
    template<> const char &__declval<const char &>(long);
    template<> const int &__declval<const int &>(long);
    template<> std::basic_istream<char> *__declval<std::basic_istream<char> *>(long);
    template<> std::basic_istream<wchar_t> *__declval<std::basic_istream<wchar_t> *>(long);
    template<> const bool &__declval<const bool &>(long);
    template<> const unsigned long &__declval<const unsigned long &>(long);
    template<> bool &&__declval<bool &&>(long);
    template<> unsigned long &&__declval<unsigned long &&>(long);
    template<> int &&__declval<int &&>(long);
    template<> const std::hash<int> &__declval<const std::hash<int> &>(long);
    template<> const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &__declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &>(long);
    template<> const std::__detail::_Mod_range_hashing &__declval<const std::__detail::_Mod_range_hashing &>(long);
    template<> const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &__declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &>(long);
    template<> std::basic_ostream<char> *__declval<std::basic_ostream<char> *>(long);
    template<> std::random_access_iterator_tag __declval<std::random_access_iterator_tag>(long);
    template<> char *const &__declval<char *const &>(long);
    template<> char *const *__declval<char *const *>(long);
    template<> wchar_t *const &__declval<wchar_t *const &>(long);
    template<> wchar_t *const *__declval<wchar_t *const *>(long);
    template<> const std::__cxx11::basic_string<char> &__declval<const std::__cxx11::basic_string<char> &>(long);
    template<> const std::__cxx11::basic_string<char> *__declval<const std::__cxx11::basic_string<char> *>(long);
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0));
    template <typename, unsigned int = 0> struct extent;
    template <typename> struct remove_all_extents;
    template <typename _Tp> struct __is_array_known_bounds : public integral_constant<bool, (extent<_Tp>::value > 0)> {
    };
    template <typename _Tp> struct __is_array_unknown_bounds : public __and_<is_array<_Tp>, __not_<extent<_Tp>>> {
    };
template<> struct __is_array_unknown_bounds<char> : public __and_<is_array<char>, __not_<extent<char>>> {
    };
template<> struct __is_array_unknown_bounds<wchar_t> : public __and_<is_array<wchar_t>, __not_<extent<wchar_t>>> {
    };
template<> struct __is_array_unknown_bounds<char16_t> : public __and_<is_array<char16_t>, __not_<extent<char16_t>>> {
    };
template<> struct __is_array_unknown_bounds<char32_t> : public __and_<is_array<char32_t>, __not_<extent<char32_t>>> {
    };
template<> struct __is_array_unknown_bounds<std::allocator<char>> : public __and_<is_array<std::allocator<char>>, __not_<extent<std::allocator<char>>>> {
    };
template<> struct __is_array_unknown_bounds<bool> : public __and_<is_array<bool>, __not_<extent<bool>>> {
    };
template<> struct __is_array_unknown_bounds<unsigned long> : public __and_<is_array<unsigned long>, __not_<extent<unsigned long>>> {
    };
template<> struct __is_array_unknown_bounds<const int> : public __and_<is_array<const int>, __not_<extent<const int>>> {
    };
    struct __do_is_destructible_impl {
        template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())> static std::true_type __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_destructible_impl : public std::__do_is_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_destructible_safe;
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, false> : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_destructible : public __is_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_nt_destructible_impl {
        template <typename _Tp> static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_nt_destructible_impl : public std::__do_is_nt_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_nt_destructible_safe;
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, false> : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct __is_constructible_impl : public __bool_constant<__is_constructible(_Tp, _Args...)> {
    };
template<> struct __is_constructible_impl<bool, <const bool &>> : public __bool_constant<__is_constructible(bool, const bool &)> {
    };
template<> struct __is_constructible_impl<unsigned long, <const unsigned long &>> : public __bool_constant<__is_constructible(unsigned long, const unsigned long &)> {
    };
template<> struct __is_constructible_impl<bool, <bool &&>> : public __bool_constant<__is_constructible(bool, bool &&)> {
    };
template<> struct __is_constructible_impl<unsigned long, <const unsigned long &&>> : public __bool_constant<__is_constructible(unsigned long, const unsigned long &&)> {
    };
template<> struct __is_constructible_impl<unsigned long, <unsigned long &&>> : public __bool_constant<__is_constructible(unsigned long, unsigned long &&)> {
    };
template<> struct __is_constructible_impl<unsigned long, <int &&>> : public __bool_constant<__is_constructible(unsigned long, int &&)> {
    };
    template <typename _Tp, typename ..._Args> struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<bool, <const bool &>> : public __is_constructible_impl<bool, const bool &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<bool>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <const unsigned long &>> : public __is_constructible_impl<unsigned long, const unsigned long &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<bool, <bool &&>> : public __is_constructible_impl<bool, bool &&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<bool>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <const unsigned long &&>> : public __is_constructible_impl<unsigned long, const unsigned long &&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <unsigned long &&>> : public __is_constructible_impl<unsigned long, unsigned long &&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <int &&>> : public __is_constructible_impl<unsigned long, int &&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_default_constructible : public __is_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_constructible_impl;
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_copy_constructible : public __is_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_constructible_impl;
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_move_constructible : public __is_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <bool, typename _Tp, typename ..._Args> struct __is_nt_constructible_impl : public std::false_type {
    };
template<> struct __is_nt_constructible_impl<true, std::allocator<char>, <>> : public __bool_constant<noexcept(std::allocator<char>())> {
    };
    template <typename _Tp, typename ..._Args> struct __is_nt_constructible_impl<true, _Tp, _Args...> : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))> {
    };
    template <typename _Tp, typename _Arg> struct __is_nt_constructible_impl<true, _Tp, _Arg> : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))> {
    };
    template <typename _Tp> struct __is_nt_constructible_impl<true, _Tp> : public __bool_constant<noexcept(_Tp())> {
    };
    template <typename _Tp, std::size_t _Num> struct __is_nt_constructible_impl<true, _Tp [_Num]> : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())> {
    };
    template <typename _Tp, typename ..._Args> using __is_nothrow_constructible_impl = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...), _Tp, _Args...>;
    template <typename _Tp, typename ..._Args> struct is_nothrow_constructible : public __is_nothrow_constructible_impl<_Tp, _Args...>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_default_constructible : public __is_nothrow_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_default_constructible<std::allocator<char>> : public __is_nothrow_constructible_impl<allocator<char>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<std::allocator<char>>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_copy_constructible_impl;
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_constructible : public __is_nothrow_copy_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_move_constructible_impl;
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_constructible : public __is_nothrow_move_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_assignable : public __bool_constant<__is_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_assignable_impl
template<> struct __is_copy_assignable_impl<bool, true> : public __bool_constant<__is_assignable(bool &, const bool &)> {
    }
template<> struct __is_copy_assignable_impl<unsigned long, true> : public __bool_constant<__is_assignable(unsigned long &, const unsigned long &)> {
    }
template<> struct __is_copy_assignable_impl<const int, true> : public __bool_constant<__is_assignable(const int &, const int &)> {
    };
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_copy_assignable : public __is_copy_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<bool> : public __is_copy_assignable_impl<bool>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<bool>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<unsigned long> : public __is_copy_assignable_impl<unsigned long>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<const int> : public __is_copy_assignable_impl<const int>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const int>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_assignable_impl
template<> struct __is_move_assignable_impl<bool, true> : public __bool_constant<__is_assignable(bool &, bool &&)> {
    }
template<> struct __is_move_assignable_impl<unsigned long, true> : public __bool_constant<__is_assignable(unsigned long &, unsigned long &&)> {
    }
template<> struct __is_move_assignable_impl<const int, true> : public __bool_constant<__is_assignable(const int &, const int &&)> {
    };
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_move_assignable : public __is_move_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_move_assignable<bool> : public __is_move_assignable_impl<bool>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<bool>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_move_assignable<unsigned long> : public __is_move_assignable_impl<unsigned long>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_move_assignable<const int> : public __is_move_assignable_impl<const int>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const int>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct __is_nt_assignable_impl : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())> {
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_assignable_impl : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>, __is_nt_assignable_impl<_Tp, _Up>> {
    };
    template <typename _Tp, typename _Up> struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_copy_assignable_impl;
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_move_assignable_impl;
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct is_trivially_constructible : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_default_constructible : public __bool_constant<__is_trivially_constructible(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_implicitly_default_constructible_impl {
        template <typename _Tp> static void __helper(const _Tp &);
        template <typename _Tp> static std::true_type __test(const _Tp &, decltype(__helper<const _Tp &>({})) * = 0);
        static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_impl : public std::__do_is_implicitly_default_constructible_impl {
        typedef decltype(__test(declval<_Tp>())) type;
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_implicitly_default_constructible : public __and_<__is_constructible_impl<_Tp>, __is_implicitly_default_constructible_safe<_Tp>> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_constructible_impl;
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, true> : public __and_<__is_copy_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp &)>> {
    };
    template <typename _Tp> struct is_trivially_copy_constructible : public __is_trivially_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_constructible_impl;
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, true> : public __and_<__is_move_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, _Tp &&)>> {
    };
    template <typename _Tp> struct is_trivially_move_constructible : public __is_trivially_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_trivially_assignable : public __bool_constant<__is_trivially_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_assignable_impl;
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_trivially_copy_assignable : public __is_trivially_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_assignable_impl;
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_trivially_move_assignable : public __is_trivially_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_destructible : public __and_<__is_destructible_safe<_Tp>, __bool_constant<__has_trivial_destructor(_Tp)>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename> struct rank : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, std::size_t _Size> struct rank<_Tp [_Size]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename _Tp> struct rank<_Tp []> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename, unsigned int _Uint = 0> struct extent : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, unsigned int _Uint, std::size_t _Size> struct extent<_Tp [_Size], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, unsigned int _Uint> struct extent<_Tp [], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, typename _Up> struct is_same : public integral_constant<bool, __is_same(_Tp, _Up)> {
    };
template<> struct is_same<std::pair<const int, int>, std::pair<const int, int>> : public integral_constant<bool, __is_same(std::pair<const int, int>, std::pair<const int, int>)> {
    };
template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    };
template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    };
template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    };
template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    };
template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    };
template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    };
template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    };
template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Base, typename _Derived> struct is_base_of : public integral_constant<bool, __is_base_of(_Base, _Derived)> {
    };
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_convertible_helper {
        typedef typename is_void<_To>::type type;
    };
template<> class __is_convertible_helper<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const char *const &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char, std::char_traits<char>>>(std::basic_string_view<char, std::char_traits<char>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const &, std::basic_string_view<char, std::char_traits<char>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const char *const &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const char *const *, const std::__cxx11::basic_string<char> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const *, const std::__cxx11::basic_string<char> *>(...);
    public:
        typedef decltype(__test<const char *const *, const std::__cxx11::basic_string<char> *>(0)) type;
    };
template<> class __is_convertible_helper<const char *const &, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const &, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const &, const char *>(...);
    public:
        typedef decltype(__test<const char *const &, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(std::basic_string_view<wchar_t, std::char_traits<wchar_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(...);
    public:
        typedef decltype(__test<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>(...);
    public:
        typedef decltype(__test<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const &, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const &, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const &, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *const &, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char16_t, std::char_traits<char16_t>>>(std::basic_string_view<char16_t, std::char_traits<char16_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>(...);
    public:
        typedef decltype(__test<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>(...);
    public:
        typedef decltype(__test<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const &, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const &, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const &, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *const &, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char32_t, std::char_traits<char32_t>>>(std::basic_string_view<char32_t, std::char_traits<char32_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>(...);
    public:
        typedef decltype(__test<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>(...);
    public:
        typedef decltype(__test<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const &, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const &, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const &, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *const &, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const char &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const int &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const int &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const int &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const bool &, bool, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<bool>(bool) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const bool &, bool, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const bool &, bool>(...);
    public:
        typedef decltype(__test<const bool &, bool>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned long &, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const unsigned long &, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned long &, unsigned long>(...);
    public:
        typedef decltype(__test<const unsigned long &, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<bool &&, bool, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<bool>(bool) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<bool &&, bool, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<bool &&, bool>(...);
    public:
        typedef decltype(__test<bool &&, bool>(0)) type;
    };
template<> class __is_convertible_helper<unsigned long &&, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<unsigned long &&, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<unsigned long &&, unsigned long>(...);
    public:
        typedef decltype(__test<unsigned long &&, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<int &&, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<int &&, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<int &&, unsigned long>(...);
    public:
        typedef decltype(__test<int &&, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<std::random_access_iterator_tag, std::input_iterator_tag, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::input_iterator_tag>(std::input_iterator_tag) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<std::random_access_iterator_tag, std::input_iterator_tag, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<std::random_access_iterator_tag, std::input_iterator_tag>(...);
    public:
        typedef decltype(__test<std::random_access_iterator_tag, std::input_iterator_tag>(0)) type;
    };
template<> class __is_convertible_helper<char *const &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char, std::char_traits<char>>>(std::basic_string_view<char, std::char_traits<char>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char *const &, std::basic_string_view<char, std::char_traits<char>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *const &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<char *const &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<char *const *, const std::__cxx11::basic_string<char> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *const *, const std::__cxx11::basic_string<char> *>(...);
    public:
        typedef decltype(__test<char *const *, const std::__cxx11::basic_string<char> *>(0)) type;
    };
template<> class __is_convertible_helper<char *const &, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char *const &, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *const &, const char *>(...);
    public:
        typedef decltype(__test<char *const &, const char *>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(std::basic_string_view<wchar_t, std::char_traits<wchar_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(...);
    public:
        typedef decltype(__test<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>(...);
    public:
        typedef decltype(__test<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t *const &, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<wchar_t *const &, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t *const &, const wchar_t *>(...);
    public:
        typedef decltype(__test<wchar_t *const &, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char, std::char_traits<char>>>(std::basic_string_view<char, std::char_traits<char>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const std::__cxx11::basic_string<char> *>(const std::__cxx11::basic_string<char> *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>(...);
    public:
        typedef decltype(__test<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>(0)) type;
    };
    template <typename _From, typename _To> class __is_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        typedef decltype(__test<_From, _To>(0)) type;
    };
    template <typename _From, typename _To> struct is_convertible : public __is_convertible_helper<_From, _To>::type {
    };
template<> struct is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const unsigned int &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const char *const &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const char *const &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const char *const *, const std::__cxx11::basic_string<char> *> : public __is_convertible_helper<const char *const *, const basic_string<char> *>::type {
    };
template<> struct is_convertible<const char *const &, const char *> : public __is_convertible_helper<const char *const &, const char *>::type {
    };
template<> struct is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __is_convertible_helper<const wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::type {
    };
template<> struct is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *> : public __is_convertible_helper<const wchar_t *const *, const basic_string<wchar_t> *>::type {
    };
template<> struct is_convertible<const wchar_t *const &, const wchar_t *> : public __is_convertible_helper<const wchar_t *const &, const wchar_t *>::type {
    };
template<> struct is_convertible<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public __is_convertible_helper<const char16_t *const &, basic_string_view<char16_t, char_traits<char16_t>>>::type {
    };
template<> struct is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public __is_convertible_helper<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>::type {
    };
template<> struct is_convertible<const char16_t *const &, const char16_t *> : public __is_convertible_helper<const char16_t *const &, const char16_t *>::type {
    };
template<> struct is_convertible<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public __is_convertible_helper<const char32_t *const &, basic_string_view<char32_t, char_traits<char32_t>>>::type {
    };
template<> struct is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public __is_convertible_helper<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>::type {
    };
template<> struct is_convertible<const char32_t *const &, const char32_t *> : public __is_convertible_helper<const char32_t *const &, const char32_t *>::type {
    };
template<> struct is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const char &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const int &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const bool &, bool> : public __is_convertible_helper<const bool &, bool>::type {
    };
template<> struct is_convertible<const unsigned long &, unsigned long> : public __is_convertible_helper<const unsigned long &, unsigned long>::type {
    };
template<> struct is_convertible<bool &&, bool> : public __is_convertible_helper<bool &&, bool>::type {
    };
template<> struct is_convertible<unsigned long &&, unsigned long> : public __is_convertible_helper<unsigned long &&, unsigned long>::type {
    };
template<> struct is_convertible<int &&, unsigned long> : public __is_convertible_helper<int &&, unsigned long>::type {
    };
template<> struct is_convertible<std::random_access_iterator_tag, std::input_iterator_tag> : public __is_convertible_helper<random_access_iterator_tag, input_iterator_tag>::type {
    };
template<> struct is_convertible<char *const &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<char *const &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<char *const *, const std::__cxx11::basic_string<char> *> : public __is_convertible_helper<char *const *, const basic_string<char> *>::type {
    };
template<> struct is_convertible<char *const &, const char *> : public __is_convertible_helper<char *const &, const char *>::type {
    };
template<> struct is_convertible<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __is_convertible_helper<wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::type {
    };
template<> struct is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *> : public __is_convertible_helper<wchar_t *const *, const basic_string<wchar_t> *>::type {
    };
template<> struct is_convertible<wchar_t *const &, const wchar_t *> : public __is_convertible_helper<wchar_t *const &, const wchar_t *>::type {
    };
template<> struct is_convertible<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const basic_string<char> &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *> : public __is_convertible_helper<const basic_string<char> *, const basic_string<char> *>::type {
    };
    template <typename _ToElementType, typename _FromElementType> using __is_array_convertible = is_convertible<_FromElementType (*)[], _ToElementType (*)[]>;
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_nt_convertible_helper : is_void<_To> {
    };
    template <typename _From, typename _To> class __is_nt_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1> static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))> __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        using type = decltype(__test<_From, _To>(0));
    };
    template <typename _From, typename _To> struct __is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {
    };
    template <typename _Tp> struct remove_const {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_const<const _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile<volatile _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_cv {
        using type = _Tp;
    };
template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    };
template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    };
template<> struct remove_cv<char16_t> {
        using type = char16_t;
    };
template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    };
template<> struct remove_cv<char32_t> {
        using type = char32_t;
    };
template<> struct remove_cv<void> {
        using type = void;
    };
template<> struct remove_cv<bool> {
        using type = bool;
    };
template<> struct remove_cv<int> {
        using type = int;
    };
template<> struct remove_cv<char> {
        using type = char;
    };
template<> struct remove_cv<const unsigned int &> {
        using type = const unsigned int &;
    };
template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    };
template<> struct remove_cv<unsigned long long> {
        using type = unsigned long long;
    };
template<> struct remove_cv<const char *const &> {
        using type = const char *const &;
    };
template<> struct remove_cv<const char *const *> {
        using type = const char *const *;
    };
template<> struct remove_cv<const wchar_t *const &> {
        using type = const wchar_t *const &;
    };
template<> struct remove_cv<const wchar_t *const *> {
        using type = const wchar_t *const *;
    };
template<> struct remove_cv<const char16_t *const &> {
        using type = const char16_t *const &;
    };
template<> struct remove_cv<const char16_t *const *> {
        using type = const char16_t *const *;
    };
template<> struct remove_cv<const char32_t *const &> {
        using type = const char32_t *const &;
    };
template<> struct remove_cv<const char32_t *const *> {
        using type = const char32_t *const *;
    };
template<> struct remove_cv<const char &> {
        using type = const char &;
    };
template<> struct remove_cv<std::allocator<char>> {
        using type = std::allocator<char>;
    };
template<> struct remove_cv<const int &> {
        using type = const int &;
    };
template<> struct remove_cv<const bool &> {
        using type = const bool &;
    };
template<> struct remove_cv<const unsigned long &> {
        using type = const unsigned long &;
    };
template<> struct remove_cv<bool &&> {
        using type = bool &&;
    };
template<> struct remove_cv<unsigned long &&> {
        using type = unsigned long &&;
    };
template<> struct remove_cv<int &&> {
        using type = int &&;
    };
template<> struct remove_cv<const std::hash<int>> {
        using type = std::hash<int>;
    };
template<> struct remove_cv<const int> {
        using type = int;
    };
template<> struct remove_cv<std::pair<const int, int>> {
        using type = std::pair<const int, int>;
    };
template<> struct remove_cv<const char> {
        using type = char;
    };
template<> struct remove_cv<std::random_access_iterator_tag> {
        using type = std::random_access_iterator_tag;
    };
template<> struct remove_cv<char *const &> {
        using type = char *const &;
    };
template<> struct remove_cv<char *const *> {
        using type = char *const *;
    };
template<> struct remove_cv<wchar_t *const &> {
        using type = wchar_t *const &;
    };
template<> struct remove_cv<wchar_t *const *> {
        using type = wchar_t *const *;
    };
template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    };
template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    };
template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    };
template<> struct remove_cv<const std::__cxx11::basic_string<char> &> {
        using type = const std::__cxx11::basic_string<char> &;
    };
template<> struct remove_cv<const std::__cxx11::basic_string<char> *> {
        using type = const std::__cxx11::basic_string<char> *;
    };
    template <typename _Tp> struct remove_cv<const _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<const volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct add_const {
        typedef const _Tp type;
    };
    template <typename _Tp> struct add_volatile {
        typedef volatile _Tp type;
    };
    template <typename _Tp> struct add_cv {
        typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
    };
    template <typename _Tp> using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;
    template <typename _Tp> struct remove_reference {
        typedef _Tp type;
    };
template<> struct remove_reference<std::basic_istream<char> &> {
        typedef std::basic_istream<char> type;
    };
template<> struct remove_reference<std::basic_istream<wchar_t> &> {
        typedef std::basic_istream<wchar_t> type;
    };
template<> struct remove_reference<bool> {
        typedef bool type;
    };
template<> struct remove_reference<unsigned long> {
        typedef unsigned long type;
    };
template<> struct remove_reference<int> {
        typedef int type;
    };
template<> struct remove_reference<const std::hash<int> &> {
        typedef const std::hash<int> type;
    };
template<> struct remove_reference<std::basic_ostream<char> &> {
        typedef std::basic_ostream<char> type;
    };
template<> struct remove_reference<std::allocator<char> &> {
        typedef std::allocator<char> type;
    };
template<> struct remove_reference<std::__cxx11::basic_string<char> &> {
        typedef std::__cxx11::basic_string<char> type;
    };
    template <typename _Tp> struct remove_reference<_Tp &> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_reference<_Tp &&> {
        typedef _Tp type;
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_lvalue_reference_helper<_Tp, true> {
        typedef _Tp &type;
    };
    template <typename _Tp> struct add_lvalue_reference : public __add_lvalue_reference_helper<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_rvalue_reference_helper<_Tp, true> {
        typedef _Tp &&type;
    };
    template <typename _Tp> struct add_rvalue_reference : public __add_rvalue_reference_helper<_Tp> {
    };
    template <typename _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
    template <typename _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
    template <typename _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
    template <typename _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector
template<> struct __cv_selector<unsigned int, false, false> {
        typedef unsigned int __type;
    }
template<> struct __cv_selector<unsigned short, false, false> {
        typedef unsigned short __type;
    }
template<> struct __cv_selector<int, false, false> {
        typedef int __type;
    }
template<> struct __cv_selector<short, false, false> {
        typedef short __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, false> {
        typedef _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, true> {
        typedef volatile _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, false> {
        typedef const _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, true> {
        typedef const volatile _Unqualified __type;
    };
    template <typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value> class __match_cv_qualifiers {
        typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<wchar_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char16_t, unsigned short, false, false> {
        typedef __cv_selector<unsigned short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char32_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned int, int, false, false> {
        typedef __cv_selector<int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned short, short, false, false> {
        typedef __cv_selector<short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<int, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template <typename _Tp> struct __make_unsigned {
        typedef _Tp __type;
    };
    template<> struct __make_unsigned<char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<signed char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<short> {
        typedef unsigned short __type;
    };
    template<> struct __make_unsigned<int> {
        typedef unsigned int __type;
    };
    template<> struct __make_unsigned<long> {
        typedef unsigned long __type;
    };
    template<> struct __make_unsigned<long long> {
        typedef unsigned long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_unsigned_selector
template<> class __make_unsigned_selector<wchar_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(wchar_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char16_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char32_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<wchar_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<wchar_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char16_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char32_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<int, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<int>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<int, __unsigned_type>::__type;
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    class __make_unsigned_selector_base {
    protected:
        template <typename ...> struct _List {
        };
template<> struct _List<<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned short, unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned char);
        };
template<> struct _List<<unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned short);
        };
template<> struct _List<<unsigned int, unsigned long, unsigned long long>> : _List<unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned int);
        };
template<> struct _List<<unsigned long, unsigned long long>> : _List<unsigned long long> {
            static constexpr std::size_t __size;
        };
template<> struct _List<<unsigned long long>> : _List<> {
            static constexpr std::size_t __size;
        };
template<> struct _List<<>> {
        };
        template <typename _Tp, typename ..._Up> struct _List<_Tp, _Up...> : _List<_Up...> {
            static constexpr std::size_t __size = sizeof(_Tp);
        };
        template <std::size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)> struct __select
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned int;
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned short;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, true> {
            using __type = _Uint;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, false> : __select<_Sz, _List<_UInts...>> {
        };
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    template<> struct __make_unsigned<wchar_t> {
        using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char16_t> {
        using __type = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char32_t> {
        using __type = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_unsigned {
        typedef typename __make_unsigned_selector<_Tp>::__type type;
    };
template<> struct make_unsigned<int> {
        typedef typename __make_unsigned_selector<int>::__type type;
    };
    template<> struct make_unsigned<bool>;
    template <typename _Tp> struct __make_signed {
        typedef _Tp __type;
    };
    template<> struct __make_signed<char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned short> {
        typedef short __type;
    };
    template<> struct __make_signed<unsigned int> {
        typedef int __type;
    };
    template<> struct __make_signed<unsigned long> {
        typedef long __type;
    };
    template<> struct __make_signed<unsigned long long> {
        typedef long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_signed_selector
template<> class __make_signed_selector<wchar_t, false, true> {
        typedef typename __make_unsigned_selector<wchar_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned int, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned int>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned int, __signed_type>::__type;
    }
template<> class __make_signed_selector<char16_t, false, true> {
        typedef typename __make_unsigned_selector<char16_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned short, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned short>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned short, __signed_type>::__type;
    }
template<> class __make_signed_selector<char32_t, false, true> {
        typedef typename __make_unsigned_selector<char32_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
        typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template<> struct __make_signed<wchar_t> {
        using __type = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_signed<char16_t> {
        using __type = typename __make_signed_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_signed<char32_t> {
        using __type = typename __make_signed_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_signed {
        typedef typename __make_signed_selector<_Tp>::__type type;
    };
    template<> struct make_signed<bool>;
    template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;
    template <typename _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
    template <typename _Tp> struct remove_extent {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp [_Size]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_extent<_Tp []> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_all_extents {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_all_extents<_Tp [_Size]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> struct remove_all_extents<_Tp []> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
    template <typename _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
    template <typename _Tp, typename> struct __remove_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp, typename _Up> struct __remove_pointer_helper<_Tp, _Up *> {
        typedef _Up type;
    };
    template <typename _Tp> struct remove_pointer : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {
    };
    template <typename _Tp, bool = __or_<__is_referenceable<_Tp>, is_void<_Tp>>::value> struct __add_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_pointer_helper<_Tp, true> {
        typedef typename remove_reference<_Tp>::type *type;
    };
    template <typename _Tp> struct add_pointer : public __add_pointer_helper<_Tp> {
    };
    template <typename _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
    template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
    template <std::size_t _Len> struct __aligned_storage_msa {
        union __type {
            unsigned char __data[_Len];
            struct __attribute__((aligned)) {
            } __align;
        };
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> struct aligned_storage {
        union type {
            unsigned char __data[_Len];
            struct __attribute__((aligned((_Align)))) {
            } __align;
        };
    };
template<> struct aligned_storage<8, 4> {
        union type {
            unsigned char __data[8];
            struct __attribute__((aligned((4UL)))) {
            };
            struct (anonymous struct at /usr/bin/../lib/gcc/x86_64-pc-linux-gnu/10.1.0/../../../../include/c++/10.1.0/type_traits:2074:2) __align;
        };
    };
    template <typename ..._Types> struct __strictest_alignment {
        static const std::size_t _S_alignment = 0;
        static const std::size_t _S_size = 0;
    };
    template <typename _Tp, typename ..._Types> struct __strictest_alignment<_Tp, _Types...> {
        static const std::size_t _S_alignment = alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
        static const std::size_t _S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
    template <std::size_t _Len, typename ..._Types> struct aligned_union {
    private:
        static_assert(sizeof...(_Types) != 0, "At least one type is required");
        using __strictest = __strictest_alignment<_Types...>;
        static const std::size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;
    public:
        static const std::size_t alignment_value = __strictest::_S_alignment;
        typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };
    const std::size_t alignment_value;
    template <typename _Up, bool _IsArray = is_array<_Up>::value, bool _IsFunction = is_function<_Up>::value> struct __decay_selector;
    template <typename _Up> struct __decay_selector<_Up, false, false> {
        typedef __remove_cv_t<_Up> __type;
    };
    template <typename _Up> struct __decay_selector<_Up, true, false> {
        typedef typename remove_extent<_Up>::type *__type;
    };
    template <typename _Up> struct __decay_selector<_Up, false, true> {
        typedef typename add_pointer<_Up>::type __type;
    };
    template <typename _Tp> class decay {
        typedef typename remove_reference<_Tp>::type __remove_type;
    public:
        typedef typename __decay_selector<__remove_type>::__type type;
    };
    template <typename _Tp> using __decay_t = typename decay<_Tp>::type;
    template <typename _Tp> class reference_wrapper;
    template <typename _Tp> struct __strip_reference_wrapper {
        typedef _Tp __type;
    };
    template <typename _Tp> struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
        typedef _Tp &__type;
    };
    template <typename _Tp> using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;
    template <bool, typename _Tp = void> struct enable_if {
    };
template<> struct enable_if<true, std::allocator<char>> {
        typedef std::allocator<char> type;
    };
template<> struct enable_if<false, void> {
    };
template<> struct enable_if<true, std::allocator<wchar_t>> {
        typedef std::allocator<wchar_t> type;
    };
template<> struct enable_if<true, std::allocator<char16_t>> {
        typedef std::allocator<char16_t> type;
    };
template<> struct enable_if<true, std::allocator<char32_t>> {
        typedef std::allocator<char32_t> type;
    };
template<> struct enable_if<false, std::error_code &> {
    };
template<> struct enable_if<true, void> {
        typedef void type;
    };
template<> struct enable_if<false, std::__cxx11::basic_string<char> &> {
    };
template<> struct enable_if<false, std::basic_istream<char> &> {
    };
template<> struct enable_if<false, std::basic_istream<wchar_t> &> {
    };
template<> struct enable_if<true, bool> {
        typedef bool type;
    };
template<> struct enable_if<false, bool> {
    };
template<> struct enable_if<false, std::basic_ostream<char> &> {
    };
    template <typename _Tp> struct enable_if<true, _Tp> {
        typedef _Tp type;
    };
    template <bool _Cond, typename _Tp = void> using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <typename ..._Cond> using _Require = __enable_if_t<__and_<_Cond...>::value>;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> struct conditional {
        typedef _Iftrue type;
    };
template<> struct conditional<true, std::is_integral<bool>, std::is_floating_point<bool>> {
        typedef std::is_integral<bool> type;
    };
template<> struct conditional<true, std::is_integral<int>, std::is_floating_point<int>> {
        typedef std::is_integral<int> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char>, std::is_rvalue_reference<char>> {
        typedef std::is_rvalue_reference<char> type;
    };
template<> struct conditional<false, std::is_reference<char>, std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    };
template<> struct conditional<false, std::is_function<char>, std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    };
template<> struct conditional<false, std::is_void<char>, std::__is_array_unknown_bounds<char>> {
        typedef std::__is_array_unknown_bounds<char> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char, 0>>, std::is_array<char>> {
        typedef std::is_array<char> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>> {
        typedef std::is_rvalue_reference<wchar_t> type;
    };
template<> struct conditional<false, std::is_reference<wchar_t>, std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    };
template<> struct conditional<false, std::is_function<wchar_t>, std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    };
template<> struct conditional<false, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> {
        typedef std::__is_array_unknown_bounds<wchar_t> type;
    };
template<> struct conditional<false, std::__not_<std::extent<wchar_t, 0>>, std::is_array<wchar_t>> {
        typedef std::is_array<wchar_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>> {
        typedef std::is_rvalue_reference<char16_t> type;
    };
template<> struct conditional<false, std::is_reference<char16_t>, std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    };
template<> struct conditional<false, std::is_function<char16_t>, std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    };
template<> struct conditional<false, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> {
        typedef std::__is_array_unknown_bounds<char16_t> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char16_t, 0>>, std::is_array<char16_t>> {
        typedef std::is_array<char16_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>> {
        typedef std::is_rvalue_reference<char32_t> type;
    };
template<> struct conditional<false, std::is_reference<char32_t>, std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    };
template<> struct conditional<false, std::is_function<char32_t>, std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    };
template<> struct conditional<false, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> {
        typedef std::__is_array_unknown_bounds<char32_t> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char32_t, 0>>, std::is_array<char32_t>> {
        typedef std::is_array<char32_t> type;
    };
template<> struct conditional<true, std::is_integral<unsigned int>, std::is_floating_point<unsigned int>> {
        typedef std::is_integral<unsigned int> type;
    };
template<> struct conditional<true, std::__not_<std::is_signed<unsigned int>>, std::is_arithmetic<unsigned int>> {
        typedef std::__not_<std::is_signed<unsigned int>> type;
    };
template<> struct conditional<false, std::is_void<const unsigned int &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    };
template<> struct conditional<false, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_array<std::basic_string_view<char, std::char_traits<char>>> type;
    };
template<> struct conditional<false, std::__and_<std::__not_<std::is_convertible<const unsigned int *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>, std::is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>> type;
    };
template<> struct conditional<true, std::is_integral<unsigned long>, std::is_floating_point<unsigned long>> {
        typedef std::is_integral<unsigned long> type;
    };
template<> struct conditional<true, std::__not_<std::is_signed<unsigned long>>, std::is_arithmetic<unsigned long>> {
        typedef std::__not_<std::is_signed<unsigned long>> type;
    };
template<> struct conditional<true, std::is_integral<unsigned long long>, std::is_floating_point<unsigned long long>> {
        typedef std::is_integral<unsigned long long> type;
    };
template<> struct conditional<true, std::__not_<std::is_signed<unsigned long long>>, std::is_arithmetic<unsigned long long>> {
        typedef std::__not_<std::is_signed<unsigned long long>> type;
    };
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    };
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>, std::is_convertible<const char *const &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>> type;
    };
template<> struct conditional<false, std::is_void<const char *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> type;
    };
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<char> *> type;
    };
template<> struct conditional<true, std::__not_<std::is_convertible<const char *const &, const char *>>, std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char> *>>> {
        typedef std::__not_<std::is_convertible<const char *const &, const char *>> type;
    };
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    };
template<> struct conditional<false, std::is_function<const char *>, std::is_array<const char *>> {
        typedef std::is_array<const char *> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> type;
    };
template<> struct conditional<false, std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
        typedef std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> type;
    };
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>, std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>> type;
    };
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<wchar_t> *> type;
    };
template<> struct conditional<true, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> {
        typedef std::is_array<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>> type;
    };
template<> struct conditional<false, std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>> {
        typedef std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>> type;
    };
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>, std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>> type;
    };
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> type;
    };
template<> struct conditional<true, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>, std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> {
        typedef std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char16_t *>, std::is_array<const char16_t *>> {
        typedef std::is_array<const char16_t *> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>> type;
    };
template<> struct conditional<false, std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>> {
        typedef std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>> type;
    };
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>, std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>> type;
    };
template<> struct conditional<false, std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>> {
        typedef std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> type;
    };
template<> struct conditional<true, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>, std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> {
        typedef std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char32_t *>, std::is_array<const char32_t *>> {
        typedef std::is_array<const char32_t *> type;
    };
template<> struct conditional<false, std::is_void<const char &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    };
template<> struct conditional<false, std::__and_<std::__not_<std::is_convertible<const char *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const char &, const char *>>>, std::is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<std::allocator<char>>, std::is_rvalue_reference<std::allocator<char>>> {
        typedef std::is_rvalue_reference<std::allocator<char>> type;
    };
template<> struct conditional<false, std::is_reference<std::allocator<char>>, std::__or_<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
        typedef std::__or_<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> type;
    };
template<> struct conditional<false, std::is_function<std::allocator<char>>, std::__or_<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
        typedef std::__or_<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> type;
    };
template<> struct conditional<false, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> {
        typedef std::__is_array_unknown_bounds<std::allocator<char>> type;
    };
template<> struct conditional<false, std::__not_<std::extent<std::allocator<char>, 0>>, std::is_array<std::allocator<char>>> {
        typedef std::is_array<std::allocator<char>> type;
    };
template<> struct conditional<false, std::is_void<const int &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    };
template<> struct conditional<false, std::__and_<std::__not_<std::is_convertible<const int *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const int &, const char *>>>, std::is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>> type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, char &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>> type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, unsigned char &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>> type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, signed char &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &>> type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<wchar_t> &>, std::__is_extractable<std::basic_istream<wchar_t> &, wchar_t &, void>>, std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &>> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<bool>, std::is_rvalue_reference<bool>> {
        typedef std::is_rvalue_reference<bool> type;
    };
template<> struct conditional<false, std::is_reference<bool>, std::__or_<std::is_function<bool>, std::is_void<bool>, std::__is_array_unknown_bounds<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_void<bool>, std::__is_array_unknown_bounds<bool>> type;
    };
template<> struct conditional<false, std::is_function<bool>, std::__or_<std::is_void<bool>, std::__is_array_unknown_bounds<bool>>> {
        typedef std::__or_<std::is_void<bool>, std::__is_array_unknown_bounds<bool>> type;
    };
template<> struct conditional<false, std::is_void<bool>, std::__is_array_unknown_bounds<bool>> {
        typedef std::__is_array_unknown_bounds<bool> type;
    };
template<> struct conditional<false, std::__not_<std::extent<bool, 0>>, std::is_array<bool>> {
        typedef std::is_array<bool> type;
    };
template<> struct conditional<true, std::is_copy_assignable<unsigned long>, std::is_copy_assignable<bool>> {
        typedef std::is_copy_assignable<unsigned long> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>> {
        typedef std::is_rvalue_reference<unsigned long> type;
    };
template<> struct conditional<false, std::is_reference<unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    };
template<> struct conditional<false, std::is_function<unsigned long>, std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    };
template<> struct conditional<false, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> {
        typedef std::__is_array_unknown_bounds<unsigned long> type;
    };
template<> struct conditional<false, std::__not_<std::extent<unsigned long, 0>>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    };
template<> struct conditional<true, const std::pair<bool, unsigned long> &, const std::__nonesuch &> {
        typedef const std::pair<bool, unsigned long> &type;
    };
template<> struct conditional<true, std::is_move_assignable<unsigned long>, std::is_move_assignable<bool>> {
        typedef std::is_move_assignable<unsigned long> type;
    };
template<> struct conditional<true, std::pair<bool, unsigned long> &&, std::__nonesuch &&> {
        typedef std::pair<bool, unsigned long> &&type;
    };
template<> struct conditional<true, std::is_constructible<unsigned long, const unsigned long &>, std::is_constructible<bool, const bool &>> {
        typedef std::is_constructible<unsigned long, const unsigned long &> type;
    };
template<> struct conditional<false, std::is_void<const bool &>, std::__or_<std::is_function<bool>, std::is_array<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_array<bool>> type;
    };
template<> struct conditional<false, std::is_function<bool>, std::is_array<bool>> {
        typedef std::is_array<bool> type;
    };
template<> struct conditional<true, std::is_convertible<const unsigned long &, unsigned long>, std::is_convertible<const bool &, bool>> {
        typedef std::is_convertible<const unsigned long &, unsigned long> type;
    };
template<> struct conditional<false, std::is_void<const unsigned long &>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    };
template<> struct conditional<false, std::is_function<unsigned long>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    };
template<> struct conditional<true, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> {
        typedef std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>> type;
    };
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>, std::is_constructible<bool, bool &&>> {
        typedef std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> type;
    };
template<> struct conditional<true, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>, std::is_constructible<unsigned long, const unsigned long &&>> {
        typedef std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>> type;
    };
template<> struct conditional<false, std::is_void<bool &&>, std::__or_<std::is_function<bool>, std::is_array<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_array<bool>> type;
    };
template<> struct conditional<true, std::is_convertible<const unsigned long &, unsigned long>, std::is_convertible<bool &&, bool>> {
        typedef std::is_convertible<const unsigned long &, unsigned long> type;
    };
template<> struct conditional<false, std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> {
        typedef std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> type;
    };
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>>, std::is_constructible<bool, bool &&>> {
        typedef std::__and_<std::is_constructible<unsigned long, const unsigned long &&>, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>> type;
    };
template<> struct conditional<true, std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>>, std::is_constructible<unsigned long, const unsigned long &&>> {
        typedef std::__not_<std::__and_<std::is_convertible<bool &&, bool>, std::is_convertible<const unsigned long &, unsigned long>>> type;
    };
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>> type;
    };
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> type;
    };
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>, std::is_constructible<unsigned long, unsigned long &&>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>> type;
    };
template<> struct conditional<true, std::is_convertible<unsigned long &&, unsigned long>, std::is_convertible<const bool &, bool>> {
        typedef std::is_convertible<unsigned long &&, unsigned long> type;
    };
template<> struct conditional<false, std::is_void<unsigned long &&>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    };
template<> struct conditional<false, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> type;
    };
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, unsigned long &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>> type;
    };
template<> struct conditional<true, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>>, std::is_constructible<unsigned long, unsigned long &&>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<unsigned long &&, unsigned long>>> type;
    };
template<> struct conditional<true, std::is_constructible<unsigned long, unsigned long &&>, std::is_constructible<bool, bool &&>> {
        typedef std::is_constructible<unsigned long, unsigned long &&> type;
    };
template<> struct conditional<true, std::is_convertible<unsigned long &&, unsigned long>, std::is_convertible<bool &&, bool>> {
        typedef std::is_convertible<unsigned long &&, unsigned long> type;
    };
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>> type;
    };
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, int &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, int &&>, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> type;
    };
template<> struct conditional<true, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>, std::is_constructible<unsigned long, int &&>> {
        typedef std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>> type;
    };
template<> struct conditional<true, std::is_convertible<int &&, unsigned long>, std::is_convertible<const bool &, bool>> {
        typedef std::is_convertible<int &&, unsigned long> type;
    };
template<> struct conditional<false, std::is_void<int &&>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    };
template<> struct conditional<false, std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> type;
    };
template<> struct conditional<true, std::__and_<std::is_constructible<unsigned long, int &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>>, std::is_constructible<bool, const bool &>> {
        typedef std::__and_<std::is_constructible<unsigned long, int &&>, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>> type;
    };
template<> struct conditional<true, std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>>, std::is_constructible<unsigned long, int &&>> {
        typedef std::__not_<std::__and_<std::is_convertible<const bool &, bool>, std::is_convertible<int &&, unsigned long>>> type;
    };
template<> struct conditional<true, std::is_constructible<unsigned long, int &&>, std::is_constructible<bool, bool &&>> {
        typedef std::is_constructible<unsigned long, int &&> type;
    };
template<> struct conditional<true, std::is_convertible<int &&, unsigned long>, std::is_convertible<bool &&, bool>> {
        typedef std::is_convertible<int &&, unsigned long> type;
    };
template<> struct conditional<true, std::__is_nothrow_invocable<const std::hash<int> &, const int &>, std::__is_fast_hash<std::hash<int>>> {
        typedef std::__is_nothrow_invocable<const std::hash<int> &, const int &> type;
    };
template<> struct conditional<true, std::__call_is_nothrow<std::__invoke_result<const std::hash<int> &, const int &>, const std::hash<int> &, const int &>, std::__is_invocable<const std::hash<int> &, const int &>> {
        typedef std::__call_is_nothrow<std::__invoke_result<const std::hash<int> &, const int &>, const std::hash<int> &, const int &> type;
    };
template<> struct conditional<true, std::pair<std::__detail::_Node_iterator<std::pair<const int, int>, false, false>, bool>, std::__detail::_Node_iterator<std::pair<const int, int>, false, false>> {
        typedef std::pair<std::__detail::_Node_iterator<std::pair<const int, int>, false, false>, bool> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const int>, std::is_rvalue_reference<const int>> {
        typedef std::is_rvalue_reference<const int> type;
    };
template<> struct conditional<false, std::is_reference<const int>, std::__or_<std::is_function<const int>, std::is_void<const int>, std::__is_array_unknown_bounds<const int>>> {
        typedef std::__or_<std::is_function<const int>, std::is_void<const int>, std::__is_array_unknown_bounds<const int>> type;
    };
template<> struct conditional<false, std::is_function<const int>, std::__or_<std::is_void<const int>, std::__is_array_unknown_bounds<const int>>> {
        typedef std::__or_<std::is_void<const int>, std::__is_array_unknown_bounds<const int>> type;
    };
template<> struct conditional<false, std::is_void<const int>, std::__is_array_unknown_bounds<const int>> {
        typedef std::__is_array_unknown_bounds<const int> type;
    };
template<> struct conditional<false, std::__not_<std::extent<const int, 0>>, std::is_array<const int>> {
        typedef std::is_array<const int> type;
    };
template<> struct conditional<false, std::is_copy_assignable<int>, std::is_copy_assignable<const int>> {
        typedef std::is_copy_assignable<const int> type;
    };
template<> struct conditional<false, const std::pair<const int, int> &, const std::__nonesuch &> {
        typedef const std::__nonesuch &type;
    };
template<> struct conditional<false, std::is_move_assignable<int>, std::is_move_assignable<const int>> {
        typedef std::is_move_assignable<const int> type;
    };
template<> struct conditional<false, std::pair<const int, int> &&, std::__nonesuch &&> {
        typedef std::__nonesuch &&type;
    };
template<> struct conditional<false, std::__detail::_Identity, std::__detail::_Select1st> {
        typedef std::__detail::_Select1st type;
    };
template<> struct conditional<true, std::__not_<std::integral_constant<bool, false>>, std::is_default_constructible<std::__detail::_Mod_range_hashing>> {
        typedef std::__not_<std::integral_constant<bool, false>> type;
    };
template<> struct conditional<false, std::pair<std::__detail::_Node_iterator<std::pair<const int, int>, false, false>, bool>, std::__detail::_Node_iterator<std::pair<const int, int>, false, false>> {
        typedef std::__detail::_Node_iterator<std::pair<const int, int>, false, false> type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[11], void>>, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>> type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, const char *const &, void>>, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>>> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &>> type;
    };
template<> struct conditional<false, std::__undefined, char> {
        typedef char type;
    };
template<> struct conditional<false, std::__undefined, const char> {
        typedef const char type;
    };
template<> struct conditional<false, std::is_void<std::random_access_iterator_tag>, std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> {
        typedef std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> type;
    };
template<> struct conditional<false, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> {
        typedef std::is_array<std::input_iterator_tag> type;
    };
template<> struct conditional<false, std::is_void<char *const &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    };
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>, std::is_convertible<char *const &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<char *const &, const char *>>> type;
    };
template<> struct conditional<false, std::is_void<char *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> type;
    };
template<> struct conditional<true, std::__not_<std::is_convertible<char *const &, const char *>>, std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char> *>>> {
        typedef std::__not_<std::is_convertible<char *const &, const char *>> type;
    };
template<> struct conditional<false, std::is_void<char *const &>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    };
template<> struct conditional<false, std::is_void<wchar_t *const &>, std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> type;
    };
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>, std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>> type;
    };
template<> struct conditional<false, std::is_void<wchar_t *const *>, std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<wchar_t> *>, std::is_array<const std::__cxx11::basic_string<wchar_t> *>> type;
    };
template<> struct conditional<true, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>, std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t> *>>> {
        typedef std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_void<wchar_t *const &>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    };
template<> struct conditional<false, std::__undefined, wchar_t> {
        typedef wchar_t type;
    };
template<> struct conditional<false, std::__undefined, const wchar_t> {
        typedef const wchar_t type;
    };
template<> struct conditional<false, std::__undefined, char16_t> {
        typedef char16_t type;
    };
template<> struct conditional<false, std::__undefined, const char16_t> {
        typedef const char16_t type;
    };
template<> struct conditional<false, std::__undefined, char32_t> {
        typedef char32_t type;
    };
template<> struct conditional<false, std::__undefined, const char32_t> {
        typedef const char32_t type;
    };
template<> struct conditional<false, std::is_void<const std::__cxx11::basic_string<char> &>, std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
        typedef std::__or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> type;
    };
template<> struct conditional<true, std::__and_<std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>>, std::is_convertible<const std::__cxx11::basic_string<char> &, std::basic_string_view<char, std::char_traits<char>>>> {
        typedef std::__and_<std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>> type;
    };
template<> struct conditional<false, std::is_void<const std::__cxx11::basic_string<char> *>, std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>>> {
        typedef std::__or_<std::is_function<const std::__cxx11::basic_string<char> *>, std::is_array<const std::__cxx11::basic_string<char> *>> type;
    };
template<> struct conditional<false, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> &, const char *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>>> {
        typedef std::__not_<std::is_convertible<const std::__cxx11::basic_string<char> *, const std::__cxx11::basic_string<char> *>> type;
    };
    template <typename _Iftrue, typename _Iffalse> struct conditional<false, _Iftrue, _Iffalse> {
        typedef _Iffalse type;
    };
    template <typename _Tp> using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    template <typename ..._Tp> struct common_type;
    struct __do_common_type_impl {
        template <typename _Tp, typename _Up> using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());
        template <typename _Tp, typename _Up> static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test_2(...);
        template <typename _Tp, typename _Up> static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
    };
    template<> struct common_type<> {
    };
    template <typename _Tp0> struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {
    };
    template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>> struct __common_type_impl {
        using type = common_type<_Dp1, _Dp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2> : private std::__do_common_type_impl {
        using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };
    template <typename _Tp1, typename _Tp2> struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {
    };
    template <typename ...> struct __common_type_pack {
    };
    template <typename, typename, typename = void> struct __common_type_fold;
    template <typename _Tp1, typename _Tp2, typename ..._Rp> struct common_type<_Tp1, _Tp2, _Rp...> : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>> {
    };
    template <typename _CTp, typename ..._Rp> struct __common_type_fold<_CTp, __common_type_pack<_Rp...>, __void_t<typename _CTp::type>> : public common_type<typename _CTp::type, _Rp...> {
    };
    template <typename _CTp, typename _Rp> struct __common_type_fold<_CTp, _Rp, void> {
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl {
        using type = __underlying_type(_Tp);
    };
    template <typename _Tp> struct __underlying_type_impl<_Tp, false> {
    };
    template <typename _Tp> struct underlying_type : public __underlying_type_impl<_Tp> {
    };
    template <typename _Tp> struct __declval_protector {
        static const bool __stop = false;
    };
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0))     {
        static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
        return __declval<_Tp>(0);
    }
    template<> auto declval<std::allocator<char> &>() noexcept -> decltype(__declval<std::allocator<char> &>(0))    template<> auto declval<const unsigned int &>() noexcept -> decltype(__declval<const unsigned int &>(0))    template<> auto declval<std::allocator<wchar_t> &>() noexcept -> decltype(__declval<std::allocator<wchar_t> &>(0))    template<> auto declval<std::allocator<char16_t> &>() noexcept -> decltype(__declval<std::allocator<char16_t> &>(0))    template<> auto declval<std::allocator<char32_t> &>() noexcept -> decltype(__declval<std::allocator<char32_t> &>(0))    template<> auto declval<const char *const &>() noexcept -> decltype(__declval<const char *const &>(0))    template<> auto declval<const char *const *>() noexcept -> decltype(__declval<const char *const *>(0))    template<> auto declval<const wchar_t *const &>() noexcept -> decltype(__declval<const wchar_t *const &>(0))    template<> auto declval<const wchar_t *const *>() noexcept -> decltype(__declval<const wchar_t *const *>(0))    template<> auto declval<const char16_t *const &>() noexcept -> decltype(__declval<const char16_t *const &>(0))    template<> auto declval<const char16_t *const *>() noexcept -> decltype(__declval<const char16_t *const *>(0))    template<> auto declval<const char32_t *const &>() noexcept -> decltype(__declval<const char32_t *const &>(0))    template<> auto declval<const char32_t *const *>() noexcept -> decltype(__declval<const char32_t *const *>(0))    template<> auto declval<const char &>() noexcept -> decltype(__declval<const char &>(0))    template<> auto declval<const int &>() noexcept -> decltype(__declval<const int &>(0))    template<> auto declval<std::basic_istream<char> *>() noexcept -> decltype(__declval<std::basic_istream<char> *>(0))    template<> auto declval<std::basic_istream<wchar_t> *>() noexcept -> decltype(__declval<std::basic_istream<wchar_t> *>(0))    template<> auto declval<const bool &>() noexcept -> decltype(__declval<const bool &>(0))    template<> auto declval<const unsigned long &>() noexcept -> decltype(__declval<const unsigned long &>(0))    template<> auto declval<bool &&>() noexcept -> decltype(__declval<bool &&>(0))    template<> auto declval<unsigned long &&>() noexcept -> decltype(__declval<unsigned long &&>(0))    template<> auto declval<int &&>() noexcept -> decltype(__declval<int &&>(0))    template<> auto declval<const std::hash<int> &>() noexcept -> decltype(__declval<const std::hash<int> &>(0))    template<> auto declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &>() noexcept -> decltype(__declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &>(0))    template<> auto declval<const std::__detail::_Mod_range_hashing &>() noexcept -> decltype(__declval<const std::__detail::_Mod_range_hashing &>(0))    template<> auto declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &>() noexcept -> decltype(__declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &>(0))    template<> auto declval<std::basic_ostream<char> *>() noexcept -> decltype(__declval<std::basic_ostream<char> *>(0))    template<> auto declval<std::random_access_iterator_tag>() noexcept -> decltype(__declval<std::random_access_iterator_tag>(0))    template<> auto declval<char *const &>() noexcept -> decltype(__declval<char *const &>(0))    template<> auto declval<char *const *>() noexcept -> decltype(__declval<char *const *>(0))    template<> auto declval<wchar_t *const &>() noexcept -> decltype(__declval<wchar_t *const &>(0))    template<> auto declval<wchar_t *const *>() noexcept -> decltype(__declval<wchar_t *const *>(0))    template<> auto declval<const std::__cxx11::basic_string<char> &>() noexcept -> decltype(__declval<const std::__cxx11::basic_string<char> &>(0))    template<> auto declval<const std::__cxx11::basic_string<char> *>() noexcept -> decltype(__declval<const std::__cxx11::basic_string<char> *>(0))    template <typename _Signature> class result_of;
    struct __invoke_memfun_ref {
    };
    struct __invoke_memfun_deref {
    };
    struct __invoke_memobj_ref {
    };
    struct __invoke_memobj_deref {
    };
    struct __invoke_other {
    };
    template <typename _Tp, typename _Tag> struct __result_of_success : __success_type<_Tp> {
        using __invoke_type = _Tag;
    };
template<> struct __result_of_success<unsigned long, std::__invoke_other> : __success_type<unsigned long> {
        using __invoke_type = std::__invoke_other;
    };
    struct __result_of_memfun_ref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype((std::declval<_Tp1>() .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_ref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_ref : private std::__result_of_memfun_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memfun_deref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype(((*std::declval<_Tp1>()) .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_deref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_deref : private std::__result_of_memfun_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memobj_ref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype(std::declval<_Tp1>() .* std::declval<_Fp>()), std::__invoke_memobj_ref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_ref : private std::__result_of_memobj_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    struct __result_of_memobj_deref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype((*std::declval<_Tp1>()) .* std::declval<_Fp>()), std::__invoke_memobj_deref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_deref : private std::__result_of_memobj_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj;
    template <typename _Res, typename _Class, typename _Arg> struct __result_of_memobj<_Res _Class::*, _Arg> {
        typedef __remove_cvref_t<_Arg> _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename conditional<__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value, __result_of_memobj_ref<_MemPtr, _Arg>, __result_of_memobj_deref<_MemPtr, _Arg>>::type::type type;
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun;
    template <typename _Res, typename _Class, typename _Arg, typename ..._Args> struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
        typedef typename remove_reference<_Arg>::type _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename conditional<is_base_of<_Class, _Argval>::value, __result_of_memfun_ref<_MemPtr, _Arg, _Args...>, __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type::type type;
    };
    template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>> struct __inv_unwrap {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
        using type = _Up &;
    };
    template <bool, bool, typename _Functor, typename ..._ArgTypes> struct __result_of_impl {
        typedef std::__failure_type type;
    };
template<> struct __result_of_impl<false, false, const std::hash<int> &, <const int &>> : private std::__result_of_other_impl {
        typedef decltype(_S_test<const std::hash<int> &, const int &>(0)) type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_impl<true, false, _MemPtr, _Arg> : public __result_of_memobj<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type> {
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...> : public __result_of_memfun<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type, _Args...> {
    };
    struct __result_of_other_impl {
        template <typename _Fn, typename ..._Args> static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)), std::__invoke_other> _S_test(int);
        template<> static __result_of_success<decltype(std::declval<const std::hash<int> &>()(std::declval<const int &>())), std::__invoke_other> _S_test<const std::hash<int> &, <const int &>>(int);
        template <typename ...> static std::__failure_type _S_test(...);
        template<> static std::__failure_type _S_test<<const std::hash<int> &, const int &>>(...);
    };
    template <typename _Functor, typename ..._ArgTypes> struct __result_of_impl<false, false, _Functor, _ArgTypes...> : private std::__result_of_other_impl {
        typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };
    template <typename _Functor, typename ..._ArgTypes> struct __invoke_result : public __result_of_impl<is_member_object_pointer<typename remove_reference<_Functor>::type>::value, is_member_function_pointer<typename remove_reference<_Functor>::type>::value, _Functor, _ArgTypes...>::type {
    };
template<> struct __invoke_result<const std::hash<int> &, <const int &>> : public __result_of_impl<is_member_object_pointer<typename remove_reference<const hash<int> &>::type>::value, is_member_function_pointer<typename remove_reference<const hash<int> &>::type>::value, const hash<int> &, const int &>::type {
    };
    template <typename _Functor, typename ..._ArgTypes> struct result_of<_Functor (_ArgTypes...)> : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <std::size_t _Len, typename ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <typename _Tp> using decay_t = typename decay<_Tp>::type;
    template <bool _Cond, typename _Tp = void> using enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
    template <typename ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
    template <typename _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
    template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;
    template <typename ...> using void_t = void;
    template <typename _Default, typename _AlwaysVoid, template <typename ...> class _Op, typename ..._Args> struct __detector {
        using value_t = std::false_type;
        using type = _Default;
    };
template<> struct __detector<std::integral_constant<bool, false>, void, __has_load_factor, <std::__detail::_Prime_rehash_policy>> {
        using value_t = std::true_type;
        using type = __has_load_factor<std::__detail::_Prime_rehash_policy>;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {
        using value_t = std::true_type;
        using type = _Op<_Args...>;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or = __detector<_Default, void, _Op, _Args...>;
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
    template <typename _Tp> struct __is_swappable;
    template <typename _Tp> struct __is_nothrow_swappable;
    template <typename ..._Elements> class tuple;
    template <typename> struct __is_tuple_like_impl : std::false_type {
    };
    template <typename ..._Tps> struct __is_tuple_like_impl<tuple<_Tps...>> : std::true_type {
    };
    template <typename _Tp> struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {
    };
    template <typename _Tp> inline _Require<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>> swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::valueswap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value);
    template <typename _Tp, std::size_t _Nm> inline __enable_if_t<__is_swappable<_Tp>::value> swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);
    namespace __swappable_details {
        using std::swap;
        struct __do_is_swappable_impl {
            template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_impl {
            template <typename _Tp> static __bool_constant<noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> __test(int);
            template <typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp> struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_swappable : public __is_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct is_swappable : public __is_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool is_swappable_v = is_swappable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
    namespace __swappable_with_details {
        using std::swap;
        struct __do_is_swappable_with_impl {
            template <typename _Tp, typename _Up, typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())), typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))> static std::true_type __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_with_impl {
            template <typename _Tp, typename _Up> static __bool_constant<noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) && noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))> __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp, typename _Up> struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
    };
    template <typename _Tp, typename _Up> struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
    };
    template <typename _Tp, typename _Up> constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
    template <typename _Result, typename _Ret, bool = is_void<_Ret>::value, typename = void> struct __is_invocable_impl : std::false_type {
    };
template<> struct __is_invocable_impl<std::__invoke_result<const std::hash<int> &, const int &>, void, true, void> : std::true_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, true, __void_t<typename _Result::type>> : std::true_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, false, __void_t<typename _Result::type>> {
    private:
        static typename _Result::type _S_get();
        template <typename _Tp> static void _S_conv(_Tp);
        template <typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))> static std::true_type _S_test(int);
        template <typename _Tp> static std::false_type _S_test(...);
    public:
        using type = decltype(_S_test<_Ret>(1));
    };
    template <typename _Fn, typename ..._ArgTypes> struct __is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
    };
template<> struct __is_invocable<const std::hash<int> &, <const int &>> : __is_invocable_impl<__invoke_result<const hash<int> &, const int &>, void>::type {
    };
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept((std::declval<_Up>() .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_deref)     {
        return noexcept(((*std::declval<_Tp>()) .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept(std::declval<_Up>() .* std::declval<_Fn>());
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_deref)     {
        return noexcept((*std::declval<_Tp>()) .* std::declval<_Fn>());
    }
    template <typename _Fn, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_other)     {
        return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }
    template<> constexpr bool __call_is_nt<const std::hash<int> &, <const int &>>(std::__invoke_other)     {
        return noexcept(std::declval<const std::hash<int> &>()(std::declval<const int &>()));
    }
    template <typename _Result, typename _Fn, typename ..._Args> struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type({}))> {
    };
template<> struct __call_is_nothrow<std::__invoke_result<const std::hash<int> &, const int &>, const std::hash<int> &, <const int &>> : __bool_constant<std::__call_is_nt<const std::hash<int> &, const int &>(typename __invoke_result<const hash<int> &, const int &>::__invoke_type{})> {
    };
    template <typename _Fn, typename ..._Args> using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
    template <typename _Fn, typename ..._Args> struct __is_nothrow_invocable : __and_<__is_invocable<_Fn, _Args...>, __call_is_nothrow_<_Fn, _Args...>>::type {
    };
template<> struct __is_nothrow_invocable<const std::hash<int> &, <const int &>> : __and_<__is_invocable<const hash<int> &, const int &>, __call_is_nothrow_<const hash<int> &, const int &>>::type {
    };
    struct __nonesuchbase {
    };
    struct __nonesuch : private std::__nonesuchbase {
        ~__nonesuch() = delete
        __nonesuch(const std::__nonesuch &) = delete
        void operator=(const std::__nonesuch &) = delete
    };
    template <typename _Functor, typename ..._ArgTypes> struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <typename _Fn, typename ..._Args> using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
    template <typename _Fn, typename ..._ArgTypes> struct is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
    };
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_invocable_r : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
    };
    template <typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
    };
    template <typename _Result, typename _Ret, typename = void> struct __is_nt_invocable_impl : std::false_type {
    };
    template <typename _Result, typename _Ret> struct __is_nt_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>> : __or_<is_void<_Ret>, __is_nothrow_convertible<typename _Result::type, _Ret>> {
    };
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable_r : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
    };
    template <typename _Fn, typename ..._Args> constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
    template <typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Tp> constexpr bool is_void_v = is_void<_Tp>::value;
    template <typename _Tp> constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_integral_v = is_integral<_Tp>::value;
    template <typename _Tp> constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
    template <typename _Tp> constexpr bool is_array_v = is_array<_Tp>::value;
    template <typename _Tp> constexpr bool is_pointer_v = is_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_enum_v = is_enum<_Tp>::value;
    template <typename _Tp> constexpr bool is_union_v = is_union<_Tp>::value;
    template <typename _Tp> constexpr bool is_class_v = is_class<_Tp>::value;
    template <typename _Tp> constexpr bool is_function_v = is_function<_Tp>::value;
    template <typename _Tp> constexpr bool is_reference_v = is_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
    template <typename _Tp> constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
    template <typename _Tp> constexpr bool is_object_v = is_object<_Tp>::value;
    template <typename _Tp> constexpr bool is_scalar_v = is_scalar<_Tp>::value;
    template <typename _Tp> constexpr bool is_compound_v = is_compound<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_const_v = is_const<_Tp>::value;
    template <typename _Tp> constexpr bool is_volatile_v = is_volatile<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivial_v = is_trivial<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Tp>::value;
    template <typename _Tp> constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
    template <typename _Tp> constexpr bool is_pod_v = is_pod<_Tp>::value;
    template <typename _Tp> constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;
    template <typename _Tp> constexpr bool is_empty_v = is_empty<_Tp>::value;
    template <typename _Tp> constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
    template <typename _Tp> constexpr bool is_abstract_v = is_abstract<_Tp>::value;
    template <typename _Tp> constexpr bool is_final_v = is_final<_Tp>::value;
    template <typename _Tp> constexpr bool is_signed_v = is_signed<_Tp>::value;
    template <typename _Tp> constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_constructible_v = is_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_default_constructible_v = is_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_destructible_v = is_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;
    template <typename _Tp> constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Tp>::value;
    template <typename _Tp> constexpr std::size_t alignment_of_v = alignment_of<_Tp>::value;
    template <typename _Tp> constexpr std::size_t rank_v = rank<_Tp>::value;
    template <typename _Tp, unsigned int _Idx = 0> constexpr std::size_t extent_v = extent<_Tp, _Idx>::value;
    template <typename _Tp, typename _Up> constexpr bool is_same_v = __is_same(_Tp, _Up);
    template <typename _Base, typename _Derived> constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
    template <typename _From, typename _To> constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
    template <typename _Tp> struct has_unique_object_representations : bool_constant<__has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Tp>::value;
    template <typename _Tp> struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {
    };
    template <typename _Tp> constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
    constexpr bool is_array_v = is_array<char>::value;
    constexpr bool is_trivial_v = is_trivial<char>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char>::value;
    constexpr bool is_same_v = __is_same(char, char);
    constexpr bool is_array_v = is_array<wchar_t>::value;
    constexpr bool is_trivial_v = is_trivial<wchar_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<wchar_t>::value;
    constexpr bool is_same_v = __is_same(wchar_t, wchar_t);
    constexpr bool is_array_v = is_array<char16_t>::value;
    constexpr bool is_trivial_v = is_trivial<char16_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char16_t>::value;
    constexpr bool is_same_v = __is_same(char16_t, char16_t);
    constexpr bool is_array_v = is_array<char32_t>::value;
    constexpr bool is_trivial_v = is_trivial<char32_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char32_t>::value;
    constexpr bool is_same_v = __is_same(char32_t, char32_t);
}
namespace std {
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept     {
        return static_cast<_Tp &&>(__t);
    }
    template<> constexpr bool &&forward<bool>(typename std::remove_reference<bool>::type &__t) noexcept     {
        return static_cast<bool &&>(__t);
    }
    template<> constexpr unsigned long &&forward<unsigned long>(typename std::remove_reference<unsigned long>::type &__t) noexcept     {
        return static_cast<unsigned long &&>(__t);
    }
    template<> constexpr int &&forward<int>(typename std::remove_reference<int>::type &__t) noexcept     {
        return static_cast<int &&>(__t);
    }
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &&__t) noexcept     {
        static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument substituting _Tp is an lvalue reference type");
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept     {
        return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char> &>::type &&move<std::allocator<char> &>(std::allocator<char> &__t) noexcept     {
        return static_cast<typename std::remove_reference<allocator<char> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<basic_string<char> &>::type &&move<std::__cxx11::basic_string<char> &>(std::__cxx11::basic_string<char> &__t) noexcept     {
        return static_cast<typename std::remove_reference<basic_string<char> &>::type &&>(__t);
    }
    template <typename _Tp> struct __move_if_noexcept_cond : public __and_<__not_<is_nothrow_move_constructible<_Tp>>, is_copy_constructible<_Tp>>::type {
    };
    template <typename _Tp> constexpr typename conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept     {
        return std::move(__x);
    }
    template <typename _Tp> inline constexpr _Tp *addressof(_Tp &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr char *addressof<char>(char &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const char *addressof<const char>(const char &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr wchar_t *addressof<wchar_t>(wchar_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const wchar_t *addressof<const wchar_t>(const wchar_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr char16_t *addressof<char16_t>(char16_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const char16_t *addressof<const char16_t>(const char16_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr char32_t *addressof<char32_t>(char32_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const char32_t *addressof<const char32_t>(const char32_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete    template<> const char *addressof<char>(const char &&) = delete    template<> const wchar_t *addressof<wchar_t>(const wchar_t &&) = delete    template<> const char16_t *addressof<char16_t>(const char16_t &&) = delete    template<> const char32_t *addressof<char32_t>(const char32_t &&) = delete
    template <typename _Tp, typename _Up = _Tp> inline _Tp __exchange(_Tp &__obj, _Up &&__new_val)     {
        _Tp __old_val = std::move(__obj);
        __obj = std::forward<_Up>(__new_val);
        return __old_val;
    }
    template <typename _Tp> inline typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value>::type swap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::valueswap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)     {
        _Tp __tmp = std::move(__a);
        __a = std::move(__b);
        __b = std::move(__tmp);
    }
    template <typename _Tp, std::size_t _Nm> inline typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value)     {
        for (std::size_t __n = 0; __n < _Nm; ++__n)
            swap(__a[__n], __b[__n]);
    }
}
extern "C++" {
    namespace std {
        class nested_exception {
            std::__exception_ptr::exception_ptr _M_ptr;
        public:
            nested_exception() noexcept : _M_ptr(current_exception())             {
            }
            nested_exception(const std::nested_exception &) noexcept = default
            std::nested_exception &operator=(const std::nested_exception &) noexcept = default
            virtual ~nested_exception() noexcept;
            void rethrow_nested() const [[noreturn]]             {
                if (this->_M_ptr)
                    rethrow_exception(this->_M_ptr);
                std::terminate();
            }
            std::__exception_ptr::exception_ptr nested_ptr() const noexcept             {
                return this->_M_ptr;
            }
        };
        template <typename _Except> struct _Nested_exception : public _Except, public std::nested_exception {
            explicit _Nested_exception<_Except>(const _Except &__ex) : _Except(__ex)             {
            }
            explicit _Nested_exception<_Except>(_Except &&__ex) : _Except(static_cast<_Except &&>(__ex))             {
            }
        };
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::true_type) [[noreturn]]         {
            using _Up = typename remove_reference<_Tp>::type;
            throw _Nested_exception<_Up>({std::forward<_Tp>(__t)});
        }
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::false_type) [[noreturn]]         {
            throw std::forward<_Tp>(__t);
        }
        template <typename _Tp> inline void throw_with_nested(_Tp &&__t) [[noreturn]]         {
            using _Up = typename decay<_Tp>::type;
            using _CopyConstructible = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
            static_assert(_CopyConstructible::value, "throw_with_nested argument must be CopyConstructible");
            using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>, __not_<is_base_of<std::nested_exception, _Up>>>;
            std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest({}));
        }
        template <typename _Tp> using __rethrow_if_nested_cond = typename enable_if<__and_<is_polymorphic<_Tp>, __or_<__not_<is_base_of<nested_exception, _Tp>>, is_convertible<_Tp *, nested_exception *>>>::value>::type;
        template <typename _Ex> inline __rethrow_if_nested_cond<_Ex> __rethrow_if_nested_impl(const _Ex *__ptr)         {
            if (auto __ne_ptr = dynamic_cast<const std::nested_exception *>(__ptr))
                __ne_ptr->rethrow_nested();
        }
        inline void __rethrow_if_nested_impl(const void *)         {
        }
        template <typename _Ex> inline void rethrow_if_nested(const _Ex &__ex)         {
            std::__rethrow_if_nested_impl(std::__addressof(__ex));
        }
    }
}
namespace std {
    void __throw_bad_exception();
    void __throw_bad_alloc();
    void __throw_bad_cast();
    void __throw_bad_typeid();
    void __throw_logic_error(const char *);
    void __throw_domain_error(const char *);
    void __throw_invalid_argument(const char *);
    void __throw_length_error(const char *);
    void __throw_out_of_range(const char *);
    void __throw_out_of_range_fmt(const char *, ...);
    void __throw_runtime_error(const char *);
    void __throw_range_error(const char *);
    void __throw_overflow_error(const char *);
    void __throw_underflow_error(const char *);
    void __throw_ios_failure(const char *);
    void __throw_ios_failure(const char *, int);
    void __throw_system_error(int);
    void __throw_future_error(int);
    void __throw_bad_function_call();
}
extern "C++" {
    namespace std {
        struct __true_type {
        };
        struct __false_type {
        };
        template <bool> struct __truth_type {
            typedef std::__false_type __type;
        };
        template<> struct __truth_type<true> {
            typedef std::__true_type __type;
        };
        template <class _Sp, class _Tp> struct __traitor {
            enum  {
                __value = bool(_Sp::__value) || bool(_Tp::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template <typename, typename> struct __are_same {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<float, float> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
template<> struct __are_same<float, double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<double, float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<double, double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
template<> struct __are_same<long double, float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<long double, double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __are_same<_Tp, _Tp> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_void {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_void<void> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_integer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<long double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<char *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<wchar_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const char *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const wchar_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const char16_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const char32_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<bool> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char16_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char32_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_floating {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_floating<float> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<long double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_pointer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __is_pointer<_Tp *> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_arithmetic : public __traitor<__is_integer<_Tp>, __is_floating<_Tp>> {
        };
        template <typename _Tp> struct __is_scalar : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>> {
        };
        template <typename _Tp> struct __is_char {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_char<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_char<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_byte {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_byte<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        enum class byte : unsigned char;
        template<> struct __is_byte<std::byte> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename> struct iterator_traits
template<> struct iterator_traits<char *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char value_type;
            typedef std::ptrdiff_t difference_type;
            typedef char *pointer;
            typedef char &reference;
        }
template<> struct iterator_traits<const char *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const char *pointer;
            typedef const char &reference;
        }
template<> struct iterator_traits<wchar_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef wchar_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef wchar_t &reference;
        }
template<> struct iterator_traits<const wchar_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef wchar_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const wchar_t *pointer;
            typedef const wchar_t &reference;
        }
template<> struct iterator_traits<const char16_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char16_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const char16_t *pointer;
            typedef const char16_t &reference;
        }
template<> struct iterator_traits<char16_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char16_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef char16_t *pointer;
            typedef char16_t &reference;
        }
template<> struct iterator_traits<const char32_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char32_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef const char32_t *pointer;
            typedef const char32_t &reference;
        }
template<> struct iterator_traits<char32_t *> {
            typedef std::random_access_iterator_tag iterator_category;
            typedef char32_t value_type;
            typedef std::ptrdiff_t difference_type;
            typedef char32_t *pointer;
            typedef char32_t &reference;
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable {
            enum  {
                __value = __is_trivially_copyable(_Tp)
            };
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
            enum  {
                __value = 0
            };
        };
        template <typename _OutputIter, typename _InputIter> struct __memcpyable {
            enum  {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcpyable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcpyable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Iter1, typename _Iter2> struct __memcmpable {
            enum  {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcmpable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<const _Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __is_move_iterator {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Iterator> inline _Iterator __miter_base(_Iterator __it)         {
            return __it;
        }
    }
}
extern "C++" {
    namespace __gnu_cxx {
        template <bool, typename> struct __enable_if {
        };
        template <typename _Tp> struct __enable_if<true, _Tp> {
            typedef _Tp __type;
        };
        template <bool _Cond, typename _Iftrue, typename _Iffalse> struct __conditional_type {
            typedef _Iftrue __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<int>, __gnu_cxx::__numeric_traits_floating<int>> {
            typedef __gnu_cxx::__numeric_traits_integer<int> __type;
        };
template<> struct __conditional_type<false, __gnu_cxx::__numeric_traits_integer<float>, __gnu_cxx::__numeric_traits_floating<float>> {
            typedef __gnu_cxx::__numeric_traits_floating<float> __type;
        };
template<> struct __conditional_type<false, __gnu_cxx::__numeric_traits_integer<double>, __gnu_cxx::__numeric_traits_floating<double>> {
            typedef __gnu_cxx::__numeric_traits_floating<double> __type;
        };
template<> struct __conditional_type<false, __gnu_cxx::__numeric_traits_integer<long double>, __gnu_cxx::__numeric_traits_floating<long double>> {
            typedef __gnu_cxx::__numeric_traits_floating<long double> __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<unsigned long>, __gnu_cxx::__numeric_traits_floating<unsigned long>> {
            typedef __gnu_cxx::__numeric_traits_integer<unsigned long> __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<char>, __gnu_cxx::__numeric_traits_floating<char>> {
            typedef __gnu_cxx::__numeric_traits_integer<char> __type;
        };
template<> struct __conditional_type<true, unsigned long, unsigned long long> {
            typedef unsigned long __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<short>, __gnu_cxx::__numeric_traits_floating<short>> {
            typedef __gnu_cxx::__numeric_traits_integer<short> __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<long>, __gnu_cxx::__numeric_traits_floating<long>> {
            typedef __gnu_cxx::__numeric_traits_integer<long> __type;
        };
        template <typename _Iftrue, typename _Iffalse> struct __conditional_type<false, _Iftrue, _Iffalse> {
            typedef _Iffalse __type;
        };
        template <typename _Tp> struct __add_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __add_unsigned<char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<signed char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<short> {
            typedef unsigned short __type;
        };
        template<> struct __add_unsigned<int> {
            typedef unsigned int __type;
        };
        template<> struct __add_unsigned<long> {
            typedef unsigned long __type;
        };
        template<> struct __add_unsigned<long long> {
            typedef unsigned long long __type;
        };
        template<> struct __add_unsigned<bool>;
        template<> struct __add_unsigned<wchar_t>;
        template <typename _Tp> struct __remove_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __remove_unsigned<char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned short> {
            typedef short __type;
        };
        template<> struct __remove_unsigned<unsigned int> {
            typedef int __type;
        };
        template<> struct __remove_unsigned<unsigned long> {
            typedef long __type;
        };
        template<> struct __remove_unsigned<unsigned long long> {
            typedef long long __type;
        };
        template<> struct __remove_unsigned<bool>;
        template<> struct __remove_unsigned<wchar_t>;
        template <typename _Type> inline bool __is_null_pointer(_Type *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<char>(char *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<wchar_t>(wchar_t *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const char>(const char *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const wchar_t>(const wchar_t *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const char16_t>(const char16_t *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const char32_t>(const char32_t *__ptr)         {
            return __ptr == 0;
        }
        template <typename _Type> inline bool __is_null_pointer(_Type)         {
            return false;
        }
        template<> inline bool __is_null_pointer<char *>(char *)        template<> inline bool __is_null_pointer<wchar_t *>(wchar_t *)        template<> inline bool __is_null_pointer<const char *>(const char *)        template<> inline bool __is_null_pointer<const wchar_t *>(const wchar_t *)        template<> inline bool __is_null_pointer<const char16_t *>(const char16_t *)        template<> inline bool __is_null_pointer<const char32_t *>(const char32_t *)        inline bool __is_null_pointer(std::nullptr_t)         {
            return true;
        }
        template <typename _Tp, bool = std::__is_integer<_Tp>::__value> struct __promote {
            typedef double __type;
        };
        template <typename _Tp> struct __promote<_Tp, false> {
        };
        template<> struct __promote<long double> {
            typedef long double __type;
        };
        template<> struct __promote<double> {
            typedef double __type;
        };
        template<> struct __promote<float> {
            typedef float __type;
        };
        template <typename _Tp, typename _Up, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type> struct __promote_2 {
            typedef typeof (_Tp2() + _Up2()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type> struct __promote_3 {
            typedef typeof (_Tp2() + _Up2() + _Vp2()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type, typename _Wp2 = typename __promote<_Wp>::__type> struct __promote_4 {
            typedef typeof (_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
        };
    }
}
namespace __gnu_cxx {
    template <typename _Value> struct __numeric_traits_integer {
        static const _Value __min = (((_Value)(-1) < 0) ? -(((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0) - 1 : (_Value)0);
        static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);
        static const bool __is_signed = ((_Value)(-1) < 0);
        static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };
template<> struct __numeric_traits_integer<int> {
        static const int __min = (((int)(-1) < 0) ? -(((int)(-1) < 0) ? (((((int)1 << ((sizeof(int) * 8 - ((int)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(int)0) - 1 : (int)0);
        static const int __max = (((int)(-1) < 0) ? (((((int)1 << ((sizeof(int) * 8 - ((int)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(int)0);
        static const bool __is_signed = ((int)(-1) < 0);
        static const int __digits = (sizeof(int) * 8 - ((int)(-1) < 0));
    };
template<> struct __numeric_traits_integer<unsigned long> {
        static const unsigned long __min = (((unsigned long)(-1) < 0) ? -(((unsigned long)(-1) < 0) ? (((((unsigned long)1 << ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned long)0) - 1 : (unsigned long)0);
        static const unsigned long __max = (((unsigned long)(-1) < 0) ? (((((unsigned long)1 << ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned long)0);
        static const bool __is_signed = ((unsigned long)(-1) < 0);
        static const int __digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
    };
template<> struct __numeric_traits_integer<char> {
        static const char __min = (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0);
        static const char __max = (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0);
        static const bool __is_signed = ((char)(-1) < 0);
        static const int __digits = (sizeof(char) * 8 - ((char)(-1) < 0));
    };
template<> struct __numeric_traits_integer<short> {
        static const short __min = (((short)(-1) < 0) ? -(((short)(-1) < 0) ? (((((short)1 << ((sizeof(short) * 8 - ((short)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(short)0) - 1 : (short)0);
        static const short __max = (((short)(-1) < 0) ? (((((short)1 << ((sizeof(short) * 8 - ((short)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(short)0);
        static const bool __is_signed = ((short)(-1) < 0);
        static const int __digits = (sizeof(short) * 8 - ((short)(-1) < 0));
    };
template<> struct __numeric_traits_integer<long> {
        static const long __min = (((long)(-1) < 0) ? -(((long)(-1) < 0) ? (((((long)1 << ((sizeof(long) * 8 - ((long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(long)0) - 1 : (long)0);
        static const long __max = (((long)(-1) < 0) ? (((((long)1 << ((sizeof(long) * 8 - ((long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(long)0);
        static const bool __is_signed = ((long)(-1) < 0);
        static const int __digits = (sizeof(long) * 8 - ((long)(-1) < 0));
    };
    const _Value __min;
    const _Value __max;
    const bool __is_signed;
    const int __digits;
    template <typename _Value> struct __numeric_traits_floating {
        static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<float> {
        static const int __max_digits10 = (2 + (std::__are_same<float, float>::__value ? 24 : std::__are_same<float, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<float, float>::__value ? 6 : std::__are_same<float, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<float, float>::__value ? 38 : std::__are_same<float, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<double> {
        static const int __max_digits10 = (2 + (std::__are_same<double, float>::__value ? 24 : std::__are_same<double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<double, float>::__value ? 6 : std::__are_same<double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<double, float>::__value ? 38 : std::__are_same<double, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<long double> {
        static const int __max_digits10 = (2 + (std::__are_same<long double, float>::__value ? 24 : std::__are_same<long double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<long double, float>::__value ? 6 : std::__are_same<long double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<long double, float>::__value ? 38 : std::__are_same<long double, double>::__value ? 308 : 4932);
    };
    const int __max_digits10;
    const bool __is_signed;
    const int __digits10;
    const int __max_exponent10;
    template <typename _Value> struct __numeric_traits : public __conditional_type<std::__is_integer<_Value>::__value, __numeric_traits_integer<_Value>, __numeric_traits_floating<_Value>>::__type {
    };
template<> struct __numeric_traits<int> : public __conditional_type<std::__is_integer<int>::__value, __numeric_traits_integer<int>, __numeric_traits_floating<int>>::__type {
    };
template<> struct __numeric_traits<float> : public __conditional_type<std::__is_integer<float>::__value, __numeric_traits_integer<float>, __numeric_traits_floating<float>>::__type {
    };
template<> struct __numeric_traits<double> : public __conditional_type<std::__is_integer<double>::__value, __numeric_traits_integer<double>, __numeric_traits_floating<double>>::__type {
    };
template<> struct __numeric_traits<long double> : public __conditional_type<std::__is_integer<long double>::__value, __numeric_traits_integer<long double>, __numeric_traits_floating<long double>>::__type {
    };
template<> struct __numeric_traits<unsigned long> : public __conditional_type<std::__is_integer<unsigned long>::__value, __numeric_traits_integer<unsigned long>, __numeric_traits_floating<unsigned long>>::__type {
    };
template<> struct __numeric_traits<char> : public __conditional_type<std::__is_integer<char>::__value, __numeric_traits_integer<char>, __numeric_traits_floating<char>>::__type {
    };
template<> struct __numeric_traits<short> : public __conditional_type<std::__is_integer<short>::__value, __numeric_traits_integer<short>, __numeric_traits_floating<short>>::__type {
    };
template<> struct __numeric_traits<long> : public __conditional_type<std::__is_integer<long>::__value, __numeric_traits_integer<long>, __numeric_traits_floating<long>>::__type {
    };
    const int __max;
    const int __min;
    const int __max_exponent10;
    const int __max_exponent10;
    const int __max_exponent10;
    const int __digits;
    const char __max;
    const short __min;
    const short __max;
    const long __max;
    const long __min;
}
namespace std {
    struct piecewise_construct_t {
        explicit piecewise_construct_t() noexcept = default
    };
    constexpr std::piecewise_construct_t piecewise_construct = std::piecewise_construct_t();
    template <typename ...> class tuple;
    template <std::size_t ...> struct _Index_tuple;
    template <bool, typename _T1, typename _T2> struct _PCC {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair()         {
            return __and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, const _U2 &>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair()         {
            return __and_<is_convertible<const _U1 &, _T1>, is_convertible<const _U2 &, _T2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair()         {
            return __and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, _U2 &&>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair()         {
            return __and_<is_convertible<_U1 &&, _T1>, is_convertible<_U2 &&, _T2>>::value;
        }
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _CopyMovePair()         {
            using __do_converts = __and_<is_convertible<const _U1 &, _T1>, is_convertible<_U2 &&, _T2>>;
            using __converts = typename conditional<__implicit, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, _U2 &&>, __converts>::value;
        }
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _MoveCopyPair()         {
            using __do_converts = __and_<is_convertible<_U1 &&, _T1>, is_convertible<const _U2 &, _T2>>;
            using __converts = typename conditional<__implicit, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, const _U2 &&>, __converts>::value;
        }
    };
template<> struct _PCC<true, bool, unsigned long> {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair();
        template<> static constexpr bool _ConstructiblePair<bool, unsigned long>()         {
            return __and_<is_constructible<bool, const bool &>, is_constructible<unsigned long, const unsigned long &>>::value;
        }
;
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair();
        template<> static constexpr bool _ImplicitlyConvertiblePair<bool, unsigned long>()         {
            return __and_<is_convertible<const bool &, bool>, is_convertible<const unsigned long &, unsigned long>>::value;
        }
;
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair();
        template<> static constexpr bool _MoveConstructiblePair<bool, unsigned long>()         {
            return __and_<is_constructible<bool, bool &&>, is_constructible<unsigned long, unsigned long &&>>::value;
        }
;
        template<> static constexpr bool _MoveConstructiblePair<bool, int>()         {
            return __and_<is_constructible<bool, bool &&>, is_constructible<unsigned long, int &&>>::value;
        }
;
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair();
        template<> static constexpr bool _ImplicitlyMoveConvertiblePair<bool, unsigned long>()         {
            return __and_<is_convertible<bool &&, bool>, is_convertible<unsigned long &&, unsigned long>>::value;
        }
;
        template<> static constexpr bool _ImplicitlyMoveConvertiblePair<bool, int>()         {
            return __and_<is_convertible<bool &&, bool>, is_convertible<int &&, unsigned long>>::value;
        }
;
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _CopyMovePair();
        template<> static constexpr bool _CopyMovePair<true, bool, unsigned long>()         {
            using __do_converts = __and_<is_convertible<const bool &, bool>, is_convertible<unsigned long &&, unsigned long>>;
            using __converts = typename conditional<true, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<bool, const bool &>, is_constructible<unsigned long, unsigned long &&>, __converts>::value;
        }
;
        template<> static constexpr bool _CopyMovePair<false, bool, unsigned long>()         {
            using __do_converts = __and_<is_convertible<const bool &, bool>, is_convertible<unsigned long &&, unsigned long>>;
            using __converts = typename conditional<false, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<bool, const bool &>, is_constructible<unsigned long, unsigned long &&>, __converts>::value;
        }
;
        template<> static constexpr bool _CopyMovePair<true, bool, int>()         {
            using __do_converts = __and_<is_convertible<const bool &, bool>, is_convertible<int &&, unsigned long>>;
            using __converts = typename conditional<true, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<bool, const bool &>, is_constructible<unsigned long, int &&>, __converts>::value;
        }
;
        template<> static constexpr bool _CopyMovePair<false, bool, int>()         {
            using __do_converts = __and_<is_convertible<const bool &, bool>, is_convertible<int &&, unsigned long>>;
            using __converts = typename conditional<false, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<bool, const bool &>, is_constructible<unsigned long, int &&>, __converts>::value;
        }
;
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _MoveCopyPair();
        template<> static constexpr bool _MoveCopyPair<true, bool, unsigned long>()         {
            using __do_converts = __and_<is_convertible<bool &&, bool>, is_convertible<const unsigned long &, unsigned long>>;
            using __converts = typename conditional<true, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<bool, bool &&>, is_constructible<unsigned long, const unsigned long &&>, __converts>::value;
        }
;
        template<> static constexpr bool _MoveCopyPair<false, bool, unsigned long>()         {
            using __do_converts = __and_<is_convertible<bool &&, bool>, is_convertible<const unsigned long &, unsigned long>>;
            using __converts = typename conditional<false, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<bool, bool &&>, is_constructible<unsigned long, const unsigned long &&>, __converts>::value;
        }
;
    };
template<> struct _PCC<true, const int, int> {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair();
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair();
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair();
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair();
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _CopyMovePair();
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _MoveCopyPair();
    };
    template <typename _T1, typename _T2> struct _PCC<false, _T1, _T2> {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair()         {
            return false;
        }
    };
    template <typename _U1, typename _U2> class __pair_base {
        friend template <typename _T1, typename _T2> struct pair;
        __pair_base<_U1, _U2>() = default
        ~__pair_base<_U1, _U2>() = default
        __pair_base<_U1, _U2>(const __pair_base<_U1, _U2> &) = default
        __pair_base<_U1, _U2> &operator=(const __pair_base<_U1, _U2> &) = delete
    };
template<> class __pair_base<bool, unsigned long> {
        friend template <typename _T1, typename _T2> struct pair;
        __pair_base() noexcept = default        ~__pair_base<bool, unsigned long>() noexcept = default
        __pair_base(const std::__pair_base<bool, unsigned long> &) = default
        std::__pair_base<bool, unsigned long> &operator=(const std::__pair_base<bool, unsigned long> &) = delete
    };
template<> class __pair_base<const int, int> {
        friend template <typename _T1, typename _T2> struct pair;
        __pair_base() = default
        ~__pair_base<const int, int>() = default
        __pair_base(const std::__pair_base<const int, int> &) = default
        std::__pair_base<const int, int> &operator=(const std::__pair_base<const int, int> &) = delete
    };
    template <typename _T1, typename _T2> struct pair : private __pair_base<_T1, _T2> {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>::value, bool>::type = true> constexpr pair<_T1, _T2>() : first(), second()         {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>>>::value, bool>::type = false> constexpr explicit pair<_T1, _T2>() : first(), second()         {
        }
        using _PCCP = _PCC<true, _T1, _T2>;
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b)         {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b)         {
        }
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<_T1, _U1>::value || !is_same<_T2, _U2>::value, _T1, _T2>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)         {
        }
        pair<_T1, _T2>(const pair<_T1, _T2> &) = default
        pair<_T1, _T2>(pair<_T1, _T2> &&) = default
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<true, _U1, _T2>(), bool>::type = true> constexpr pair<_T1, _T2>(_U1 &&__x, const _T2 &__y) : first(std::forward<_U1>(__x)), second(__y)         {
        }
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<false, _U1, _T2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, const _T2 &__y) : first(std::forward<_U1>(__x)), second(__y)         {
        }
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<true, _T1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward<_U2>(__y))         {
        }
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<false, _T1, _U2>(), bool>::type = false> explicit pair<_T1, _T2>(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))         {
        }
        template <typename ..._Args1, typename ..._Args2> pair<_T1, _T2>(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        pair<_T1, _T2> &operator=(typename conditional<__and_<is_copy_assignable<_T1>, is_copy_assignable<_T2>>::value, const pair<_T1, _T2> &, const __nonesuch &>::type __p)         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        pair<_T1, _T2> &operator=(typename conditional<__and_<is_move_assignable<_T1>, is_move_assignable<_T2>>::value, pair<_T1, _T2> &&, __nonesuch &&>::type __p) noexcept(__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2>>::valueoperator=(typename conditional<__and_<is_move_assignable<_T1>, is_move_assignable<_T2>>::value, pair<_T1, _T2> &&, __nonesuch &&>::type __p) noexcept(__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2>>::value)         {
            this->first = std::forward<std::pair::first_type>(__p.first);
            this->second = std::forward<std::pair::second_type>(__p.second);
            return *this;
        }
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<_T1 &, const _U1 &>, is_assignable<_T2 &, const _U2 &>>::value, pair<_T1, _T2> &>::type operator=(const pair<_U1, _U2> &__p)         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<_T1 &, _U1 &&>, is_assignable<_T2 &, _U2 &&>>::value, pair<_T1, _T2> &>::type operator=(pair<_U1, _U2> &&__p)         {
            this->first = std::forward<_U1>(__p.first);
            this->second = std::forward<_U2>(__p.second);
            return *this;
        }
        void swap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::valueswap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value)         {
            using std::swap;
            swap(this->first, __p.first);
            swap(this->second, __p.second);
        }
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> pair<_T1, _T2>(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    };
template<> struct pair<bool, unsigned long> : private __pair_base<bool, unsigned long> {
        typedef bool first_type;
        typedef unsigned long second_type;
        bool first;
        unsigned long second;
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>::value, bool>::type = true> constexpr pair();
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>>>::value, bool>::type = false> constexpr explicit pair();
        using _PCCP = _PCC<true, bool, unsigned long>;
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const bool &__a, const unsigned long &__b);
        template<> constexpr pair<bool, unsigned long, true>(const bool &__a, const unsigned long &__b);
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const bool &__a, const unsigned long &__b);
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<bool, _U1>::value || !is_same<unsigned long, _U2>::value, bool, unsigned long>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const pair<_U1, _U2> &__p);
        pair(const std::pair<bool, unsigned long> &) = default
        pair(std::pair<bool, unsigned long> &&) = default
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<true, _U1, unsigned long>(), bool>::type = true> constexpr pair(_U1 &&__x, const unsigned long &__y);
        template<> constexpr pair<bool, true>(bool &&__x, const unsigned long &__y);
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<false, _U1, unsigned long>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, const unsigned long &__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<true, bool, _U2>(), bool>::type = true> constexpr pair(const bool &__x, _U2 &&__y);
        template<> constexpr pair<unsigned long, true>(const bool &__x, unsigned long &&__y);
        template<> constexpr pair<int, true>(const bool &__x, int &&__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<false, bool, _U2>(), bool>::type = false> explicit pair(const bool &__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(_U1 &&__x, _U2 &&__y);
        template<> constexpr pair<bool, unsigned long, true>(bool &&__x, unsigned long &&__y) : __pair_base<bool, unsigned long>(), first(std::forward<bool>(__x)), second(std::forward<unsigned long>(__y))         {
        }
;
        template<> constexpr pair<bool, int, true>(bool &&__x, int &&__y) : __pair_base<bool, unsigned long>(), first(std::forward<bool>(__x)), second(std::forward<int>(__y))         {
        }
;
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(pair<_U1, _U2> &&__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(pair<_U1, _U2> &&__p);
        template <typename ..._Args1, typename ..._Args2> pair(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        std::pair<bool, unsigned long> &operator=(typename conditional<__and_<is_copy_assignable<bool>, is_copy_assignable<unsigned long>>::value, const pair<bool, unsigned long> &, const __nonesuch &>::type __p);
        std::pair<bool, unsigned long> &operator=(typename conditional<__and_<is_move_assignable<bool>, is_move_assignable<unsigned long>>::value, pair<bool, unsigned long> &&, __nonesuch &&>::type __p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<bool &, const _U1 &>, is_assignable<unsigned long &, const _U2 &>>::value, pair<bool, unsigned long> &>::type operator=(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<bool &, _U1 &&>, is_assignable<unsigned long &, _U2 &&>>::value, pair<bool, unsigned long> &>::type operator=(pair<_U1, _U2> &&__p);
        void swap(std::pair<bool, unsigned long> &__p);
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> pair(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    };
template<> struct pair<const int, int> : private __pair_base<const int, int> {
        typedef const int first_type;
        typedef int second_type;
        const int first;
        int second;
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>::value, bool>::type = true> constexpr pair();
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>>>::value, bool>::type = false> constexpr explicit pair();
        using _PCCP = _PCC<true, const int, int>;
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const int &__a, const int &__b);
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const int &__a, const int &__b);
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<const int, _U1>::value || !is_same<int, _U2>::value, const int, int>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const pair<_U1, _U2> &__p);
        pair(const std::pair<const int, int> &) = default
        pair(std::pair<const int, int> &&) = default
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<true, _U1, int>(), bool>::type = true> constexpr pair(_U1 &&__x, const int &__y);
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<false, _U1, int>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, const int &__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<true, const int, _U2>(), bool>::type = true> constexpr pair(const int &__x, _U2 &&__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<false, const int, _U2>(), bool>::type = false> explicit pair(const int &__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(_U1 &&__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(pair<_U1, _U2> &&__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(pair<_U1, _U2> &&__p);
        template <typename ..._Args1, typename ..._Args2> pair(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        std::pair<const int, int> &operator=(typename conditional<__and_<is_copy_assignable<const int>, is_copy_assignable<int>>::value, const pair<const int, int> &, const __nonesuch &>::type __p);
        std::pair<const int, int> &operator=(typename conditional<__and_<is_move_assignable<const int>, is_move_assignable<int>>::value, pair<const int, int> &&, __nonesuch &&>::type __p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<const int &, const _U1 &>, is_assignable<int &, const _U2 &>>::value, pair<const int, int> &>::type operator=(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<const int &, _U1 &&>, is_assignable<int &, _U2 &&>>::value, pair<const int, int> &>::type operator=(pair<_U1, _U2> &&__p);
        void swap(std::pair<const int, int> &__p);
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> pair(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    };
    template <typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
    template <typename _T1, typename _T2> inline constexpr bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first == __y.first && __x.second == __y.second;
    }
    template <typename _T1, typename _T2> inline constexpr bool operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__x == __y);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __y < __x;
    }
    template <typename _T1, typename _T2> inline constexpr bool operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__y < __x);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__x < __y);
    }
    template <typename _T1, typename _T2> inline typename enable_if<__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y))swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)))     {
        __x.swap(__y);
    }
    template <typename _T1, typename _T2> typename enable_if<!__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete
    template <typename _T1, typename _T2> constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y)     {
        typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        typedef pair<__ds_type1, __ds_type2> __pair_type;
        return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
}
namespace std {
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : public std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : public std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : public std::bidirectional_iterator_tag {
    };
    template <typename _Category, typename _Tp, typename _Distance = std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp &> struct iterator {
        typedef _Category iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef _Pointer pointer;
        typedef _Reference reference;
    };
template<> struct iterator<std::output_iterator_tag, void, void, void, void> {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
    };
    template <typename _Iterator> struct iterator_traits
template<> struct iterator_traits<char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef char &reference;
    }
template<> struct iterator_traits<const char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char *pointer;
        typedef const char &reference;
    }
template<> struct iterator_traits<wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef wchar_t &reference;
    }
template<> struct iterator_traits<const wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const wchar_t *pointer;
        typedef const wchar_t &reference;
    }
template<> struct iterator_traits<const char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char16_t *pointer;
        typedef const char16_t &reference;
    }
template<> struct iterator_traits<char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef char16_t &reference;
    }
template<> struct iterator_traits<const char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char32_t *pointer;
        typedef const char32_t &reference;
    }
template<> struct iterator_traits<char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef char32_t &reference;
    };
    template <typename _Iterator, typename = __void_t<>> struct __iterator_traits {
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, __void_t<typename _Iterator::iterator_category, typename _Iterator::value_type, typename _Iterator::difference_type, typename _Iterator::pointer, typename _Iterator::reference>> {
        typedef typename _Iterator::iterator_category iterator_category;
        typedef typename _Iterator::value_type value_type;
        typedef typename _Iterator::difference_type difference_type;
        typedef typename _Iterator::pointer pointer;
        typedef typename _Iterator::reference reference;
    };
    template <typename _Iterator> struct iterator_traits : public __iterator_traits<_Iterator> {
    };
template<> struct iterator_traits<char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef char &reference;
    };
template<> struct iterator_traits<const char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char *pointer;
        typedef const char &reference;
    };
template<> struct iterator_traits<wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef wchar_t &reference;
    };
template<> struct iterator_traits<const wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const wchar_t *pointer;
        typedef const wchar_t &reference;
    };
template<> struct iterator_traits<const char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char16_t *pointer;
        typedef const char16_t &reference;
    };
template<> struct iterator_traits<char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef char16_t &reference;
    };
template<> struct iterator_traits<const char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char32_t *pointer;
        typedef const char32_t &reference;
    };
template<> struct iterator_traits<char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef char32_t &reference;
    };
    template <typename _Tp> struct iterator_traits<_Tp *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef _Tp &reference;
    };
    template <typename _Tp> struct iterator_traits<const _Tp *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const _Tp *pointer;
        typedef const _Tp &reference;
    };
    template <typename _Iter> inline constexpr typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)     {
        return typename iterator_traits<_Iter>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<char *>::iterator_category __iterator_category<char *>(char *const &)     {
        return typename iterator_traits<char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::iterator_category __iterator_category<wchar_t *>(wchar_t *const &)     {
        return typename iterator_traits<wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char *>::iterator_category __iterator_category<const char *>(const char *const &)     {
        return typename iterator_traits<const char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::iterator_category __iterator_category<const wchar_t *>(const wchar_t *const &)     {
        return typename iterator_traits<const wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::iterator_category __iterator_category<const char16_t *>(const char16_t *const &)     {
        return typename iterator_traits<const char16_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::iterator_category __iterator_category<const char32_t *>(const char32_t *const &)     {
        return typename iterator_traits<const char32_t *>::iterator_category();
    }
    template <typename _Iter> using __iterator_category_t = typename iterator_traits<_Iter>::iterator_category;
    template <typename _InIter> using _RequireInputIter = __enable_if_t<is_convertible<__iterator_category_t<_InIter>, input_iterator_tag>::value>;
    template <typename _It, typename _Cat = __iterator_category_t<_It>> struct __is_random_access_iter : is_base_of<std::random_access_iterator_tag, _Cat> {
        typedef is_base_of<std::random_access_iterator_tag, _Cat> _Base;
        enum  {
            __value = _Base::value
        };
    };
}
namespace std {
    template <typename> struct _List_iterator;
    template <typename> struct _List_const_iterator;
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        while (__first != __last)
            {
                ++__first;
                ++__n;
            }
        return __n;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, std::input_iterator_tag)    template <typename _RandomAccessIterator> inline constexpr typename iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>, std::input_iterator_tag);
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_const_iterator<_Tp>, std::_List_const_iterator<_Tp>, std::input_iterator_tag);
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type distance<char *>(char *__first, char *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type distance<wchar_t *>(wchar_t *__first, wchar_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const char *>::difference_type distance<const char *>(const char *__first, const char *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type distance<const char16_t *>(const char16_t *__first, const char16_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type distance<const char32_t *>(const char32_t *__first, const char32_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void __advance(_InputIterator &__i, _Distance __n, std::input_iterator_tag)     {
        ;
        while (__n--)
            ++__i;
    }
    template <typename _BidirectionalIterator, typename _Distance> inline constexpr void __advance(_BidirectionalIterator &__i, _Distance __n, std::bidirectional_iterator_tag)     {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }
    template <typename _RandomAccessIterator, typename _Distance> inline constexpr void __advance(_RandomAccessIterator &__i, _Distance __n, std::random_access_iterator_tag)     {
        if (__builtin_constant_p(__n) && __n == 1)
            ++__i;
        else if (__builtin_constant_p(__n) && __n == -1)
            --__i;
        else
            __i += __n;
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void advance(_InputIterator &__i, _Distance __n)     {
        typename iterator_traits<_InputIterator>::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }
    template <typename _InputIterator> inline constexpr _InputIterator next(_InputIterator __x, typename iterator_traits<_InputIterator>::difference_type __n = 1)     {
        std::advance(__x, __n);
        return __x;
    }
    template <typename _BidirectionalIterator> inline constexpr _BidirectionalIterator prev(_BidirectionalIterator __x, typename iterator_traits<_BidirectionalIterator>::difference_type __n = 1)     {
        std::advance(__x, -__n);
        return __x;
    }
}
namespace std {
    class __undefined;
    template <typename _Tp> struct __get_first_arg {
        using type = std::__undefined;
    };
    template <template <typename, typename ...> class _Template, typename _Tp, typename ..._Types> struct __get_first_arg<_Template<_Tp, _Types...>> {
        using type = _Tp;
    };
    template <typename _Tp> using __get_first_arg_t = typename __get_first_arg<_Tp>::type;
    template <typename _Tp, typename _Up> struct __replace_first_arg {
    };
    template <template <typename, typename ...> class _Template, typename _Up, typename _Tp, typename ..._Types> struct __replace_first_arg<_Template<_Tp, _Types...>, _Up> {
        using type = _Template<_Up, _Types...>;
    };
    template <typename _Tp, typename _Up> using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;
    template <typename _Tp> using __make_not_void = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;
    template <typename _Ptr> struct pointer_traits {
    private:
        template <typename _Tp> using __element_type = typename _Tp::element_type;
        template <typename _Tp> using __difference_type = typename _Tp::difference_type;
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>> {
            using type = typename _Tp::template rebind<_Up>;
        };
    public:
        using pointer = _Ptr;
        using element_type = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;
        using difference_type = __detected_or_t<std::ptrdiff_t, __difference_type, _Ptr>;
        template <typename _Up> using rebind = typename __rebind<_Ptr, _Up>::type;
        static _Ptr pointer_to(__make_not_void<std::pointer_traits::element_type> &__e)         {
            return _Ptr::pointer_to(__e);
        }
        static_assert(!is_same<element_type, __undefined>::value, "pointer type defines element_type or is like SomePointer<T, Args>");
    };
template<> struct pointer_traits<char *> {
        typedef char *pointer;
        typedef char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<char *>::pointer pointer_to(__make_not_void<std::pointer_traits<char *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const char *> {
        typedef const char *pointer;
        typedef const char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const char *>::pointer pointer_to(__make_not_void<std::pointer_traits<const char *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<wchar_t *> {
        typedef wchar_t *pointer;
        typedef wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<wchar_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<wchar_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const wchar_t *> {
        typedef const wchar_t *pointer;
        typedef const wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const wchar_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<const wchar_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<char16_t *> {
        typedef char16_t *pointer;
        typedef char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<char16_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<char16_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const char16_t *> {
        typedef const char16_t *pointer;
        typedef const char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const char16_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<const char16_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<char32_t *> {
        typedef char32_t *pointer;
        typedef char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<char32_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<char32_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const char32_t *> {
        typedef const char32_t *pointer;
        typedef const char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const char32_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<const char32_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
    template <typename _Tp> struct pointer_traits<_Tp *> {
        typedef _Tp *pointer;
        typedef _Tp element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<type-parameter-0-0 *>::pointer pointer_to(__make_not_void<std::pointer_traits<type-parameter-0-0 *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Tp> using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
    template <typename _Tp> constexpr _Tp *__to_address(_Tp *__ptr) noexcept     {
        static_assert(!std::is_function<_Tp>::value, "not a function pointer");
        return __ptr;
    }
    template <typename _Ptr> constexpr typename std::pointer_traits<_Ptr>::element_type *__to_address(const _Ptr &__ptr)     {
        return std::__to_address(__ptr.operator->());
    }
}
namespace std {
    template <typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference> {
    protected:
        _Iterator current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::pointer pointer;
        typedef typename __traits_type::reference reference;
        constexpr reverse_iterator<_Iterator>() : current()         {
        }
        constexpr explicit reverse_iterator<_Iterator>(std::reverse_iterator::iterator_type __x) : current(__x)         {
        }
        constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) : current(__x.current)         {
        }
        reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iterator> &) = default
        template <typename _Iter> constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) : current(__x.base())         {
        }
        constexpr std::reverse_iterator::iterator_type base() const         {
            return this->current;
        }
        constexpr std::reverse_iterator::reference operator*() const         {
            _Iterator __tmp = this->current;
            return *--__tmp;
        }
        constexpr std::reverse_iterator::pointer operator->() const         {
            _Iterator __tmp = this->current;
            --__tmp;
            return _S_to_pointer(__tmp);
        }
        constexpr reverse_iterator<_Iterator> &operator++()         {
            --this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator++(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            --this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> &operator--()         {
            ++this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator--(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            ++this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> operator+(std::reverse_iterator::difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current - __n);
        }
        constexpr reverse_iterator<_Iterator> &operator+=(std::reverse_iterator::difference_type __n)         {
            this->current -= __n;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator-(std::reverse_iterator::difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current + __n);
        }
        constexpr reverse_iterator<_Iterator> &operator-=(std::reverse_iterator::difference_type __n)         {
            this->current += __n;
            return *this;
        }
        constexpr std::reverse_iterator::reference operator[](std::reverse_iterator::difference_type __n) const         {
            return *(*this + __n);
        }
    private:
        template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p)         {
            return __p;
        }
        template <typename _Tp> static constexpr std::reverse_iterator::pointer _S_to_pointer(_Tp __t)         {
            return __t.operator->();
        }
    };
    template <typename _Iterator> inline constexpr bool operator==(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _Iterator> inline constexpr bool operator<(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __y.base() < __x.base();
    }
    template <typename _Iterator> inline constexpr bool operator!=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__x == __y);
    }
    template <typename _Iterator> inline constexpr bool operator>(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __y < __x;
    }
    template <typename _Iterator> inline constexpr bool operator<=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__y < __x);
    }
    template <typename _Iterator> inline constexpr bool operator>=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator==(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y.base() < __x.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator!=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__x == __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base())     {
        return __y.base() - __x.base();
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> operator+(typename reverse_iterator<_Iterator>::difference_type __n, const reverse_iterator<_Iterator> &__x)     {
        return reverse_iterator<_Iterator>(__x.base() - __n);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> __make_reverse_iterator(_Iterator __i)     {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> make_reverse_iterator(_Iterator __i)     {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> auto __niter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__niter_base(__it.base())))     {
        return __make_reverse_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<reverse_iterator<_Iterator>> : __is_move_iterator<_Iterator> {
    };
    template <typename _Iterator> auto __miter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__miter_base(__it.base())))     {
        return __make_reverse_iterator(__miter_base(__it.base()));
    }
    template <typename _Container> class back_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_back(__value);
            return *this;
        }
        back_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_back(std::move(__value));
            return *this;
        }
        back_insert_iterator<_Container> &operator*()         {
            return *this;
        }
        back_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        back_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline back_insert_iterator<_Container> back_inserter(_Container &__x)     {
        return back_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class front_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_front(__value);
            return *this;
        }
        front_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_front(std::move(__value));
            return *this;
        }
        front_insert_iterator<_Container> &operator*()         {
            return *this;
        }
        front_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        front_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline front_insert_iterator<_Container> front_inserter(_Container &__x)     {
        return front_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
        typedef typename _Container::iterator _Iter;
    protected:
        _Container *container;
        std::insert_iterator::_Iter iter;
    public:
        typedef _Container container_type;
        insert_iterator<_Container>(_Container &__x, std::insert_iterator::_Iter __i) : container(std::__addressof(__x)), iter(__i)         {
        }
        insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->iter = this->container->insert(this->iter, __value);
            ++this->iter;
            return *this;
        }
        insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->iter = this->container->insert(this->iter, std::move(__value));
            ++this->iter;
            return *this;
        }
        insert_iterator<_Container> &operator*()         {
            return *this;
        }
        insert_iterator<_Container> &operator++()         {
            return *this;
        }
        insert_iterator<_Container> &operator++(int)         {
            return *this;
        }
    };
    template <typename _Container, typename _Iterator> inline insert_iterator<_Container> inserter(_Container &__x, _Iterator __i)     {
        return insert_iterator<_Container>(__x, typename _Container::iterator(__i));
    }
}
namespace __gnu_cxx {
    template <typename _Iterator, typename _Container> class __normal_iterator {
    protected:
        _Iterator _M_current;
        typedef std::iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator<_Iterator, _Container>() noexcept : _M_current(_Iterator())         {
        }
        explicit __normal_iterator<_Iterator, _Container>(const _Iterator &__i) noexcept : _M_current(__i)         {
        }
        template <typename _Iter> __normal_iterator<_Iterator, _Container>(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename _Container::pointer>::__value), _Container>::__type> &__i) noexcept : _M_current(__i.base())         {
        }
        __gnu_cxx::__normal_iterator::reference operator*() const noexcept         {
            return *this->_M_current;
        }
        __gnu_cxx::__normal_iterator::pointer operator->() const noexcept         {
            return this->_M_current;
        }
        __normal_iterator<_Iterator, _Container> &operator++() noexcept         {
            ++this->_M_current;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator++(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current++);
        }
        __normal_iterator<_Iterator, _Container> &operator--() noexcept         {
            --this->_M_current;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator--(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current--);
        }
        __gnu_cxx::__normal_iterator::reference operator[](__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return this->_M_current[__n];
        }
        __normal_iterator<_Iterator, _Container> &operator+=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current += __n;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator+(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current + __n);
        }
        __normal_iterator<_Iterator, _Container> &operator-=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current -= __n;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator-(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current - __n);
        }
        const _Iterator &base() const noexcept         {
            return this->_M_current;
        }
    };
template<> class __normal_iterator<char *, std::__cxx11::basic_string<char>> {
    protected:
        char *_M_current;
        typedef std::iterator_traits<char *> __traits_type;
    public:
        typedef char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::reference operator[](__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> &operator+=(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> operator+(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> &operator-=(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>> operator-(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char>>::difference_type __n) const noexcept;
        char *const &base() const noexcept;
    };
template<> class __normal_iterator<const char *, std::__cxx11::basic_string<char>> {
    protected:
        const char *_M_current;
        typedef std::iterator_traits<const char *> __traits_type;
    public:
        typedef const char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::reference operator[](__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> &operator+=(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> operator+(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> &operator-=(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>> operator-(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char>>::difference_type __n) const noexcept;
        const char *const &base() const noexcept;
    };
template<> class __normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> {
    protected:
        wchar_t *_M_current;
        typedef std::iterator_traits<wchar_t *> __traits_type;
    public:
        typedef wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(wchar_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<wchar_t>::pointer>::__value), basic_string<wchar_t>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::reference operator[](__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator+=(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> operator+(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator-=(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> operator-(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) const noexcept;
        wchar_t *const &base() const noexcept;
    };
template<> class __normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> {
    protected:
        const wchar_t *_M_current;
        typedef std::iterator_traits<const wchar_t *> __traits_type;
    public:
        typedef const wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const wchar_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<wchar_t>::pointer>::__value), basic_string<wchar_t>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::reference operator[](__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator+=(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> operator+(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> &operator-=(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> operator-(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>>::difference_type __n) const noexcept;
        const wchar_t *const &base() const noexcept;
    };
template<> class __normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> {
    protected:
        char16_t *_M_current;
        typedef std::iterator_traits<char16_t *> __traits_type;
    public:
        typedef char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char16_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::pointer>::__value), basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::reference operator[](__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator+=(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator+(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator-=(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator-(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) const noexcept;
        char16_t *const &base() const noexcept;
    };
template<> class __normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> {
    protected:
        const char16_t *_M_current;
        typedef std::iterator_traits<const char16_t *> __traits_type;
    public:
        typedef const char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char16_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::pointer>::__value), basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::reference operator[](__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator+=(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator+(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> &operator-=(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> operator-(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>>::difference_type __n) const noexcept;
        const char16_t *const &base() const noexcept;
    };
template<> class __normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> {
    protected:
        char32_t *_M_current;
        typedef std::iterator_traits<char32_t *> __traits_type;
    public:
        typedef char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char32_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::pointer>::__value), basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::reference operator[](__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator+=(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator+(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator-=(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator-(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) const noexcept;
        char32_t *const &base() const noexcept;
    };
template<> class __normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> {
    protected:
        const char32_t *_M_current;
        typedef std::iterator_traits<const char32_t *> __traits_type;
    public:
        typedef const char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char32_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::pointer>::__value), basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::reference operator[](__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator+=(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator+(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> &operator-=(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> operator-(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>>::difference_type __n) const noexcept;
        const char32_t *const &base() const noexcept;
    };
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() == __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator==(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() == __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator!=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() != __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator!=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() != __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() < __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator<(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() < __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() > __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator>(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() > __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() <= __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator<=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() <= __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() >= __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator>=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() >= __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline auto operator-(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base())     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline typename __normal_iterator<_Iterator, _Container>::difference_type operator-(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline __normal_iterator<_Iterator, _Container> operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n, const __normal_iterator<_Iterator, _Container> &__i) noexcept     {
        return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
    }
}
namespace std {
    template <typename _Iterator, typename _Container> _Iterator __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it.base();
    }
    template <typename _Iterator> class move_iterator {
        _Iterator _M_current;
        using __traits_type = iterator_traits<_Iterator>;
        using __base_ref = typename __traits_type::reference;
    public:
        using iterator_type = _Iterator;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef _Iterator pointer;
        typedef typename conditional<is_reference<__base_ref>::value, typename remove_reference<__base_ref>::type &&, __base_ref>::type reference;
        constexpr move_iterator<_Iterator>() : _M_current()         {
        }
        constexpr explicit move_iterator<_Iterator>(std::move_iterator::iterator_type __i) : _M_current(std::move(__i))         {
        }
        template <typename _Iter> constexpr move_iterator<_Iterator>(const move_iterator<_Iter> &__i) : _M_current(__i.base())         {
        }
        constexpr std::move_iterator::iterator_type base() const         {
            return this->_M_current;
        }
        constexpr std::move_iterator::reference operator*() const         {
            return static_cast<std::move_iterator::reference>(*this->_M_current);
        }
        constexpr std::move_iterator::pointer operator->() const         {
            return this->_M_current;
        }
        constexpr move_iterator<_Iterator> &operator++()         {
            ++this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator++(int)         {
            move_iterator<_Iterator> __tmp = *this;
            ++this->_M_current;
            return __tmp;
        }
        constexpr move_iterator<_Iterator> &operator--()         {
            --this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator--(int)         {
            move_iterator<_Iterator> __tmp = *this;
            --this->_M_current;
            return __tmp;
        }
        constexpr move_iterator<_Iterator> operator+(std::move_iterator::difference_type __n) const         {
            return move_iterator<_Iterator>(this->_M_current + __n);
        }
        constexpr move_iterator<_Iterator> &operator+=(std::move_iterator::difference_type __n)         {
            this->_M_current += __n;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator-(std::move_iterator::difference_type __n) const         {
            return move_iterator<_Iterator>(this->_M_current - __n);
        }
        constexpr move_iterator<_Iterator> &operator-=(std::move_iterator::difference_type __n)         {
            this->_M_current -= __n;
            return *this;
        }
        constexpr std::move_iterator::reference operator[](std::move_iterator::difference_type __n) const         {
            return std::move(this->_M_current[__n]);
        }
    };
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator==(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator!=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return !(__x == __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return !(__x < __y);
    }
    template <typename _Iterator> inline constexpr bool operator==(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _Iterator> inline constexpr bool operator!=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return !(__x == __y);
    }
    template <typename _Iterator> inline constexpr bool operator<(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return __x.base() < __y.base();
    }
    template <typename _Iterator> inline constexpr bool operator<=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return !(__y < __x);
    }
    template <typename _Iterator> inline constexpr bool operator>(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return __y < __x;
    }
    template <typename _Iterator> inline constexpr bool operator>=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base())     {
        return __x.base() - __y.base();
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> operator+(typename move_iterator<_Iterator>::difference_type __n, const move_iterator<_Iterator> &__x)     {
        return __x + __n;
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> make_move_iterator(_Iterator __i)     {
        return move_iterator<_Iterator>(std::move(__i));
    }
    template <typename _Iterator, typename _ReturnType = typename conditional<__move_if_noexcept_cond<typename iterator_traits<_Iterator>::value_type>::value, _Iterator, move_iterator<_Iterator>>::type> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Iterator __i)     {
        return _ReturnType(__i);
    }
    template <typename _Tp, typename _ReturnType = typename conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp *, move_iterator<_Tp *>>::type> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Tp *__i)     {
        return _ReturnType(__i);
    }
    template <typename _Iterator> auto __niter_base(move_iterator<_Iterator> __it) -> decltype(make_move_iterator(__niter_base(__it.base())))     {
        return make_move_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<move_iterator<_Iterator>> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Iterator> auto __miter_base(move_iterator<_Iterator> __it) -> decltype(__miter_base(__it.base()))     {
        return __miter_base(__it.base());
    }
    template <typename _InputIterator> using __iter_key_t = remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;
    template <typename _InputIterator> using __iter_val_t = typename iterator_traits<_InputIterator>::value_type::second_type;
    template <typename _T1, typename _T2> struct pair
template<> struct pair<bool, unsigned long> : private __pair_base<bool, unsigned long> {
        typedef bool first_type;
        typedef unsigned long second_type;
        bool first;
        unsigned long second;
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>::value, bool>::type = true> constexpr pair();
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>>>::value, bool>::type = false> constexpr explicit pair();
        using _PCCP = _PCC<true, bool, unsigned long>;
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const bool &__a, const unsigned long &__b);
        template<> constexpr pair<bool, unsigned long, true>(const bool &__a, const unsigned long &__b);
        template <typename _U1 = bool, typename _U2 = unsigned long, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const bool &__a, const unsigned long &__b);
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<bool, _U1>::value || !is_same<unsigned long, _U2>::value, bool, unsigned long>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const pair<_U1, _U2> &__p);
        pair(const std::pair<bool, unsigned long> &) = default
        pair(std::pair<bool, unsigned long> &&) = default
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<true, _U1, unsigned long>(), bool>::type = true> constexpr pair(_U1 &&__x, const unsigned long &__y);
        template<> constexpr pair<bool, true>(bool &&__x, const unsigned long &__y);
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<false, _U1, unsigned long>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, const unsigned long &__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<true, bool, _U2>(), bool>::type = true> constexpr pair(const bool &__x, _U2 &&__y);
        template<> constexpr pair<unsigned long, true>(const bool &__x, unsigned long &&__y);
        template<> constexpr pair<int, true>(const bool &__x, int &&__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<false, bool, _U2>(), bool>::type = false> explicit pair(const bool &__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(_U1 &&__x, _U2 &&__y);
        template<> constexpr pair<bool, unsigned long, true>(bool &&__x, unsigned long &&__y) : __pair_base<bool, unsigned long>(), first(std::forward<bool>(__x)), second(std::forward<unsigned long>(__y))         {
        }
;
        template<> constexpr pair<bool, int, true>(bool &&__x, int &&__y) : __pair_base<bool, unsigned long>(), first(std::forward<bool>(__x)), second(std::forward<int>(__y))         {
        }
;
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(pair<_U1, _U2> &&__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(pair<_U1, _U2> &&__p);
        template <typename ..._Args1, typename ..._Args2> pair(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        std::pair<bool, unsigned long> &operator=(typename conditional<__and_<is_copy_assignable<bool>, is_copy_assignable<unsigned long>>::value, const pair<bool, unsigned long> &, const __nonesuch &>::type __p);
        std::pair<bool, unsigned long> &operator=(typename conditional<__and_<is_move_assignable<bool>, is_move_assignable<unsigned long>>::value, pair<bool, unsigned long> &&, __nonesuch &&>::type __p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<bool &, const _U1 &>, is_assignable<unsigned long &, const _U2 &>>::value, pair<bool, unsigned long> &>::type operator=(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<bool &, _U1 &&>, is_assignable<unsigned long &, _U2 &&>>::value, pair<bool, unsigned long> &>::type operator=(pair<_U1, _U2> &&__p);
        void swap(std::pair<bool, unsigned long> &__p);
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> pair(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    }
template<> struct pair<const int, int> : private __pair_base<const int, int> {
        typedef const int first_type;
        typedef int second_type;
        const int first;
        int second;
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>::value, bool>::type = true> constexpr pair();
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>>>::value, bool>::type = false> constexpr explicit pair();
        using _PCCP = _PCC<true, const int, int>;
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const int &__a, const int &__b);
        template <typename _U1 = const int, typename _U2 = int, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const int &__a, const int &__b);
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<const int, _U1>::value || !is_same<int, _U2>::value, const int, int>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(const pair<_U1, _U2> &__p);
        pair(const std::pair<const int, int> &) = default
        pair(std::pair<const int, int> &&) = default
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<true, _U1, int>(), bool>::type = true> constexpr pair(_U1 &&__x, const int &__y);
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<false, _U1, int>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, const int &__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<true, const int, _U2>(), bool>::type = true> constexpr pair(const int &__x, _U2 &&__y);
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<false, const int, _U2>(), bool>::type = false> explicit pair(const int &__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(_U1 &&__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(_U1 &&__x, _U2 &&__y);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair(pair<_U1, _U2> &&__p);
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair(pair<_U1, _U2> &&__p);
        template <typename ..._Args1, typename ..._Args2> pair(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        std::pair<const int, int> &operator=(typename conditional<__and_<is_copy_assignable<const int>, is_copy_assignable<int>>::value, const pair<const int, int> &, const __nonesuch &>::type __p);
        std::pair<const int, int> &operator=(typename conditional<__and_<is_move_assignable<const int>, is_move_assignable<int>>::value, pair<const int, int> &&, __nonesuch &&>::type __p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<const int &, const _U1 &>, is_assignable<int &, const _U2 &>>::value, pair<const int, int> &>::type operator=(const pair<_U1, _U2> &__p);
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<const int &, _U1 &&>, is_assignable<int &, _U2 &&>>::value, pair<const int, int> &>::type operator=(pair<_U1, _U2> &&__p);
        void swap(std::pair<const int, int> &__p);
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> pair(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    };
    template <typename _InputIterator> using __iter_to_alloc_t = pair<add_const_t<__iter_key_t<_InputIterator>>, __iter_val_t<_InputIterator>>;
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
    template <typename _Ite, typename _Seq, typename _Cat> struct _Safe_iterator;
}
namespace __gnu_cxx {
    namespace __ops {
        struct _Iter_less_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 < *__it2;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_less_iter __iter_less_iter()         {
            return __gnu_cxx::__ops::_Iter_less_iter();
        }
        struct _Iter_less_val {
            _Iter_less_val() noexcept = default
            explicit _Iter_less_val(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it < __val;
            }
        };
        inline __gnu_cxx::__ops::_Iter_less_val __iter_less_val()         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        inline __gnu_cxx::__ops::_Iter_less_val __iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        struct _Val_less_iter {
            _Val_less_iter() noexcept = default
            explicit _Val_less_iter(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it) const             {
                return __val < *__it;
            }
        };
        inline __gnu_cxx::__ops::_Val_less_iter __val_less_iter()         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        inline __gnu_cxx::__ops::_Val_less_iter __val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        struct _Iter_equal_to_iter {
            template <typename _Iterator1, typename _Iterator2> bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 == *__it2;
            }
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter()         {
            return __gnu_cxx::__ops::_Iter_equal_to_iter();
        }
        struct _Iter_equal_to_val {
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it == __val;
            }
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val()         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter)         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        template <typename _Compare> struct _Iter_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2)             {
                return bool(this->_M_comp(*__it1, *__it2));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)         {
            return _Iter_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Iter_comp_val {
            _Compare _M_comp;
            explicit _Iter_comp_val<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            explicit _Iter_comp_val<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            explicit _Iter_comp_val<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val)             {
                return bool(this->_M_comp(*__it, __val));
            }
        };
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Iter_comp_iter<_Compare> __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Val_comp_iter {
            _Compare _M_comp;
            explicit _Val_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            explicit _Val_comp_iter<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            explicit _Val_comp_iter<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it)             {
                return bool(this->_M_comp(__val, *__it));
            }
        };
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Iter_comp_iter<_Compare> __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Value> struct _Iter_equals_val {
            _Value &_M_value;
            explicit _Iter_equals_val<_Value>(_Value &__value) : _M_value(__value)             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return *__it == this->_M_value;
            }
        };
        template <typename _Value> inline _Iter_equals_val<_Value> __iter_equals_val(_Value &__val)         {
            return _Iter_equals_val<_Value>(__val);
        }
        template <typename _Iterator1> struct _Iter_equals_iter {
            _Iterator1 _M_it1;
            explicit _Iter_equals_iter<_Iterator1>(_Iterator1 __it1) : _M_it1(__it1)             {
            }
            template <typename _Iterator2> bool operator()(_Iterator2 __it2)             {
                return *__it2 == *this->_M_it1;
            }
        };
        template <typename _Iterator> inline _Iter_equals_iter<_Iterator> __iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it)         {
            return _Iter_equals_iter<_Iterator>(__it);
        }
        template <typename _Predicate> struct _Iter_pred {
            _Predicate _M_pred;
            explicit _Iter_pred<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline _Iter_pred<_Predicate> __pred_iter(_Predicate __pred)         {
            return _Iter_pred<_Predicate>(std::move(__pred));
        }
        template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
            _Compare _M_comp;
            _Value &_M_value;
            _Iter_comp_to_val<_Compare, _Value>(_Compare __comp, _Value &__value) : _M_comp(std::move(__comp)), _M_value(__value)             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return bool(this->_M_comp(*__it, this->_M_value));
            }
        };
        template <typename _Compare, typename _Value> _Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val)         {
            return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
        }
        template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
            _Compare _M_comp;
            _Iterator1 _M_it1;
            _Iter_comp_to_iter<_Compare, _Iterator1>(_Compare __comp, _Iterator1 __it1) : _M_comp(std::move(__comp)), _M_it1(__it1)             {
            }
            template <typename _Iterator2> bool operator()(_Iterator2 __it2)             {
                return bool(this->_M_comp(*__it2, *this->_M_it1));
            }
        };
        template <typename _Compare, typename _Iterator> inline _Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)         {
            return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp), __it);
        }
        template <typename _Predicate> struct _Iter_negate {
            _Predicate _M_pred;
            explicit _Iter_negate<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return !bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred)         {
            return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
        }
    }
}
namespace std {
    template <typename _Tp, typename _Up> inline constexpr int __memcmp(const _Tp *__first1, const _Up *__first2, std::size_t __num)     {
        static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
        return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)     {
        swap(*__a, *__b);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            std::iter_swap(__first1, __first2);
        return __first2;
    }
    template <typename _Tp> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const unsigned long &min<unsigned long>(const unsigned long &__a, const unsigned long &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const long &min<long>(const long &__a, const long &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template <typename _Tp> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<> inline constexpr const unsigned long &max<unsigned long>(const unsigned long &__a, const unsigned long &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }
    template <typename _Iterator> inline _Iterator __niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it;
    }
    template <typename _From, typename _To> inline _From __niter_wrap(_From __from, _To __res)     {
        return __from + (__res - std::__niter_base(__from));
    }
    template <typename _Iterator> inline _Iterator __niter_wrap(const _Iterator &, _Iterator __res)     {
        return __res;
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = *__first;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move<true, false, _Category> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = std::move(*__first);
            return __result;
        }
    };
    template<> struct __copy_move<false, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template<> struct __copy_move<true, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = std::move(*__first);
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = conditional<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
            return __result + _Num;
        }
    };
    template <typename _CharT> struct char_traits;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, _CharT *);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)     {
        typedef typename iterator_traits<_II>::iterator_category _Category;
        return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template <typename _Tp, typename _Ref, typename _Ptr> struct _Deque_iterator;
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a1(_II __first, _II __last, _OI __result)     {
        return std::__copy_move_a2<_IsMove>(__first, __last, __result);
    }
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a(_II __first, _II __last, _OI __result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _II, typename _OI> inline _OI copy(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _II, typename _OI> inline _OI move(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move_backward<true, false, _Category> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template<> struct __copy_move_backward<false, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
    };
    template<> struct __copy_move_backward<true, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move_backward<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = conditional<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
            return __result - _Num;
        }
    };
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)     {
        typedef typename iterator_traits<_BI1>::iterator_category _Category;
        return std::__copy_move_backward<_IsMove, __memcpyable<_BI2, _BI1>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)     {
        return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_backward_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_backward_a(_II __first, _II __last, _OI __result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _BI1, typename _BI2> inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _BI1, typename _BI2> inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        for (; __first != __last; ++__first)
            *__first = __value;
    }
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __first != __last; ++__first)
            *__first = __tmp;
    }
    template <typename _Tp> inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a1(_Tp *__first, _Tp *__last, const _Tp &__c)     {
        const _Tp __tmp = __c;
        if (const std::size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template <typename _Ite, typename _Cont, typename _Tp> inline void __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first, ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last, const _Tp &__value)     {
        std::__fill_a1(__first.base(), __last.base(), __value);
    }
    template <typename _Tp, typename _VTp> void __fill_a1(const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const _VTp &);
    template <typename _FIte, typename _Tp> inline void __fill_a(_FIte __first, _FIte __last, const _Tp &__value)     {
        std::__fill_a1(__first, __last, __value);
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Tp> void __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const _Tp &);
    template <typename _ForwardIterator, typename _Tp> inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        ;
        std::__fill_a(__first, __last, __value);
    }
    inline constexpr int __size_to_integer(int __n)     {
        return __n;
    }
    inline constexpr unsigned int __size_to_integer(unsigned int __n)     {
        return __n;
    }
    inline constexpr long __size_to_integer(long __n)     {
        return __n;
    }
    inline constexpr unsigned long __size_to_integer(unsigned long __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(long long __n)     {
        return __n;
    }
    inline constexpr unsigned long long __size_to_integer(unsigned long long __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(float __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(double __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(long double __n)     {
        return __n;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        for (; __n > 0; --__n , (void)++__first)
            *__first = __value;
        return __first;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __n > 0; --__n , (void)++__first)
            *__first = __tmp;
        return __first;
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Size, typename _Tp> ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first, _Size __n, const _Tp &__value, std::input_iterator_tag);
    template <typename _OutputIterator, typename _Size, typename _Tp> inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::output_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::input_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::random_access_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template <typename _OI, typename _Size, typename _Tp> inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)     {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template <bool _BoolType> struct __equal {
        template <typename _II1, typename _II2> static bool equal(_II1 __first1, _II1 __last1, _II2 __first2)         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!(*__first1 == *__first2))
                    return false;
            return true;
        }
    };
    template<> struct __equal<true> {
        template <typename _Tp> static bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)         {
            if (const std::size_t __len = (__last1 - __first1))
                return !std::__memcmp(__first1, __first2, __len);
            return true;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr, typename _II> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _II);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II, typename _Tp, typename _Ref, typename _Ptr> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(_II, _II, std::_Deque_iterator<_Tp, _Ref, _Ptr>);
    template <typename _II1, typename _II2> inline bool __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        const bool __simple = ((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __memcmpable<_II1, _II2>::__value);
        return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
    template <typename _II1, typename _II2> inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)     {
        return std::__equal_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
    }
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, _II2);
    template <typename _II1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename, typename> struct __lc_rai {
        template <typename _II1, typename _II2> static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)         {
            return __last1;
        }
        template <typename _II> static bool __cnd2(_II __first, _II __last)         {
            return __first != __last;
        }
    };
    template<> struct __lc_rai<std::random_access_iterator_tag, std::random_access_iterator_tag> {
        template <typename _RAI1, typename _RAI2> static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)         {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }
        template <typename _RAI> static bool __cnd2(_RAI, _RAI)         {
            return true;
        }
    };
    template <typename _II1, typename _II2, typename _Compare> bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        typedef typename iterator_traits<_II1>::iterator_category _Category1;
        typedef typename iterator_traits<_II2>::iterator_category _Category2;
        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ++__first1 , (void)++__first2) {
            if (__comp(__first1, __first2))
                return true;
            if (__comp(__first2, __first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template <bool _BoolType> struct __lexicographical_compare {
        template <typename _II1, typename _II2> static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)         {
            using __gnu_cxx::__ops::__iter_less_iter;
            return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __iter_less_iter());
        }
    };
    template<> struct __lexicographical_compare<true> {
        template <typename _Tp, typename _Up> static bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)         {
            const std::size_t __len1 = __last1 - __first1;
            const std::size_t __len2 = __last2 - __first2;
            if (const std::size_t __len = std::min(__len1, __len2))
                if (int __result = std::__memcmp(__first1, __first2, __len))
                    return __result < 0;
            return __len1 < __len2;
        }
    };
    template <typename _II1, typename _II2> inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value);
        return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
    }
    template <typename _ForwardIterator, typename _Tp, typename _Compare> _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else
                    __len = __half;
            }
        return __first;
    }
    template <typename _ForwardIterator, typename _Tp> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    }
    inline constexpr int __lg(int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr unsigned int __lg(unsigned int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr long __lg(long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr unsigned long __lg(unsigned long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr long long __lg(long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    inline constexpr unsigned long long __lg(unsigned long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    template <typename _II1, typename _II2> inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)     {
        ;
        return std::__equal_aux(__first1, __last1, __first2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return true;
    }
    template <typename _II1, typename _II2> inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!(*__first1 == *__first2))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2, typename _BinaryPredicate> inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _BinaryPredicate __binary_pred)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2, __binary_pred);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2> inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
    }
    template <typename _II1, typename _II2> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
    }
    template <typename _II1, typename _II2, typename _Compare> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        ;
        ;
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __first2 != __last2 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator, typename _Predicate> inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, std::input_iterator_tag)     {
        while (__first != __last && !__pred(__first))
            ++__first;
        return __first;
    }
    template <typename _RandomAccessIterator, typename _Predicate> _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, std::random_access_iterator_tag)     {
        typename iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
        for (; __trip_count > 0; --__trip_count) {
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
        }
        switch (__last - __first) {
          case 3:
            if (__pred(__first))
                return __first;
            ++__first;
          case 2:
            if (__pred(__first))
                return __first;
            ++__first;
          case 1:
            if (__pred(__first))
                return __first;
            ++__first;
          case 0:
          default:
            return __last;
        }
    }
    template <typename _Iterator, typename _Predicate> inline _Iterator __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)     {
        return __find_if(__first, __last, __pred, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Predicate> typename iterator_traits<_InputIterator>::difference_type __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        for (; __first != __last; ++__first)
            if (__pred(__first))
                ++__n;
        return __n;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)     {
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!__pred(__first1, __first2))
                break;
        if (__first1 == __last1)
            return true;
        _ForwardIterator2 __last2 = __first2;
        std::advance(__last2, std::distance(__first1, __last1));
        for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
            if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                continue;
            auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
            if (0 == __matches || std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)
                return false;
        }
        return true;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
}
namespace __gnu_cxx {
    template <typename _CharT> struct _Char_types {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<wchar_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template <typename _CharT> struct char_traits {
        typedef _CharT char_type;
        typedef typename _Char_types<_CharT>::int_type int_type;
        typedef typename _Char_types<_CharT>::pos_type pos_type;
        typedef typename _Char_types<_CharT>::off_type off_type;
        typedef typename _Char_types<_CharT>::state_type state_type;
        static constexpr void assign(__gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            __c1 = __c2;
        }
        static constexpr bool eq(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits::char_type *__s);
        static constexpr const __gnu_cxx::char_traits::char_type *find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a);
        static __gnu_cxx::char_traits::char_type *move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits::char_type *copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits::char_type *assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a);
        static constexpr __gnu_cxx::char_traits::char_type to_char_type(const __gnu_cxx::char_traits::int_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::char_type>(__c);
        }
        static constexpr __gnu_cxx::char_traits::int_type to_int_type(const __gnu_cxx::char_traits::char_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::int_type>(__c);
        }
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits::int_type &__c1, const __gnu_cxx::char_traits::int_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr __gnu_cxx::char_traits::int_type eof()         {
            return static_cast<__gnu_cxx::char_traits::int_type>(-1);
        }
        static constexpr __gnu_cxx::char_traits::int_type not_eof(const __gnu_cxx::char_traits::int_type &__c)         {
            return !eq_int_type(__c, eof()) ? __c : to_int_type(__gnu_cxx::char_traits::char_type());
        }
    };
template<> struct char_traits<char> {
        typedef char char_type;
        typedef typename _Char_types<char>::int_type int_type;
        typedef typename _Char_types<char>::pos_type pos_type;
        typedef typename _Char_types<char>::off_type off_type;
        typedef typename _Char_types<char>::state_type state_type;
        static constexpr void assign(__gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int char_traits<char>::compare(const __gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<char>::length(const __gnu_cxx::char_traits<char>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<char>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<char>::char_type *char_traits<char>::find(const __gnu_cxx::char_traits<char>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static __gnu_cxx::char_traits<char>::char_type *move(__gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits<char>::char_type *copy(__gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits<char>::char_type *assign(__gnu_cxx::char_traits<char>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char>::char_type __a);
        static constexpr __gnu_cxx::char_traits<char>::char_type to_char_type(const __gnu_cxx::char_traits<char>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char>::int_type to_int_type(const __gnu_cxx::char_traits<char>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char>::int_type &__c1, const __gnu_cxx::char_traits<char>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char>::int_type not_eof(const __gnu_cxx::char_traits<char>::int_type &__c);
    };
template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef typename _Char_types<wchar_t>::int_type int_type;
        typedef typename _Char_types<wchar_t>::pos_type pos_type;
        typedef typename _Char_types<wchar_t>::off_type off_type;
        typedef typename _Char_types<wchar_t>::state_type state_type;
        static constexpr void assign(__gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int char_traits<wchar_t>::compare(const __gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<wchar_t>::length(const __gnu_cxx::char_traits<wchar_t>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<wchar_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::find(const __gnu_cxx::char_traits<wchar_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<wchar_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static __gnu_cxx::char_traits<wchar_t>::char_type *move(__gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits<wchar_t>::char_type *copy(__gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits<wchar_t>::char_type *assign(__gnu_cxx::char_traits<wchar_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<wchar_t>::char_type __a);
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type to_char_type(const __gnu_cxx::char_traits<wchar_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type to_int_type(const __gnu_cxx::char_traits<wchar_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<wchar_t>::int_type &__c1, const __gnu_cxx::char_traits<wchar_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type not_eof(const __gnu_cxx::char_traits<wchar_t>::int_type &__c);
    };
    template <typename _CharT> constexpr int char_traits<_CharT>::compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (lt(__s1[__i], __s2[__i]))
                return -1;
            else if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }
    template <typename _CharT> constexpr std::size_t char_traits<_CharT>::length(const __gnu_cxx::char_traits::char_type *__p)     {
        std::size_t __i = 0;
        while (!eq(__p[__i], __gnu_cxx::char_traits::char_type()))
            ++__i;
        return __i;
    }
    template <typename _CharT> constexpr const typename char_traits<_CharT>::char_type *char_traits<_CharT>::find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (eq(__s[__i], __a))
                return __s + __i;
        return 0;
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        if (__n == 0)
            return __s1;
        return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits::char_type)));
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        std::copy(__s2, __s2 + __n, __s1);
        return __s1;
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a)     {
        std::fill_n(__s, __n, __a);
        return __s;
    }
}
namespace std {
    template <typename _CharT> static inline constexpr bool __constant_string_p(const _CharT *__s) __attribute__((always_inline))     {
        (void)__s;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_string_p<char>(const char *__s) __attribute__((always_inline))     {
        (void)__s;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_string_p<wchar_t>(const wchar_t *__s) __attribute__((always_inline))     {
        (void)__s;
        return __builtin_is_constant_evaluated();
    }
    template <typename _CharT> static inline constexpr bool __constant_char_array_p(const _CharT *__a, std::size_t __n) __attribute__((always_inline))     {
        (void)__a;
        (void)__n;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_char_array_p<char>(const char *__a, std::size_t __n) __attribute__((always_inline))     {
        (void)__a;
        (void)__n;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_char_array_p<wchar_t>(const wchar_t *__a, std::size_t __n) __attribute__((always_inline))     {
        (void)__a;
        (void)__n;
        return __builtin_is_constant_evaluated();
    }
    template <class _CharT> struct char_traits : public __gnu_cxx::char_traits<_CharT> {
    };
    template<> struct char_traits<char> {
        typedef char char_type;
        typedef int int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef mbstate_t state_type;
        static constexpr void assign(std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }
        static constexpr int compare(const std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __constant_char_array_p(__s1, __n) && __constant_char_array_p(__s2, __n))
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<char>::char_type *__s)         {
            if (__constant_string_p(__s))
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return __builtin_strlen(__s);
        }
        static constexpr const std::char_traits<char>::char_type *find(const std::char_traits<char>::char_type *__s, std::size_t __n, const std::char_traits<char>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __builtin_constant_p(__a) && __constant_char_array_p(__s, __n))
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return static_cast<const std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static std::char_traits<char>::char_type *move(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static std::char_traits<char>::char_type *copy(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static std::char_traits<char>::char_type *assign(std::char_traits<char>::char_type *__s, std::size_t __n, std::char_traits<char>::char_type __a)         {
            if (__n == 0)
                return __s;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr std::char_traits<char>::char_type to_char_type(const std::char_traits<char>::int_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::char_type>(__c);
        }
        static constexpr std::char_traits<char>::int_type to_int_type(const std::char_traits<char>::char_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
        }
        static constexpr bool eq_int_type(const std::char_traits<char>::int_type &__c1, const std::char_traits<char>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char>::int_type>(-1);
        }
        static constexpr std::char_traits<char>::int_type not_eof(const std::char_traits<char>::int_type &__c) noexcept         {
            return (__c == eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef std::streamoff off_type;
        typedef std::wstreampos pos_type;
        typedef mbstate_t state_type;
        static constexpr void assign(std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __constant_char_array_p(__s1, __n) && __constant_char_array_p(__s2, __n))
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return wmemcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<wchar_t>::char_type *__s)         {
            if (__constant_string_p(__s))
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return wcslen(__s);
        }
        static constexpr const std::char_traits<wchar_t>::char_type *find(const std::char_traits<wchar_t>::char_type *__s, std::size_t __n, const std::char_traits<wchar_t>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __builtin_constant_p(__a) && __constant_char_array_p(__s, __n))
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return wmemchr(__s, __a, __n);
        }
        static std::char_traits<wchar_t>::char_type *move(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemmove(__s1, __s2, __n);
        }
        static std::char_traits<wchar_t>::char_type *copy(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemcpy(__s1, __s2, __n);
        }
        static std::char_traits<wchar_t>::char_type *assign(std::char_traits<wchar_t>::char_type *__s, std::size_t __n, std::char_traits<wchar_t>::char_type __a)         {
            if (__n == 0)
                return __s;
            return wmemset(__s, __a, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type to_char_type(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return std::char_traits<wchar_t>::char_type(__c);
        }
        static constexpr std::char_traits<wchar_t>::int_type to_int_type(const std::char_traits<wchar_t>::char_type &__c) noexcept         {
            return std::char_traits<wchar_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<wchar_t>::int_type &__c1, const std::char_traits<wchar_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<wchar_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<wchar_t>::int_type>((4294967295U));
        }
        static constexpr std::char_traits<wchar_t>::int_type not_eof(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
namespace std {
    using ::int8_t;
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::int_fast8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::int_least8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uint8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::uint_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::uint_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::uintmax_t;
    using ::uintptr_t;
}
namespace std {
    template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef uint_least16_t int_type;
        typedef std::streamoff off_type;
        typedef std::u16streampos pos_type;
        typedef mbstate_t state_type;
        static constexpr void assign(std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t length(const std::char_traits<char16_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char16_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char16_t>::char_type *find(const std::char_traits<char16_t>::char_type *__s, std::size_t __n, const std::char_traits<char16_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static std::char_traits<char16_t>::char_type *move(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static std::char_traits<char16_t>::char_type *copy(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static std::char_traits<char16_t>::char_type *assign(std::char_traits<char16_t>::char_type *__s, std::size_t __n, std::char_traits<char16_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char16_t>::char_type to_char_type(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return std::char_traits<char16_t>::char_type(__c);
        }
        static constexpr std::char_traits<char16_t>::int_type to_int_type(const std::char_traits<char16_t>::char_type &__c) noexcept         {
            return __c == eof() ? std::char_traits<char16_t>::int_type(65533) : std::char_traits<char16_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char16_t>::int_type &__c1, const std::char_traits<char16_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char16_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char16_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char16_t>::int_type not_eof(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef uint_least32_t int_type;
        typedef std::streamoff off_type;
        typedef std::u32streampos pos_type;
        typedef mbstate_t state_type;
        static constexpr void assign(std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t length(const std::char_traits<char32_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char32_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char32_t>::char_type *find(const std::char_traits<char32_t>::char_type *__s, std::size_t __n, const std::char_traits<char32_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static std::char_traits<char32_t>::char_type *move(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static std::char_traits<char32_t>::char_type *copy(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static std::char_traits<char32_t>::char_type *assign(std::char_traits<char32_t>::char_type *__s, std::size_t __n, std::char_traits<char32_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char32_t>::char_type to_char_type(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return std::char_traits<char32_t>::char_type(__c);
        }
        static constexpr std::char_traits<char32_t>::int_type to_int_type(const std::char_traits<char32_t>::char_type &__c) noexcept         {
            return std::char_traits<char32_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char32_t>::int_type &__c1, const std::char_traits<char32_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char32_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char32_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char32_t>::int_type not_eof(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
extern "C" {
    struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        char int_p_cs_precedes;
        char int_p_sep_by_space;
        char int_n_cs_precedes;
        char int_n_sep_by_space;
        char int_p_sign_posn;
        char int_n_sign_posn;
    };
    extern char *setlocale(int __category, const char *__locale) throw();
    extern struct lconv *localeconv() throw();
    extern locale_t newlocale(int __category_mask, const char *__locale, locale_t __base) throw();
    extern locale_t duplocale(locale_t __dataset) throw();
    extern void freelocale(locale_t __dataset) throw();
    extern locale_t uselocale(locale_t __dataset) throw();
}
namespace std {
    using ::lconv;
    using ::setlocale;
    using ::localeconv;
}
namespace __gnu_cxx {
    extern "C" locale_t __uselocale(locale_t) throw()
}
namespace std {
    typedef __locale_t __c_locale;
    inline int __convert_from_v(const std::__c_locale &__cloc __attribute__((unused)), char *__out, const int __size __attribute__((unused)), const char *__fmt, ...)     {
        std::__c_locale __old = __gnu_cxx::__uselocale(__cloc);
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
        __builtin_va_end(__args);
        __gnu_cxx::__uselocale(__old);
        return __ret;
    }
}
extern "C" {
    static inline __uint16_t __bswap_16(__uint16_t __bsx)     {
        return ((__uint16_t)((((__bsx) >> 8) & 255) | (((__bsx) & 255) << 8)));
    }
    static inline __uint32_t __bswap_32(__uint32_t __bsx)     {
        return ((((__bsx) & 4278190080U) >> 24) | (((__bsx) & 16711680U) >> 8) | (((__bsx) & 65280U) << 8) | (((__bsx) & 255U) << 24));
    }
    static inline __uint64_t __bswap_64(__uint64_t __bsx)     {
        return ((((__bsx) & 18374686479671623680ULL) >> 56) | (((__bsx) & 71776119061217280ULL) >> 40) | (((__bsx) & 280375465082880ULL) >> 24) | (((__bsx) & 1095216660480ULL) >> 8) | (((__bsx) & 4278190080ULL) << 8) | (((__bsx) & 16711680ULL) << 24) | (((__bsx) & 65280ULL) << 40) | (((__bsx) & 255ULL) << 56));
    }
    static inline __uint16_t __uint16_identity(__uint16_t __x)     {
        return __x;
    }
    static inline __uint32_t __uint32_identity(__uint32_t __x)     {
        return __x;
    }
    static inline __uint64_t __uint64_identity(__uint64_t __x)     {
        return __x;
    }
    enum  {
        _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
        _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
        _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
        _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
        _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
        _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
        _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
        _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
        _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
        _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
        _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
        _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
    };
    extern const unsigned short **__ctype_b_loc() throw() __attribute__((const));
    extern const __int32_t **__ctype_tolower_loc() throw() __attribute__((const));
    extern const __int32_t **__ctype_toupper_loc() throw() __attribute__((const));
    extern int isalnum(int) throw();
    extern int isalpha(int) throw();
    extern int iscntrl(int) throw();
    extern int isdigit(int) throw();
    extern int islower(int) throw();
    extern int isgraph(int) throw();
    extern int isprint(int) throw();
    extern int ispunct(int) throw();
    extern int isspace(int) throw();
    extern int isupper(int) throw();
    extern int isxdigit(int) throw();
    extern int tolower(int __c) throw();
    extern int toupper(int __c) throw();
    extern int isblank(int) throw();
    extern int isctype(int __c, int __mask) throw();
    extern int isascii(int __c) throw();
    extern int toascii(int __c) throw();
    extern int _toupper(int) throw();
    extern int _tolower(int) throw();
    extern int isalnum_l(int, locale_t) throw();
    extern int isalpha_l(int, locale_t) throw();
    extern int iscntrl_l(int, locale_t) throw();
    extern int isdigit_l(int, locale_t) throw();
    extern int islower_l(int, locale_t) throw();
    extern int isgraph_l(int, locale_t) throw();
    extern int isprint_l(int, locale_t) throw();
    extern int ispunct_l(int, locale_t) throw();
    extern int isspace_l(int, locale_t) throw();
    extern int isupper_l(int, locale_t) throw();
    extern int isxdigit_l(int, locale_t) throw();
    extern int isblank_l(int, locale_t) throw();
    extern int __tolower_l(int __c, locale_t __l) throw();
    extern int tolower_l(int __c, locale_t __l) throw();
    extern int __toupper_l(int __c, locale_t __l) throw();
    extern int toupper_l(int __c, locale_t __l) throw();
}
namespace std {
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;
}
namespace std {
    using ::isblank;
}
namespace std {
    class locale;
    template <typename _Facet> bool has_facet(const std::locale &) throw();
    template <typename _Facet> const _Facet &use_facet(const std::locale &);
    template <typename _CharT> bool isspace(_CharT, const std::locale &);
    template <typename _CharT> bool isprint(_CharT, const std::locale &);
    template <typename _CharT> bool iscntrl(_CharT, const std::locale &);
    template <typename _CharT> bool isupper(_CharT, const std::locale &);
    template <typename _CharT> bool islower(_CharT, const std::locale &);
    template <typename _CharT> bool isalpha(_CharT, const std::locale &);
    template <typename _CharT> bool isdigit(_CharT, const std::locale &);
    template <typename _CharT> bool ispunct(_CharT, const std::locale &);
    template <typename _CharT> bool isxdigit(_CharT, const std::locale &);
    template <typename _CharT> bool isalnum(_CharT, const std::locale &);
    template <typename _CharT> bool isgraph(_CharT, const std::locale &);
    template <typename _CharT> bool isblank(_CharT, const std::locale &);
    template <typename _CharT> _CharT toupper(_CharT, const std::locale &);
    template <typename _CharT> _CharT tolower(_CharT, const std::locale &);
    class ctype_base;
    template <typename _CharT> class ctype;
    template<> class ctype<char>;
    template<> class ctype<wchar_t>;
    template <typename _CharT> class ctype_byname;
    class codecvt_base;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt;
    template<> class codecvt<char, char, mbstate_t>;
    template<> class codecvt<wchar_t, char, mbstate_t>;
    template<> class codecvt<char16_t, char, mbstate_t>;
    template<> class codecvt<char32_t, char, mbstate_t>;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt_byname;
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put;
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct;
        template <typename _CharT> class numpunct_byname;
    }
    inline namespace __cxx11 {
        template <typename _CharT> class collate;
        template <typename _CharT> class collate_byname;
    }
    class time_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get;
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get_byname;
    }
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put_byname;
    class money_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class money_get;
        template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class money_put;
    }
    inline namespace __cxx11 {
        template <typename _CharT, bool _Intl = false> class moneypunct;
        template <typename _CharT, bool _Intl = false> class moneypunct_byname;
    }
    class messages_base;
    inline namespace __cxx11 {
        template <typename _CharT> class messages;
        template <typename _CharT> class messages_byname;
    }
}
typedef __time_t time_t;
struct timespec {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
};
typedef __pid_t pid_t;
struct sched_param {
    int sched_priority;
};
extern "C" {
    extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) throw();
    extern int unshare(int __flags) throw();
    extern int sched_getcpu() throw();
    extern int setns(int __fd, int __nstype) throw();
}
typedef unsigned long __cpu_mask;
typedef struct {
    __cpu_mask __bits[16];
} cpu_set_t;
extern "C" {
    extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp) throw();
    extern cpu_set_t *__sched_cpualloc(size_t __count) throw();
    extern void __sched_cpufree(cpu_set_t *__set) throw();
}
extern "C" {
    extern int sched_setparam(__pid_t __pid, const struct sched_param *__param) throw();
    extern int sched_getparam(__pid_t __pid, struct sched_param *__param) throw();
    extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param) throw();
    extern int sched_getscheduler(__pid_t __pid) throw();
    extern int sched_yield() throw();
    extern int sched_get_priority_max(int __algorithm) throw();
    extern int sched_get_priority_min(int __algorithm) throw();
    extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t) throw();
    extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t *__cpuset) throw();
    extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t *__cpuset) throw();
}
struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};
struct timex {
    unsigned int modes;
    __syscall_slong_t offset;
    __syscall_slong_t freq;
    __syscall_slong_t maxerror;
    __syscall_slong_t esterror;
    int status;
    __syscall_slong_t constant;
    __syscall_slong_t precision;
    __syscall_slong_t tolerance;
    struct timeval time;
    __syscall_slong_t tick;
    __syscall_slong_t ppsfreq;
    __syscall_slong_t jitter;
    int shift;
    __syscall_slong_t stabil;
    __syscall_slong_t jitcnt;
    __syscall_slong_t calcnt;
    __syscall_slong_t errcnt;
    __syscall_slong_t stbcnt;
    int tai;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
};
extern "C" {
    extern int clock_adjtime(__clockid_t __clock_id, struct timex *__utx) throw();
}
typedef __clock_t clock_t;
struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    const char *tm_zone;
};
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};
struct sigevent;
extern "C" {
    extern clock_t clock() throw();
    extern time_t time(time_t *__timer) throw();
    extern double difftime(time_t __time1, time_t __time0) throw() __attribute__((const));
    extern time_t mktime(struct tm *__tp) throw();
    extern size_t strftime(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp) throw();
    extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp) throw();
    extern size_t strftime_l(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) throw();
    extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp, locale_t __loc) throw();
    extern struct tm *gmtime(const time_t *__timer) throw();
    extern struct tm *localtime(const time_t *__timer) throw();
    extern struct tm *gmtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) throw();
    extern struct tm *localtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) throw();
    extern char *asctime(const struct tm *__tp) throw();
    extern char *ctime(const time_t *__timer) throw();
    extern char *asctime_r(const struct tm *__restrict __tp, char *__restrict __buf) throw();
    extern char *ctime_r(const time_t *__restrict __timer, char *__restrict __buf) throw();
    extern char *__tzname[2];
    extern int __daylight;
    extern long __timezone;
    extern char *tzname[2];
    extern void tzset() throw();
    extern int daylight;
    extern long timezone;
    extern int stime(const time_t *__when) throw();
    extern time_t timegm(struct tm *__tp) throw();
    extern time_t timelocal(struct tm *__tp) throw();
    extern int dysize(int __year) throw() __attribute__((const));
    extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining);
    extern int clock_getres(clockid_t __clock_id, struct timespec *__res) throw();
    extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp) throw();
    extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp) throw();
    extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem);
    extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id) throw();
    extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) throw();
    extern int timer_delete(timer_t __timerid) throw();
    extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) throw();
    extern int timer_gettime(timer_t __timerid, struct itimerspec *__value) throw();
    extern int timer_getoverrun(timer_t __timerid) throw();
    extern int timespec_get(struct timespec *__ts, int __base) throw() __attribute__((nonnull(1)));
    extern int getdate_err;
    extern struct tm *getdate(const char *__string);
    extern int getdate_r(const char *__restrict __string, struct tm *__restrict __resbufp);
}
struct __pthread_rwlock_arch_t {
    unsigned int __readers;
    unsigned int __writers;
    unsigned int __wrphase_futex;
    unsigned int __writers_futex;
    unsigned int __pad3;
    unsigned int __pad4;
    int __cur_writer;
    int __shared;
    signed char __rwelision;
    unsigned char __pad1[7];
    unsigned long __pad2;
    unsigned int __flags;
};
typedef struct __pthread_internal_list {
    struct __pthread_internal_list *__prev;
    struct __pthread_internal_list *__next;
} __pthread_list_t;
struct __pthread_mutex_s {
    int __lock;
    unsigned int __count;
    int __owner;
    unsigned int __nusers;
    int __kind;
    short __spins;
    short __elision;
    __pthread_list_t __list;
};
struct __pthread_cond_s {
    union {
        unsigned long long __wseq;
        struct {
            unsigned int __low;
            unsigned int __high;
        } __wseq32;
    };
    union {
        unsigned long long __g1_start;
        struct {
            unsigned int __low;
            unsigned int __high;
        } __g1_start32;
    };
    unsigned int __g_refs[2];
    unsigned int __g_size[2];
    unsigned int __g1_orig_size;
    unsigned int __wrefs;
    unsigned int __g_signals[2];
};
typedef unsigned long pthread_t;
typedef union {
    char __size[4];
    int __align;
} pthread_mutexattr_t;
typedef union {
    char __size[4];
    int __align;
} pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
    char __size[56];
    long __align;
};
typedef union pthread_attr_t pthread_attr_t;
typedef union {
    struct __pthread_mutex_s __data;
    char __size[40];
    long __align;
} pthread_mutex_t;
typedef union {
    struct __pthread_cond_s __data;
    char __size[48];
    long long __align;
} pthread_cond_t;
typedef union {
    struct __pthread_rwlock_arch_t __data;
    char __size[56];
    long __align;
} pthread_rwlock_t;
typedef union {
    char __size[8];
    long __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {
    char __size[32];
    long __align;
} pthread_barrier_t;
typedef union {
    char __size[4];
    int __align;
} pthread_barrierattr_t;
typedef long __jmp_buf[8];
enum  {
    PTHREAD_CREATE_JOINABLE,
    PTHREAD_CREATE_DETACHED
};
enum  {
    PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP,
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum  {
    PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_ROBUST,
    PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};
enum  {
    PTHREAD_PRIO_NONE,
    PTHREAD_PRIO_INHERIT,
    PTHREAD_PRIO_PROTECT
};
enum  {
    PTHREAD_RWLOCK_PREFER_READER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum  {
    PTHREAD_INHERIT_SCHED,
    PTHREAD_EXPLICIT_SCHED
};
enum  {
    PTHREAD_SCOPE_SYSTEM,
    PTHREAD_SCOPE_PROCESS
};
enum  {
    PTHREAD_PROCESS_PRIVATE,
    PTHREAD_PROCESS_SHARED
};
struct _pthread_cleanup_buffer {
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
enum  {
    PTHREAD_CANCEL_ENABLE,
    PTHREAD_CANCEL_DISABLE
};
enum  {
    PTHREAD_CANCEL_DEFERRED,
    PTHREAD_CANCEL_ASYNCHRONOUS
};
extern "C" {
    extern int pthread_create(pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) throw() __attribute__((nonnull(1, 3)));
    extern void pthread_exit(void *__retval);
    extern int pthread_join(pthread_t __th, void **__thread_return);
    extern int pthread_tryjoin_np(pthread_t __th, void **__thread_return) throw();
    extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return, const struct timespec *__abstime);
    extern int pthread_detach(pthread_t __th) throw();
    extern pthread_t pthread_self() throw() __attribute__((const));
    extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) throw() __attribute__((const));
    extern int pthread_attr_init(pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_destroy(pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedparam(pthread_attr_t *__restrict __attr, const struct sched_param *__restrict __param) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr, int *__restrict __policy) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getscope(const pthread_attr_t *__restrict __attr, int *__restrict __scope) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) throw() __attribute__((nonnull(1, 2))) __attribute__((deprecated("")));
    extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr) throw() __attribute__((nonnull(1))) __attribute__((deprecated("")));
    extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getstack(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, size_t *__restrict __stacksize) throw() __attribute__((nonnull(1, 2, 3)));
    extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr, size_t __cpusetsize, const cpu_set_t *__cpuset) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr, size_t __cpusetsize, cpu_set_t *__cpuset) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_getattr_default_np(pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_setattr_default_np(const pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_getattr_np(pthread_t __th, pthread_attr_t *__attr) throw() __attribute__((nonnull(2)));
    extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param) throw() __attribute__((nonnull(3)));
    extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) throw() __attribute__((nonnull(2, 3)));
    extern int pthread_setschedprio(pthread_t __target_thread, int __prio) throw();
    extern int pthread_getname_np(pthread_t __target_thread, char *__buf, size_t __buflen) throw() __attribute__((nonnull(2)));
    extern int pthread_setname_np(pthread_t __target_thread, const char *__name) throw() __attribute__((nonnull(2)));
    extern int pthread_getconcurrency() throw();
    extern int pthread_setconcurrency(int __level) throw();
    extern int pthread_yield() throw();
    extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t *__cpuset) throw() __attribute__((nonnull(3)));
    extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t *__cpuset) throw() __attribute__((nonnull(3)));
    extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((nonnull(1, 2)));
    extern int pthread_setcancelstate(int __state, int *__oldstate);
    extern int pthread_setcanceltype(int __type, int *__oldtype);
    extern int pthread_cancel(pthread_t __th);
    extern void pthread_testcancel();
    typedef struct {
        struct {
            __jmp_buf __cancel_jmp_buf;
            int __mask_was_saved;
        } __cancel_jmp_buf[1];
        void *__pad[4];
    } __pthread_unwind_buf_t __attribute__((aligned));
    struct __pthread_cleanup_frame {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    };
    class __pthread_cleanup_class {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    public:
        __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)         {
        }
        ~__pthread_cleanup_class() noexcept         {
            if (this->__do_it)
                this->__cancel_routine(this->__cancel_arg);
        }
        void __setdoit(int __newval)         {
            this->__do_it = __newval;
        }
        void __defer()         {
            pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &this->__cancel_type);
        }
        void __restore() const         {
            pthread_setcanceltype(this->__cancel_type, 0);
        }
    };
    struct __jmp_buf_tag;
    extern int __sigsetjmp(struct __jmp_buf_tag *__env, int __savemask) throw();
    extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_lock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_consistent_np(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_init(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_destroy(pthread_cond_t *__cond) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_signal(pthread_cond_t *__cond) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_broadcast(pthread_cond_t *__cond) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __attribute__((nonnull(1, 2)));
    extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_condattr_init(pthread_condattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_condattr_destroy(pthread_condattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_destroy(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_lock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_trylock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_unlock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw() __attribute__((nonnull(1)));
    extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) throw() __attribute__((nonnull(1)));
    extern int pthread_barrier_wait(pthread_barrier_t *__barrier) throw() __attribute__((nonnull(1)));
    extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *)) throw() __attribute__((nonnull(1)));
    extern int pthread_key_delete(pthread_key_t __key) throw();
    extern void *pthread_getspecific(pthread_key_t __key) throw();
    extern int pthread_setspecific(pthread_key_t __key, const void *__pointer) throw();
    extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id) throw() __attribute__((nonnull(2)));
    extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) throw();
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static int __gthrw_pthread_once(pthread_once_t *, void (*)()) __attribute__((alias("pthread_once"))) __attribute__((weakref("")))
static void *__gthrw_pthread_getspecific(pthread_key_t) throw() __attribute__((alias("pthread_getspecific"))) __attribute__((weakref("")))
static int __gthrw_pthread_setspecific(pthread_key_t, const void *) throw() __attribute__((alias("pthread_setspecific"))) __attribute__((weakref("")))
static int __gthrw_pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict) throw() __attribute__((alias("pthread_create"))) __attribute__((weakref("")))
static int __gthrw_pthread_join(pthread_t, void **) __attribute__((alias("pthread_join"))) __attribute__((weakref("")))
static int __gthrw_pthread_equal(pthread_t, pthread_t) throw() __attribute__((alias("pthread_equal"))) __attribute__((weakref("")))
static pthread_t __gthrw_pthread_self() throw() __attribute__((alias("pthread_self"))) __attribute__((weakref("")))
static int __gthrw_pthread_detach(pthread_t) throw() __attribute__((alias("pthread_detach"))) __attribute__((weakref("")))
static int __gthrw_pthread_cancel(pthread_t) __attribute__((alias("pthread_cancel"))) __attribute__((weakref("")))
static int __gthrw_sched_yield() throw() __attribute__((alias("sched_yield"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_lock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_lock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_trylock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_trylock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict) throw() __attribute__((alias("pthread_mutex_timedlock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_unlock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_unlock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutex_init"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_destroy(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_destroy"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict) throw() __attribute__((alias("pthread_cond_init"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_broadcast(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_broadcast"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_signal(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_signal"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict) __attribute__((alias("pthread_cond_wait"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict) __attribute__((alias("pthread_cond_timedwait"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_destroy(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_destroy"))) __attribute__((weakref("")))
static int __gthrw_pthread_key_create(pthread_key_t *, void (*)(void *)) throw() __attribute__((alias("pthread_key_create"))) __attribute__((weakref("")))
static int __gthrw_pthread_key_delete(pthread_key_t) throw() __attribute__((alias("pthread_key_delete"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutexattr_init(pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutexattr_init"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutexattr_settype(pthread_mutexattr_t *, int) throw() __attribute__((alias("pthread_mutexattr_settype"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutexattr_destroy(pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutexattr_destroy"))) __attribute__((weakref("")))
static int __gthrw___pthread_key_create(pthread_key_t *, void (*)(void *)) throw() __attribute__((alias("__pthread_key_create"))) __attribute__((weakref("")))
static inline int __gthread_active_p() {
    static void *const __gthread_active_ptr = __extension__ (void *)&__gthrw___pthread_key_create;
    return __gthread_active_ptr != 0;
}
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *__args) {
    return __gthrw_pthread_create(__threadid, __null, __func, __args);
}
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) {
    return __gthrw_pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(__gthread_t __threadid) {
    return __gthrw_pthread_detach(__threadid);
}
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) {
    return __gthrw_pthread_equal(__t1, __t2);
}
static inline __gthread_t __gthread_self() {
    return __gthrw_pthread_self();
}
static inline int __gthread_yield() {
    return __gthrw_sched_yield();
}
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)()) {
    if (__gthread_active_p())
        return __gthrw_pthread_once(__once, __func);
    else
        return -1;
}
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) {
    return __gthrw_pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(__gthread_key_t __key) {
    return __gthrw_pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(__gthread_key_t __key) {
    return __gthrw_pthread_getspecific(__key);
}
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) {
    return __gthrw_pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        __gthrw_pthread_mutex_init(__mutex, __null);
}
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_destroy(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_lock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_trylock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout);
    else
        return 0;
}
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_unlock(__mutex);
    else
        return 0;
}
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) {
    return __gthrw_pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *__mutex) {
    return __gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_destroy(__cond);
}
typedef int _Atomic_word;
namespace __gnu_cxx {
    inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        return __atomic_fetch_add(__mem, __val, 4);
    }
    inline void __atomic_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        __atomic_fetch_add(__mem, __val, 4);
    }
    inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        _Atomic_word __result = *__mem;
        *__mem += __val;
        return __result;
    }
    inline void __atomic_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        *__mem += __val;
    }
    inline _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        if (__gthread_active_p())
            return __exchange_and_add(__mem, __val);
        return __exchange_and_add_single(__mem, __val);
    }
    inline void __atomic_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        if (__gthread_active_p()) {
            __atomic_add(__mem, __val);
            return;
        }
        __atomic_add_single(__mem, __val);
    }
}
namespace __gnu_cxx {
    template <typename _Tp> class new_allocator {
    public:
        typedef _Tp value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        template <typename _Tp1> struct rebind {
            typedef new_allocator<_Tp1> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator<_Tp>() noexcept         {
        }
        new_allocator<_Tp>(const new_allocator<_Tp> &) noexcept         {
        }
        template <typename _Tp1> new_allocator<_Tp>(const new_allocator<_Tp1> &) noexcept         {
        }
        ~new_allocator<_Tp>() noexcept         {
        }
        __gnu_cxx::new_allocator::pointer address(__gnu_cxx::new_allocator::reference __x) const noexcept         {
            return std::__addressof(__x);
        }
        __gnu_cxx::new_allocator::const_pointer address(__gnu_cxx::new_allocator::const_reference __x) const noexcept         {
            return std::__addressof(__x);
        }
        _Tp *allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0)) [[nodiscard("")]]         {
            if (__n > this->_M_max_size())
                std::__throw_bad_alloc();
            if (alignof(_Tp) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(_Tp));
                return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp), __al));
            }
            return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
        }
        void deallocate(_Tp *__p, __gnu_cxx::new_allocator::size_type __t)         {
            if (alignof(_Tp) > 16UL) {
                ::operator delete(__p, std::align_val_t(alignof(_Tp)));
                return;
            }
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::valueconstruct(_Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)         {
            ::new ((void *)__p) _Up((std::forward<_Args>(__args)...));
        }
        template <typename _Up> void destroy(_Up *__p) noexcept(std::is_nothrow_destructible<_Up>::valuedestroy(_Up *__p) noexcept(std::is_nothrow_destructible<_Up>::value)         {
            __p->~_Up();
        }
        friend template <typename _Up> bool operator==(const new_allocator<_Tp> &, const new_allocator<_Up> &) noexcept         {
            return true;
        }
;
        friend template <typename _Up> bool operator!=(const new_allocator<_Tp> &, const new_allocator<_Up> &) noexcept         {
            return false;
        }
;
    private:
        constexpr __gnu_cxx::new_allocator::size_type _M_max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(_Tp);
        }
    };
template<> class new_allocator<char> {
    public:
        typedef char value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<char> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<char>(const new_allocator<char> &) noexcept;
        ~new_allocator<char>() noexcept         {
        }
        __gnu_cxx::new_allocator<char>::pointer address(__gnu_cxx::new_allocator<char>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<char>::const_pointer address(__gnu_cxx::new_allocator<char>::const_reference __x) const noexcept;
        char *allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0)) [[nodiscard("")]];
        void deallocate(char *__p, __gnu_cxx::new_allocator::size_type __t)         {
            if (alignof(char) > 16UL) {
                ::operator delete(__p, std::align_val_t(alignof(char)));
                return;
            }
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<char> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<char> &, const new_allocator<_Up> &) noexcept;
    private:
        constexpr __gnu_cxx::new_allocator::size_type _M_max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(char);
        }
    };
template<> class new_allocator<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<wchar_t> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<wchar_t>(const new_allocator<wchar_t> &) noexcept;
        ~new_allocator<wchar_t>() noexcept         {
        }
        __gnu_cxx::new_allocator<wchar_t>::pointer address(__gnu_cxx::new_allocator<wchar_t>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<wchar_t>::const_pointer address(__gnu_cxx::new_allocator<wchar_t>::const_reference __x) const noexcept;
        wchar_t *allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0)) [[nodiscard("")]];
        void deallocate(wchar_t *__p, __gnu_cxx::new_allocator::size_type __t)         {
            if (alignof(wchar_t) > 16UL) {
                ::operator delete(__p, std::align_val_t(alignof(wchar_t)));
                return;
            }
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept;
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<wchar_t> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<wchar_t> &, const new_allocator<_Up> &) noexcept;
    private:
        constexpr __gnu_cxx::new_allocator::size_type _M_max_size() const noexcept;
    };
template<> class new_allocator<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<char16_t> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<char16_t>(const new_allocator<char16_t> &) noexcept;
        ~new_allocator<char16_t>() noexcept         {
        }
        __gnu_cxx::new_allocator<char16_t>::pointer address(__gnu_cxx::new_allocator<char16_t>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<char16_t>::const_pointer address(__gnu_cxx::new_allocator<char16_t>::const_reference __x) const noexcept;
        char16_t *allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0)) [[nodiscard("")]]         {
            if (__n > this->_M_max_size())
                std::__throw_bad_alloc();
            if (alignof(char16_t) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(char16_t));
                return static_cast<char16_t *>(::operator new(__n * sizeof(char16_t), __al));
            }
            return static_cast<char16_t *>(::operator new(__n * sizeof(char16_t)));
        }
        void deallocate(char16_t *__p, __gnu_cxx::new_allocator::size_type __t)         {
            if (alignof(char16_t) > 16UL) {
                ::operator delete(__p, std::align_val_t(alignof(char16_t)));
                return;
            }
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<char16_t> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<char16_t> &, const new_allocator<_Up> &) noexcept;
    private:
        constexpr __gnu_cxx::new_allocator::size_type _M_max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(char16_t);
        }
    };
template<> class new_allocator<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<char32_t> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<char32_t>(const new_allocator<char32_t> &) noexcept;
        ~new_allocator<char32_t>() noexcept         {
        }
        __gnu_cxx::new_allocator<char32_t>::pointer address(__gnu_cxx::new_allocator<char32_t>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<char32_t>::const_pointer address(__gnu_cxx::new_allocator<char32_t>::const_reference __x) const noexcept;
        char32_t *allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0)) [[nodiscard("")]]         {
            if (__n > this->_M_max_size())
                std::__throw_bad_alloc();
            if (alignof(char32_t) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(char32_t));
                return static_cast<char32_t *>(::operator new(__n * sizeof(char32_t), __al));
            }
            return static_cast<char32_t *>(::operator new(__n * sizeof(char32_t)));
        }
        void deallocate(char32_t *__p, __gnu_cxx::new_allocator::size_type __t)         {
            if (alignof(char32_t) > 16UL) {
                ::operator delete(__p, std::align_val_t(alignof(char32_t)));
                return;
            }
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return this->_M_max_size();
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<char32_t> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<char32_t> &, const new_allocator<_Up> &) noexcept;
    private:
        constexpr __gnu_cxx::new_allocator::size_type _M_max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(char32_t);
        }
    };
template<> class new_allocator<std::pair<const int, int>> {
    public:
        typedef std::pair<const int, int> value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::pair<const int, int> *pointer;
        typedef const std::pair<const int, int> *const_pointer;
        typedef std::pair<const int, int> &reference;
        typedef const std::pair<const int, int> &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept;
        new_allocator(const __gnu_cxx::new_allocator<std::pair<const int, int>> &) noexcept;
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        ~new_allocator<pair<const int, int>>() noexcept;
        __gnu_cxx::new_allocator<std::pair<const int, int>>::pointer address(__gnu_cxx::new_allocator<std::pair<const int, int>>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<std::pair<const int, int>>::const_pointer address(__gnu_cxx::new_allocator<std::pair<const int, int>>::const_reference __x) const noexcept;
        std::pair<const int, int> *allocate(__gnu_cxx::new_allocator::size_type __n, const void *) [[nodiscard("")]];
        void deallocate(std::pair<const int, int> *__p, __gnu_cxx::new_allocator::size_type __t);
        __gnu_cxx::new_allocator::size_type max_size() const noexcept;
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<std::pair<const int, int>> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<std::pair<const int, int>> &, const new_allocator<_Up> &) noexcept;
    private:
        constexpr __gnu_cxx::new_allocator::size_type _M_max_size() const noexcept;
    };
template<> class new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> {
    public:
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> *pointer;
        typedef const std::__detail::_Hash_node<std::pair<const int, int>, false> *const_pointer;
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> &reference;
        typedef const std::__detail::_Hash_node<std::pair<const int, int>, false> &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept;
        new_allocator(const __gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) noexcept;
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        ~new_allocator<_Hash_node<pair<const int, int>, false>>() noexcept;
        __gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>::pointer address(__gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>::const_pointer address(__gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>::const_reference __x) const noexcept;
        std::__detail::_Hash_node<std::pair<const int, int>, false> *allocate(__gnu_cxx::new_allocator::size_type __n, const void *) [[nodiscard("")]];
        void deallocate(std::__detail::_Hash_node<std::pair<const int, int>, false> *__p, __gnu_cxx::new_allocator::size_type __t);
        __gnu_cxx::new_allocator::size_type max_size() const noexcept;
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &, const new_allocator<_Up> &) noexcept;
    private:
        constexpr __gnu_cxx::new_allocator::size_type _M_max_size() const noexcept;
    };
}
namespace std {
    template <typename _Tp> using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
namespace std {
    template<> class allocator<void> {
    public:
        typedef void value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef void *pointer;
        typedef const void *const_pointer;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::valueconstruct(_Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)         {
            ::new ((void *)__p) _Up((std::forward<_Args>(__args)...));
        }
        template <typename _Up> void destroy(_Up *__p) noexcept(std::is_nothrow_destructible<_Up>::valuedestroy(_Up *__p) noexcept(std::is_nothrow_destructible<_Up>::value)         {
            __p->~_Up();
        }
    };
    template <typename _Tp> class allocator : public __allocator_base<_Tp> {
    public:
        typedef _Tp value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator<type-parameter-0-0>() noexcept         {
        }
        allocator<type-parameter-0-0>(const allocator<type-parameter-0-0> &__a) noexcept : __allocator_base<_Tp>(__a)         {
        }
        allocator<type-parameter-0-0> &operator=(const allocator<type-parameter-0-0> &) = default
        template <typename _Tp1> allocator<type-parameter-0-0>(const allocator<_Tp1> &) noexcept         {
        }
        ~allocator<type-parameter-0-0>() noexcept         {
        }
        friend bool operator==(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept         {
            return true;
        }
;
        friend bool operator!=(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept         {
            return false;
        }
;
    };
template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char16_t>()         {
        }
        allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a)         {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char16_t>(const allocator<char16_t> &) noexcept;
        ~allocator<char16_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
        friend bool operator!=(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    };
template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char32_t>()         {
        }
        allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a)         {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char32_t>(const allocator<char32_t> &) noexcept;
        ~allocator<char32_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
        friend bool operator!=(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    };
template<> class allocator<std::pair<const int, int>> : public __allocator_base<std::pair<const int, int>> {
    public:
        typedef std::pair<const int, int> value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::pair<const int, int> *pointer;
        typedef const std::pair<const int, int> *const_pointer;
        typedef std::pair<const int, int> &reference;
        typedef const std::pair<const int, int> &const_reference;
        template <typename _Tp1> struct rebind
template<> struct rebind<std::__detail::_Hash_node<std::pair<const int, int>, false>> {
            typedef allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept;
        allocator(const std::allocator<std::pair<const int, int>> &__a) noexcept;
        std::allocator<std::pair<const int, int>> &operator=(const std::allocator<std::pair<const int, int>> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        ~allocator<pair<const int, int>>() noexcept;
        friend bool operator==(const std::allocator<std::pair<const int, int>> &, const std::allocator<std::pair<const int, int>> &) noexcept;
        friend bool operator!=(const std::allocator<std::pair<const int, int>> &, const std::allocator<std::pair<const int, int>> &) noexcept;
    };
template<> class allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> : public __allocator_base<std::__detail::_Hash_node<std::pair<const int, int>, false>> {
    public:
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> *pointer;
        typedef const std::__detail::_Hash_node<std::pair<const int, int>, false> *const_pointer;
        typedef std::__detail::_Hash_node<std::pair<const int, int>, false> &reference;
        typedef const std::__detail::_Hash_node<std::pair<const int, int>, false> &const_reference;
        template <typename _Tp1> struct rebind
template<> struct rebind<std::__detail::_Hash_node_base *> {
            typedef allocator<std::__detail::_Hash_node_base *> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept;
        allocator(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &__a) noexcept;
        std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &operator=(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>(const allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) noexcept;
        ~allocator<_Hash_node<pair<const int, int>, false>>() noexcept;
        friend bool operator==(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &, const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) noexcept;
        friend bool operator!=(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &, const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &) noexcept;
    };
    template <typename _T1, typename _T2> inline bool operator==(const allocator<_T1> &, const allocator<_T2> &) noexcept     {
        return true;
    }
    template <typename _T1, typename _T2> inline bool operator!=(const allocator<_T1> &, const allocator<_T2> &) noexcept     {
        return false;
    }
    template <typename _Tp> class allocator<const _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template <typename _Tp> class allocator<volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<volatile type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template <typename _Tp> class allocator<const volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const volatile type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template<> class allocator<char> : public __allocator_base<char> {
    public:
        typedef char value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char>()         {
        }
        allocator(const std::allocator<char> &__a) noexcept : __allocator_base<char>(__a)         {
        }
        std::allocator<char> &operator=(const std::allocator<char> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char>(const allocator<char> &) noexcept;
        ~allocator<char>() noexcept         {
        }
        friend bool operator==(const std::allocator<char> &, const std::allocator<char> &) noexcept;
        friend bool operator!=(const std::allocator<char> &, const std::allocator<char> &) noexcept;
    };
    template<> class allocator<wchar_t> : public __allocator_base<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<wchar_t>()         {
        }
        allocator(const std::allocator<wchar_t> &__a) noexcept : __allocator_base<wchar_t>(__a)         {
        }
        std::allocator<wchar_t> &operator=(const std::allocator<wchar_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<wchar_t>(const allocator<wchar_t> &) noexcept;
        ~allocator<wchar_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<wchar_t> &, const std::allocator<wchar_t> &) noexcept;
        friend bool operator!=(const std::allocator<wchar_t> &, const std::allocator<wchar_t> &) noexcept;
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
        static void _S_do_it(_Alloc &, _Alloc &) noexcept         {
        }
    };
    template <typename _Alloc> struct __alloc_swap<_Alloc, false> {
        static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept         {
            if (__one != __two)
                swap(__one, __two);
        }
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_neq {
        static bool _S_do_it(const _Alloc &, const _Alloc &)         {
            return false;
        }
    };
    template <typename _Alloc> struct __alloc_neq<_Alloc, false> {
        static bool _S_do_it(const _Alloc &__one, const _Alloc &__two)         {
            return __one != __two;
        }
    };
    template <typename _Tp, bool = __or_<is_copy_constructible<typename _Tp::value_type>, is_nothrow_move_constructible<typename _Tp::value_type>>::value> struct __shrink_to_fit_aux {
        static bool _S_do_it(_Tp &) noexcept         {
            return false;
        }
    };
    template <typename _Tp> struct __shrink_to_fit_aux<_Tp, true> {
        static bool _S_do_it(_Tp &__c) noexcept         {
            try {
                _Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c);
                return true;
            } catch (...) {
                return false;
            }
        }
    };
}
namespace __cxxabiv1 {
    class __forced_unwind {
        virtual ~__forced_unwind() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace std {
    template <typename _CharT, typename _Traits> inline void __ostream_write(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }
    template <typename _CharT, typename _Traits> inline void __ostream_fill(basic_ostream<_CharT, _Traits> &__out, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (; __n > 0; --__n) {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof())) {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &__ostream_insert(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb) {
            try {
                const std::streamsize __w = __out.width();
                if (__w > __n) {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                } else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }
}
namespace std {
    template <typename _Arg, typename _Result> struct unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <typename _Arg1, typename _Arg2, typename _Result> struct binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
template<> struct binary_function<const volatile void *, const volatile void *, bool> {
        typedef const volatile void *first_argument_type;
        typedef const volatile void *second_argument_type;
        typedef bool result_type;
    };
template<> struct binary_function<const std::_V2::error_category *, const std::_V2::error_category *, bool> {
        typedef const std::_V2::error_category *first_argument_type;
        typedef const std::_V2::error_category *second_argument_type;
        typedef bool result_type;
    };
template<> struct binary_function<int, int, bool> {
        typedef int first_argument_type;
        typedef int second_argument_type;
        typedef bool result_type;
    };
    struct __is_transparent;
    template <typename _Tp = void> struct plus;
    template <typename _Tp = void> struct minus;
    template <typename _Tp = void> struct multiplies;
    template <typename _Tp = void> struct divides;
    template <typename _Tp = void> struct modulus;
    template <typename _Tp = void> struct negate;
    template <typename _Tp = void> struct plus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x + __y;
        }
    };
    template <typename _Tp = void> struct minus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x - __y;
        }
    };
    template <typename _Tp = void> struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x * __y;
        }
    };
    template <typename _Tp = void> struct divides : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x / __y;
        }
    };
    template <typename _Tp = void> struct modulus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x % __y;
        }
    };
    template <typename _Tp = void> struct negate : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const         {
            return - __x;
        }
    };
    template<> struct plus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct minus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct multiplies<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct divides<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct modulus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct negate<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))) -> decltype(- std::forward<_Tp>(__t))         {
            return - std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct equal_to
template<> struct equal_to<int> : public binary_function<int, int, bool> {
        constexpr bool operator()(const int &__x, const int &__y) const;
    };
    template <typename _Tp = void> struct not_equal_to;
    template <typename _Tp = void> struct greater
template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less
template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    }
template<> struct less<const std::_V2::error_category *> : public binary_function<const std::_V2::error_category *, const std::_V2::error_category *, bool> {
        constexpr bool operator()(const std::_V2::error_category *__x, const std::_V2::error_category *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal
template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal
template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x == __y;
        }
    };
template<> struct equal_to<int> : public binary_function<int, int, bool> {
        constexpr bool operator()(const int &__x, const int &__y) const;
    };
    template <typename _Tp = void> struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x != __y;
        }
    };
    template <typename _Tp = void> struct greater : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x > __y;
        }
    };
template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x < __y;
        }
    };
template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
template<> struct less<const std::_V2::error_category *> : public binary_function<const std::_V2::error_category *, const std::_V2::error_category *, bool> {
        constexpr bool operator()(const std::_V2::error_category *__x, const std::_V2::error_category *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x >= __y;
        }
    };
template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x <= __y;
        }
    };
template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template<> struct equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct not_equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct greater<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return greater<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return greater<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return less<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return less<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct greater_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return greater_equal<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return greater_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return less_equal<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return less_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template <typename _Tp = void> struct logical_and;
    template <typename _Tp = void> struct logical_or;
    template <typename _Tp = void> struct logical_not;
    template <typename _Tp = void> struct logical_and : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x && __y;
        }
    };
    template <typename _Tp = void> struct logical_or : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x || __y;
        }
    };
    template <typename _Tp = void> struct logical_not : public unary_function<_Tp, bool> {
        constexpr bool operator()(const _Tp &__x) const         {
            return !__x;
        }
    };
    template<> struct logical_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))) -> decltype(!std::forward<_Tp>(__t))         {
            return !std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct bit_and;
    template <typename _Tp = void> struct bit_or;
    template <typename _Tp = void> struct bit_xor;
    template <typename _Tp = void> struct bit_not;
    template <typename _Tp = void> struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x & __y;
        }
    };
    template <typename _Tp = void> struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x | __y;
        }
    };
    template <typename _Tp = void> struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x ^ __y;
        }
    };
    template <typename _Tp = void> struct bit_not : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const         {
            return ~__x;
        }
    };
    template<> struct bit_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_xor<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))) -> decltype(~std::forward<_Tp>(__t))         {
            return ~std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Predicate> class unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit unary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }
        constexpr bool operator()(const typename _Predicate::argument_type &__x) const         {
            return !this->_M_pred(__x);
        }
    };
    template <typename _Predicate> inline constexpr unary_negate<_Predicate> not1(const _Predicate &__pred)     {
        return unary_negate<_Predicate>(__pred);
    }
    template <typename _Predicate> class binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit binary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }
        constexpr bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const         {
            return !this->_M_pred(__x, __y);
        }
    };
    template <typename _Predicate> inline constexpr binary_negate<_Predicate> not2(const _Predicate &__pred)     {
        return binary_negate<_Predicate>(__pred);
    }
    template <typename _Arg, typename _Result> class pointer_to_unary_function : public unary_function<_Arg, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg);
    public:
        pointer_to_unary_function<_Arg, _Result>()         {
        }
        explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__x)(_Arg)) : _M_ptr(__x)         {
        }
        _Result operator()(_Arg __x) const         {
            return this->_M_ptr(__x);
        }
    };
    template <typename _Arg, typename _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))     {
        return pointer_to_unary_function<_Arg, _Result>(__x);
    }
    template <typename _Arg1, typename _Arg2, typename _Result> class pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
        pointer_to_binary_function<_Arg1, _Arg2, _Result>()         {
        }
        explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x)         {
        }
        _Result operator()(_Arg1 __x, _Arg2 __y) const         {
            return this->_M_ptr(__x, __y);
        }
    };
    template <typename _Arg1, typename _Arg2, typename _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2))     {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
    }
    template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
        _Tp &operator()(_Tp &__x) const         {
            return __x;
        }
        const _Tp &operator()(const _Tp &__x) const         {
            return __x;
        }
    };
    template <typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> {
    };
    template <typename _Pair> struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
        typename _Pair::first_type &operator()(_Pair &__x) const         {
            return __x.first;
        }
        const typename _Pair::first_type &operator()(const _Pair &__x) const         {
            return __x.first;
        }
        template <typename _Pair2> typename _Pair2::first_type &operator()(_Pair2 &__x) const         {
            return __x.first;
        }
        template <typename _Pair2> const typename _Pair2::first_type &operator()(const _Pair2 &__x) const         {
            return __x.first;
        }
    };
    template <typename _Pair> struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
        typename _Pair::second_type &operator()(_Pair &__x) const         {
            return __x.second;
        }
        const typename _Pair::second_type &operator()(const _Pair &__x) const         {
            return __x.second;
        }
    };
    template <typename _Ret, typename _Tp> class mem_fun_t : public unary_function<_Tp *, _Ret> {
    public:
        explicit mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
    public:
        explicit const_mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp> class mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp &__r) const         {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit const_mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp &__r) const         {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
    public:
        explicit mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp> inline mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)())     {
        return mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const)     {
        return const_mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)())     {
        return mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)     {
        return const_mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))     {
        return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)     {
        return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))     {
        return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)     {
        return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
}
namespace std {
    template <typename _Operation> class __attribute__((deprecated(""))) binder1st : public unary_function<typename _Operation::second_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::first_argument_type value;
    public:
        binder1st<_Operation>(const _Operation &__x, const typename _Operation::first_argument_type &__y) : op(__x), value(__y)         {
        }
        typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }
        typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }
    };
    template <typename _Operation, typename _Tp> inline binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x)     {
        typedef typename _Operation::first_argument_type _Arg1_type;
        return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
    template <typename _Operation> class __attribute__((deprecated(""))) binder2nd : public unary_function<typename _Operation::first_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::second_argument_type value;
    public:
        binder2nd<_Operation>(const _Operation &__x, const typename _Operation::second_argument_type &__y) : op(__x), value(__y)         {
        }
        typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }
        typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }
    };
    template <typename _Operation, typename _Tp> inline binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x)     {
        typedef typename _Operation::second_argument_type _Arg2_type;
        return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
}
namespace std {
    template <class _E> class initializer_list {
    public:
        typedef _E value_type;
        typedef const _E &reference;
        typedef const _E &const_reference;
        typedef std::size_t size_type;
        typedef const _E *iterator;
        typedef const _E *const_iterator;
    private:
        std::initializer_list::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list<_E>(std::initializer_list::const_iterator __a, std::initializer_list::size_type __l) : _M_array(__a), _M_len(__l)         {
        }
    public:
        constexpr initializer_list<_E>() noexcept : _M_array(0), _M_len(0)         {
        }
        constexpr std::initializer_list::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::initializer_list::const_iterator begin() const noexcept         {
            return this->_M_array;
        }
        constexpr std::initializer_list::const_iterator end() const noexcept         {
            return this->begin() + this->size();
        }
    };
template<> class initializer_list<char> {
    public:
        typedef char value_type;
        typedef const char &reference;
        typedef const char &const_reference;
        typedef std::size_t size_type;
        typedef const char *iterator;
        typedef const char *const_iterator;
    private:
        std::initializer_list<char>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char>::const_iterator end() const noexcept;
    };
template<> class initializer_list<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef const wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef std::size_t size_type;
        typedef const wchar_t *iterator;
        typedef const wchar_t *const_iterator;
    private:
        std::initializer_list<wchar_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<wchar_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator end() const noexcept;
    };
template<> class initializer_list<char16_t> {
    public:
        typedef char16_t value_type;
        typedef const char16_t &reference;
        typedef const char16_t &const_reference;
        typedef std::size_t size_type;
        typedef const char16_t *iterator;
        typedef const char16_t *const_iterator;
    private:
        std::initializer_list<char16_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char16_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator end() const noexcept;
    };
template<> class initializer_list<char32_t> {
    public:
        typedef char32_t value_type;
        typedef const char32_t &reference;
        typedef const char32_t &const_reference;
        typedef std::size_t size_type;
        typedef const char32_t *iterator;
        typedef const char32_t *const_iterator;
    private:
        std::initializer_list<char32_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char32_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator end() const noexcept;
    };
    template <class _Tp> constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept     {
        return __ils.begin();
    }
    template <class _Tp> constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept     {
        return __ils.end();
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp, bool = is_signed<_Tp>::value> struct __int_limits {
            static_assert(is_integral<_Tp>::value, "unsupported specialization");
            using _Up = typename make_unsigned<_Tp>::type;
            static constexpr int digits = sizeof(_Tp) * 8 - 1;
            static constexpr _Tp min() noexcept             {
                return _Tp(std::__detail::__int_limits::_Up(1) << digits);
            }
            static constexpr _Tp max() noexcept             {
                return _Tp(std::__detail::__int_limits::_Up(~std::__detail::__int_limits::_Up(0)) >> 1);
            }
        };
template<> struct __int_limits<int, true> {
            static_assert(is_integral<int>::value, "unsupported specialization");
            using _Up = typename make_unsigned<int>::type;
            static constexpr int digits = sizeof(int) * 8 - 1;
            static constexpr int min() noexcept             {
                return int(std::__detail::__int_limits<int, true>::_Up(1) << digits);
            }
            static constexpr int max() noexcept             {
                return int(std::__detail::__int_limits<int, true>::_Up(~std::__detail::__int_limits<int, true>::_Up(0)) >> 1);
            }
        };
        template <typename _Tp> struct __int_limits<_Tp, false> {
            static_assert(is_integral<_Tp>::value, "unsupported specialization");
            static constexpr int digits = sizeof(_Tp) * 8;
            static constexpr _Tp min() noexcept             {
                return 0;
            }
            static constexpr _Tp max() noexcept             {
                return _Tp(-1);
            }
        };
        template<> struct __int_limits<bool>;
    }
}
namespace std {
    template <typename _Container> inline constexpr auto begin(_Container &__cont) -> decltype(__cont.begin())     {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto begin(const _Container &__cont) -> decltype(__cont.begin())     {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto end(_Container &__cont) -> decltype(__cont.end())     {
        return __cont.end();
    }
    template <typename _Container> inline constexpr auto end(const _Container &__cont) -> decltype(__cont.end())     {
        return __cont.end();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *begin(_Tp (&__arr)[_Nm])     {
        return __arr;
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *end(_Tp (&__arr)[_Nm])     {
        return __arr + _Nm;
    }
    template <typename _Tp> class valarray;
    template <typename _Tp> _Tp *begin(valarray<_Tp> &);
    template <typename _Tp> const _Tp *begin(const valarray<_Tp> &);
    template <typename _Tp> _Tp *end(valarray<_Tp> &);
    template <typename _Tp> const _Tp *end(const valarray<_Tp> &);
    template <typename _Container> inline constexpr auto cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))) -> decltype(std::begin(__cont))     {
        return std::begin(__cont);
    }
    template <typename _Container> inline constexpr auto cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))) -> decltype(std::end(__cont))     {
        return std::end(__cont);
    }
    template <typename _Container> inline constexpr auto rbegin(_Container &__cont) -> decltype(__cont.rbegin())     {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rbegin(const _Container &__cont) -> decltype(__cont.rbegin())     {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rend(_Container &__cont) -> decltype(__cont.rend())     {
        return __cont.rend();
    }
    template <typename _Container> inline constexpr auto rend(const _Container &__cont) -> decltype(__cont.rend())     {
        return __cont.rend();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr reverse_iterator<_Tp *> rbegin(_Tp (&__arr)[_Nm])     {
        return reverse_iterator<_Tp *>(__arr + _Nm);
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr reverse_iterator<_Tp *> rend(_Tp (&__arr)[_Nm])     {
        return reverse_iterator<_Tp *>(__arr);
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rbegin(initializer_list<_Tp> __il)     {
        return reverse_iterator<const _Tp *>(__il.end());
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rend(initializer_list<_Tp> __il)     {
        return reverse_iterator<const _Tp *>(__il.begin());
    }
    template <typename _Container> inline constexpr auto crbegin(const _Container &__cont) -> decltype(std::rbegin(__cont))     {
        return std::rbegin(__cont);
    }
    template <typename _Container> inline constexpr auto crend(const _Container &__cont) -> decltype(std::rend(__cont))     {
        return std::rend(__cont);
    }
    template <typename _Container> constexpr auto size(const _Container &__cont) noexcept(noexcept(__cont.size())size(const _Container &__cont) noexcept(noexcept(__cont.size())) -> decltype(__cont.size())     {
        return __cont.size();
    }
    template <typename _Tp, std::size_t _Nm> constexpr std::size_t size(const _Tp (&)[_Nm]) noexcept     {
        return _Nm;
    }
    template <typename _Container> constexpr auto empty(const _Container &__cont) noexcept(noexcept(__cont.empty())empty(const _Container &__cont) noexcept(noexcept(__cont.empty())) -> decltype(__cont.empty()) [[nodiscard("")]]     {
        return __cont.empty();
    }
    template <typename _Tp, std::size_t _Nm> constexpr bool empty(const _Tp (&)[_Nm]) noexcept [[nodiscard("")]]     {
        return false;
    }
    template <typename _Tp> constexpr bool empty(initializer_list<_Tp> __il) noexcept [[nodiscard("")]]     {
        return __il.size() == 0;
    }
    template <typename _Container> constexpr auto data(_Container &__cont) noexcept(noexcept(__cont.data())data(_Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data())     {
        return __cont.data();
    }
    template <typename _Container> constexpr auto data(const _Container &__cont) noexcept(noexcept(__cont.data())data(const _Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data())     {
        return __cont.data();
    }
    template <typename _Tp, std::size_t _Nm> constexpr _Tp *data(_Tp (&__array)[_Nm]) noexcept     {
        return __array;
    }
    template <typename _Tp> constexpr const _Tp *data(initializer_list<_Tp> __il) noexcept     {
        return __il.begin();
    }
}
namespace std {
    template <typename _Tp> inline void destroy_at(_Tp *__location)     {
        if (201703L > 201703L && is_array_v<_Tp>) {
            for (auto &__x : *__location)
                std::destroy_at(std::__addressof(__x));
        } else
            __location->~_Tp();
    }
    template <typename _Tp, typename ..._Args> inline void _Construct(_Tp *__p, _Args &&...__args)     {
        ::new (static_cast<void *>(__p)) _Tp((std::forward<_Args>(__args)...));
    }
    template <typename _T1> inline void _Construct_novalue(_T1 *__p)     {
        ::new (static_cast<void *>(__p)) _T1;
    }
    template <typename _ForwardIterator> void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
    template <typename _Tp> inline constexpr void _Destroy(_Tp *__pointer)     {
        __pointer->~_Tp();
    }
    template <bool> struct _Destroy_aux {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator __first, _ForwardIterator __last)         {
            for (; __first != __last; ++__first)
                std::_Destroy(std::__addressof(*__first));
        }
    };
    template<> struct _Destroy_aux<true> {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator, _ForwardIterator)         {
        }
    };
    template <typename _ForwardIterator> inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
    }
    template <bool> struct _Destroy_n_aux {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count)         {
            for (; __count > 0; (void)++__first , --__count)
                std::_Destroy(std::__addressof(*__first));
            return __first;
        }
    };
    template<> struct _Destroy_n_aux<true> {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count)         {
            std::advance(__first, __count);
            return __first;
        }
    };
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator _Destroy_n(_ForwardIterator __first, _Size __count)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::__destroy_n(__first, __count);
    }
    template <typename _ForwardIterator> inline void destroy(_ForwardIterator __first, _ForwardIterator __last)     {
        std::_Destroy(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline _ForwardIterator destroy_n(_ForwardIterator __first, _Size __count)     {
        return std::_Destroy_n(__first, __count);
    }
}
namespace std {
    struct __allocator_traits_base {
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
template<> struct __rebind<std::allocator<std::pair<const int, int>>, std::__detail::_Hash_node<std::pair<const int, int>, false>, void> {
            using type = typename allocator<pair<const int, int>>::rebind<_Hash_node<pair<const int, int>, false>>::other;
        };
template<> struct __rebind<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, std::__detail::_Hash_node_base *, void> {
            using type = typename allocator<_Hash_node<pair<const int, int>, false>>::rebind<_Hash_node_base *>::other;
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other>> {
            using type = typename _Tp::template rebind<_Up>::other;
        };
    protected:
        template <typename _Tp> using __pointer = typename _Tp::pointer;
        template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;
        template <typename _Tp> using __v_pointer = typename _Tp::void_pointer;
        template <typename _Tp> using __cv_pointer = typename _Tp::const_void_pointer;
        template <typename _Tp> using __pocca = typename _Tp::propagate_on_container_copy_assignment;
        template <typename _Tp> using __pocma = typename _Tp::propagate_on_container_move_assignment;
        template <typename _Tp> using __pocs = typename _Tp::propagate_on_container_swap;
        template <typename _Tp> using __equal = typename _Tp::is_always_equal;
    };
    template <typename _Alloc, typename _Up> using __alloc_rebind = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
    template <typename _Alloc> struct allocator_traits : std::__allocator_traits_base {
        typedef _Alloc allocator_type;
        typedef typename _Alloc::value_type value_type;
        using pointer = __detected_or_t<std::allocator_traits::value_type *, __pointer, _Alloc>;
    private:
        template <template <typename> class _Func, typename _Tp, typename = void> struct _Ptr {
            using type = typename pointer_traits<pointer>::template rebind<_Tp>;
        };
        template <template <typename> class _Func, typename _Tp> struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>> {
            using type = _Func<_Alloc>;
        };
        template <typename _A2, typename _PtrT, typename = void> struct _Diff {
            using type = typename pointer_traits<_PtrT>::difference_type;
        };
        template <typename _A2, typename _PtrT> struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>> {
            using type = typename _A2::difference_type;
        };
        template <typename _A2, typename _DiffT, typename = void> struct _Size : make_unsigned<_DiffT> {
        };
        template <typename _A2, typename _DiffT> struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
            using type = typename _A2::size_type;
        };
    public:
        using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
        using void_pointer = typename _Ptr<__v_pointer, void>::type;
        using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
        using difference_type = typename _Diff<_Alloc, pointer>::type;
        using size_type = typename _Size<_Alloc, difference_type>::type;
        using propagate_on_container_copy_assignment = __detected_or_t<std::false_type, __pocca, _Alloc>;
        using propagate_on_container_move_assignment = __detected_or_t<std::false_type, __pocma, _Alloc>;
        using propagate_on_container_swap = __detected_or_t<std::false_type, __pocs, _Alloc>;
        using is_always_equal = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;
        template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
        template <typename _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
    private:
        template <typename _Alloc2> static constexpr auto _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint, int) -> decltype(__a.allocate(__n, __hint))         {
            return __a.allocate(__n, __hint);
        }
        template <typename _Alloc2> static constexpr std::allocator_traits::pointer _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer, ...)         {
            return __a.allocate(__n);
        }
        template <typename _Tp, typename ..._Args> struct __construct_helper {
            template <typename _Alloc2, typename = decltype(std::declval<_Alloc2 *>()->construct(std::declval<_Tp *>(), std::declval<_Args>()...))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
            using type = decltype(__test<_Alloc>(0));
        };
        template <typename _Tp, typename ..._Args> using __has_construct = typename __construct_helper<_Tp, _Args...>::type;
        template <typename _Tp, typename ..._Args> static constexpr _Require<__has_construct<_Tp, _Args...>> _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...))_S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))         {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp, typename ..._Args> static constexpr _Require<__and_<__not_<__has_construct<_Tp, _Args...>>, is_constructible<_Tp, _Args...>>> _S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value_S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)         {
            ::new ((void *)__p) _Tp((std::forward<_Args>(__args)...));
        }
        template <typename _Alloc2, typename _Tp> static constexpr auto _S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))_S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))) -> decltype(__a.destroy(__p))         {
            __a.destroy(__p);
        }
        template <typename _Alloc2, typename _Tp> static constexpr void _S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(std::is_nothrow_destructible<_Tp>::value_S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(std::is_nothrow_destructible<_Tp>::value)         {
            std::_Destroy(__p);
        }
        template <typename _Alloc2> static constexpr auto _S_max_size(_Alloc2 &__a, int) -> decltype(__a.max_size())         {
            return __a.max_size();
        }
        template <typename _Alloc2> static constexpr std::allocator_traits::size_type _S_max_size(_Alloc2 &, ...)         {
            return __gnu_cxx::__numeric_traits<size_type>::__max / sizeof(std::allocator_traits::value_type);
        }
        template <typename _Alloc2> static constexpr auto _S_select(_Alloc2 &__a, int) -> decltype(__a.select_on_container_copy_construction())         {
            return __a.select_on_container_copy_construction();
        }
        template <typename _Alloc2> static constexpr _Alloc2 _S_select(_Alloc2 &__a, ...)         {
            return __a;
        }
    public:
        static std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint) [[nodiscard("")]]         {
            return _S_allocate(__a, __n, __hint, 0);
        }
        static void deallocate(_Alloc &__a, std::allocator_traits::pointer __p, std::allocator_traits::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Tp, typename ..._Args> static auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))) -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))         {
            _S_construct(__a, __p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp> static void destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0)))         {
            _S_destroy(__a, __p, 0);
        }
        static std::allocator_traits::size_type max_size(const _Alloc &__a) noexcept         {
            return _S_max_size(__a, 0);
        }
        static _Alloc select_on_container_copy_construction(const _Alloc &__rhs)         {
            return _S_select(__rhs, 0);
        }
    };
template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static void deallocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<std::allocator<char>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char>>::size_type max_size(const std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char>>::allocator_type &__rhs)         {
            return __rhs;
        }
    };
template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static void deallocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<std::allocator<wchar_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<wchar_t>>::size_type max_size(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static std::allocator_traits<std::allocator<wchar_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static void deallocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char16_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char16_t>>::size_type max_size(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char16_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static void deallocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char32_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<char32_t>>::size_type max_size(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char32_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> {
        using allocator_type = allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>;
        using value_type = std::__detail::_Hash_node<std::pair<const int, int>, false>;
        using pointer = std::__detail::_Hash_node<std::pair<const int, int>, false> *;
        using const_pointer = const std::__detail::_Hash_node<std::pair<const int, int>, false> *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::pointer allocate(std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::pointer allocate(std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static void deallocate(std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type &__a, std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n);
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::size_type max_size(const std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type &__a __attribute__((unused))) noexcept;
        static std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<std::pair<const int, int>>> {
        using allocator_type = allocator<std::pair<const int, int>>;
        using value_type = std::pair<const int, int>;
        using pointer = std::pair<const int, int> *;
        using const_pointer = const std::pair<const int, int> *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<std::allocator<std::pair<const int, int>>>::pointer allocate(std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static std::allocator_traits<std::allocator<std::pair<const int, int>>>::pointer allocate(std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static void deallocate(std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type &__a, std::allocator_traits<std::allocator<std::pair<const int, int>>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n);
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static std::allocator_traits<std::allocator<std::pair<const int, int>>>::size_type max_size(const std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type &__a __attribute__((unused))) noexcept;
        static std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<std::pair<const int, int>>>::allocator_type &__rhs);
    };
    template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
        using allocator_type = allocator<_Tp>;
        using value_type = _Tp;
        using pointer = _Tp *;
        using const_pointer = const _Tp *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static std::allocator_traits<allocator<type-parameter-0-0>>::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static std::allocator_traits<allocator<type-parameter-0-0>>::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]]         {
            return __a.allocate(__n, __hint);
        }
        static void deallocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::valueconstruct(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)         {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static void destroy(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p) noexcept(is_nothrow_destructible<_Up>::valuedestroy(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p) noexcept(is_nothrow_destructible<_Up>::value)         {
            __a.destroy(__p);
        }
        static std::allocator_traits<allocator<type-parameter-0-0>>::size_type max_size(const std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__rhs)         {
            return __rhs;
        }
    };
    template <typename _Alloc> inline constexpr void __alloc_on_copy(_Alloc &__one, const _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_copy_assignment __pocca;
        if (__pocca::value)
            __one = __two;
    }
    template <typename _Alloc> constexpr _Alloc __alloc_on_copy(const _Alloc &__a)     {
        typedef allocator_traits<_Alloc> __traits;
        return __traits::select_on_container_copy_construction(__a);
    }
    template <typename _Alloc> inline constexpr void __alloc_on_move(_Alloc &__one, _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_move_assignment __pocma;
        if (__pocma::value)
            __one = std::move(__two);
    }
    template <typename _Alloc> inline constexpr void __alloc_on_swap(_Alloc &__one, _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_swap __pocs;
        if (__pocs::value) {
            using std::swap;
            swap(__one, __two);
        }
    }
    template <typename _Alloc, typename _Tp, typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>, typename = void> struct __is_alloc_insertable_impl : std::false_type {
    };
    template <typename _Alloc, typename _Tp, typename _ValueT> struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, __void_t<decltype(allocator_traits<_Alloc>::construct(std::declval<_Alloc &>(), std::declval<_ValueT *>(), std::declval<_Tp>()))>> : std::true_type {
    };
    template <typename _Alloc> struct __is_copy_insertable : __is_alloc_insertable_impl<_Alloc, const typename _Alloc::value_type &>::type {
    };
    template <typename _Tp> struct __is_copy_insertable<allocator<_Tp>> : is_copy_constructible<_Tp> {
    };
    template <typename _Alloc> struct __is_move_insertable : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type {
    };
    template <typename _Tp> struct __is_move_insertable<allocator<_Tp>> : is_move_constructible<_Tp> {
    };
    template <typename _Alloc, typename = void> struct __is_allocator : std::false_type {
    };
template<> struct __is_allocator<std::allocator<char>, void> : std::true_type {
    };
template<> struct __is_allocator<std::allocator<wchar_t>, void> : std::true_type {
    };
template<> struct __is_allocator<std::allocator<char16_t>, void> : std::true_type {
    };
template<> struct __is_allocator<std::allocator<char32_t>, void> : std::true_type {
    };
    template <typename _Alloc> struct __is_allocator<_Alloc, __void_t<typename _Alloc::value_type, decltype(std::declval<_Alloc &>().allocate(std::size_t{}))>> : std::true_type {
    };
    template <typename _Alloc> using _RequireAllocator = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _Alloc> using _RequireNotAllocator = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _ForwardIterator, typename _Allocator> void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)     {
        for (; __first != __last; ++__first)
            allocator_traits<_Allocator>::destroy(__alloc, std::__addressof(*__first));
    }
    template <typename _ForwardIterator, typename _Tp> inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &)     {
        _Destroy(__first, __last);
    }
}
namespace __gnu_cxx {
    template <typename _Alloc, typename = typename _Alloc::value_type> struct __alloc_traits : std::allocator_traits<_Alloc> {
        typedef _Alloc allocator_type;
        typedef std::allocator_traits<_Alloc> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...))construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...)))         {
            _Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...);
        }
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p)))destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))         {
            _Base_type::destroy(__a, std::__to_address(__p));
        }
        static constexpr _Alloc _S_select_on_copy(const _Alloc &__a)         {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(_Alloc &__a, _Alloc &__b)         {
            std::__alloc_on_swap(__a, __b);
        }
        static constexpr bool _S_propagate_on_copy_assign()         {
            return _Base_type::propagate_on_container_copy_assignment::value;
        }
        static constexpr bool _S_propagate_on_move_assign()         {
            return _Base_type::propagate_on_container_move_assignment::value;
        }
        static constexpr bool _S_propagate_on_swap()         {
            return _Base_type::propagate_on_container_swap::value;
        }
        static constexpr bool _S_always_equal()         {
            return _Base_type::is_always_equal::value;
        }
        static constexpr bool _S_nothrow_move()         {
            return _S_propagate_on_move_assign() || _S_always_equal();
        }
        template <typename _Tp> struct rebind {
            typedef typename _Base_type::template rebind_alloc<_Tp> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char>, char> : std::allocator_traits<allocator<char>> {
        typedef std::allocator<char> allocator_type;
        typedef std::allocator_traits<allocator<char>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char> &__a, _Ptr __p);
        static constexpr std::allocator<char> _S_select_on_copy(const std::allocator<char> &__a)         {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(std::allocator<char> &__a, std::allocator<char> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char> {
            typedef typename _Base_type::rebind_alloc<char> other;
        };
    };
template<> struct __alloc_traits<std::allocator<wchar_t>, wchar_t> : std::allocator_traits<allocator<wchar_t>> {
        typedef std::allocator<wchar_t> allocator_type;
        typedef std::allocator_traits<allocator<wchar_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<wchar_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<wchar_t> &__a, _Ptr __p);
        static constexpr std::allocator<wchar_t> _S_select_on_copy(const std::allocator<wchar_t> &__a);
        static constexpr void _S_on_swap(std::allocator<wchar_t> &__a, std::allocator<wchar_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<wchar_t> {
            typedef typename _Base_type::rebind_alloc<wchar_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char16_t>, char16_t> : std::allocator_traits<allocator<char16_t>> {
        typedef std::allocator<char16_t> allocator_type;
        typedef std::allocator_traits<allocator<char16_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char16_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char16_t> &__a, _Ptr __p);
        static constexpr std::allocator<char16_t> _S_select_on_copy(const std::allocator<char16_t> &__a);
        static constexpr void _S_on_swap(std::allocator<char16_t> &__a, std::allocator<char16_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char16_t> {
            typedef typename _Base_type::rebind_alloc<char16_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char32_t>, char32_t> : std::allocator_traits<allocator<char32_t>> {
        typedef std::allocator<char32_t> allocator_type;
        typedef std::allocator_traits<allocator<char32_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char32_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char32_t> &__a, _Ptr __p);
        static constexpr std::allocator<char32_t> _S_select_on_copy(const std::allocator<char32_t> &__a);
        static constexpr void _S_on_swap(std::allocator<char32_t> &__a, std::allocator<char32_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char32_t> {
            typedef typename _Base_type::rebind_alloc<char32_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, std::__detail::_Hash_node<std::pair<const int, int>, false>> : std::allocator_traits<allocator<_Hash_node<pair<const int, int>, false>>> {
        typedef std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> allocator_type;
        typedef std::allocator_traits<allocator<_Hash_node<pair<const int, int>, false>>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, std::__detail::_Hash_node<std::pair<const int, int>, false>>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, std::__detail::_Hash_node<std::pair<const int, int>, false>>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &__a, _Ptr __p);
        static constexpr std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> _S_select_on_copy(const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &__a);
        static constexpr void _S_on_swap(std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &__a, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind;
    };
}
namespace std {
    template <typename _Result, typename _Arg> struct __hash_base {
        typedef _Result result_type [[deprecated("")]];
        typedef _Arg argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, bool> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef bool argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, signed char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef signed char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, wchar_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef wchar_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char16_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char16_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char32_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char32_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef short argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef int argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned short argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned int argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, float> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef float argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef double argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long double argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, nullptr_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef nullptr_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char, std::char_traits<char>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char, std::char_traits<char>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<wchar_t, std::char_traits<wchar_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char16_t, std::char_traits<char16_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char16_t, std::char_traits<char16_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char32_t, std::char_traits<char32_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char32_t, std::char_traits<char32_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<wchar_t>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<wchar_t> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::error_code> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::error_code argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::error_condition> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::error_condition argument_type [[deprecated("")]];
    };
    template <typename _Tp> struct hash;
    template <typename _Tp, typename = void> struct __poison_hash {
        static constexpr bool __enable_hash_call = false;
    private:
        __poison_hash<_Tp, type-parameter-0-1>(__poison_hash<_Tp, type-parameter-0-1> &&);
        ~__poison_hash<_Tp, type-parameter-0-1>();
    };
    template <typename _Tp> struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
        static constexpr bool __enable_hash_call = true;
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
    private:
        __hash_enum<_Tp, >(__hash_enum<_Tp, > &&);
        ~__hash_enum<_Tp, >();
    };
    template <typename _Tp> struct __hash_enum<_Tp, true> : public __hash_base<std::size_t, _Tp> {
        std::size_t operator()(_Tp __val) const noexcept         {
            using __type = typename underlying_type<_Tp>::type;
            return hash<__type>({})(static_cast<__type>(__val));
        }
    };
    template <typename _Tp> struct hash : __hash_enum<_Tp> {
    };
    template <typename _Tp> struct hash<_Tp *> : public __hash_base<std::size_t, _Tp *> {
        std::size_t operator()(_Tp *__p) const noexcept         {
            return reinterpret_cast<std::size_t>(__p);
        }
    };
    template<> struct hash<bool> : public __hash_base<std::size_t, bool> {
        std::size_t operator()(bool __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char> : public __hash_base<std::size_t, char> {
        std::size_t operator()(char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<signed char> : public __hash_base<std::size_t, signed char> {
        std::size_t operator()(signed char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned char> : public __hash_base<std::size_t, unsigned char> {
        std::size_t operator()(unsigned char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<wchar_t> : public __hash_base<std::size_t, wchar_t> {
        std::size_t operator()(wchar_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char16_t> : public __hash_base<std::size_t, char16_t> {
        std::size_t operator()(char16_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char32_t> : public __hash_base<std::size_t, char32_t> {
        std::size_t operator()(char32_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<short> : public __hash_base<std::size_t, short> {
        std::size_t operator()(short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<int> : public __hash_base<std::size_t, int> {
        std::size_t operator()(int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long> : public __hash_base<std::size_t, long> {
        std::size_t operator()(long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long long> : public __hash_base<std::size_t, long long> {
        std::size_t operator()(long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned short> : public __hash_base<std::size_t, unsigned short> {
        std::size_t operator()(unsigned short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned int> : public __hash_base<std::size_t, unsigned int> {
        std::size_t operator()(unsigned int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long> : public __hash_base<std::size_t, unsigned long> {
        std::size_t operator()(unsigned long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long long> : public __hash_base<std::size_t, unsigned long long> {
        std::size_t operator()(unsigned long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    struct _Hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(3339675911UL))         {
            return _Hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<float>(const float &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<double>(const double &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<int>(const int &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
        template<> static std::size_t __hash_combine<const std::_V2::error_category *>(const std::_V2::error_category *const &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    struct _Fnv_hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(2166136261UL))         {
            return _Fnv_hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    template<> struct hash<float> : public __hash_base<std::size_t, float> {
        std::size_t operator()(float __val) const noexcept         {
            return __val != 0.F ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<double> : public __hash_base<std::size_t, double> {
        std::size_t operator()(double __val) const noexcept         {
            return __val != 0. ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<long double> : public __hash_base<std::size_t, long double> {
        std::size_t operator()(long double __val) const noexcept __attribute__((pure));
    };
    template<> struct hash<std::nullptr_t> : public __hash_base<std::size_t, std::nullptr_t> {
        std::size_t operator()(std::nullptr_t) const noexcept         {
            return 0;
        }
    };
    template <typename _Hash> struct __is_fast_hash : public std::true_type {
    };
template<> struct __is_fast_hash<std::hash<int>> : public std::true_type {
    };
    template<> struct __is_fast_hash<hash<long double>> : public std::false_type {
    };
}
namespace std {
    constexpr std::size_t __sv_check(std::size_t __size, std::size_t __pos, const char *__s)     {
        if (__pos > __size)
            __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size (which is %zu)"), __s, __pos, __size);
        return __pos;
    }
    constexpr std::size_t __sv_limit(std::size_t __size, std::size_t __pos, std::size_t __off) noexcept     {
        const bool __testoff = __off < __size - __pos;
        return __testoff ? __off : __size - __pos;
    }
    template <typename _CharT, typename _Traits = std::char_traits<_CharT>> class basic_string_view {
        static_assert(!is_array_v<_CharT>);
        static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
        static_assert(is_same_v<_CharT, typename _Traits::char_type>);
    public:
        using traits_type = _Traits;
        using value_type = _CharT;
        using pointer = std::basic_string_view::value_type *;
        using const_pointer = const std::basic_string_view::value_type *;
        using reference = std::basic_string_view::value_type &;
        using const_reference = const std::basic_string_view::value_type &;
        using const_iterator = const std::basic_string_view::value_type *;
        using iterator = std::basic_string_view::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos = std::basic_string_view::size_type(-1);
        constexpr basic_string_view<_CharT, _Traits>() noexcept : _M_len({0}), _M_str({nullptr})         {
        }
        basic_string_view<_CharT, _Traits>(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str) noexcept : _M_len({traits_type::length(__str)}), _M_str({__str}) __attribute__((nonnull()))         {
        }
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        basic_string_view<_CharT, _Traits> &operator=(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr std::basic_string_view::const_iterator begin() const noexcept         {
            return this->_M_str;
        }
        constexpr std::basic_string_view::const_iterator end() const noexcept         {
            return this->_M_str + this->_M_len;
        }
        constexpr std::basic_string_view::const_iterator cbegin() const noexcept         {
            return this->_M_str;
        }
        constexpr std::basic_string_view::const_iterator cend() const noexcept         {
            return this->_M_str + this->_M_len;
        }
        constexpr std::basic_string_view::const_reverse_iterator rbegin() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->end());
        }
        constexpr std::basic_string_view::const_reverse_iterator rend() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->begin());
        }
        constexpr std::basic_string_view::const_reverse_iterator crbegin() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->end());
        }
        constexpr std::basic_string_view::const_reverse_iterator crend() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->begin());
        }
        constexpr std::basic_string_view::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept         {
            return (npos - sizeof(std::basic_string_view::size_type) - sizeof(void *)) / sizeof(std::basic_string_view::value_type) / 4;
        }
        constexpr bool empty() const noexcept [[nodiscard("")]]         {
            return this->_M_len == 0;
        }
        constexpr std::basic_string_view::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept         {
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view::const_reference at(std::basic_string_view::size_type __pos) const         {
            if (__pos >= this->_M_len)
                __throw_out_of_range_fmt(("basic_string_view::at: __pos (which is %zu) >= this->size() (which is %zu)"), __pos, this->size());
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view::const_reference front() const noexcept         {
            return *this->_M_str;
        }
        constexpr std::basic_string_view::const_reference back() const noexcept         {
            return *(this->_M_str + this->_M_len - 1);
        }
        constexpr std::basic_string_view::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept         {
            ;
            this->_M_str += __n;
            this->_M_len -= __n;
        }
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept         {
            this->_M_len -= __n;
        }
        constexpr void swap(basic_string_view<_CharT, _Traits> &__sv) noexcept         {
            auto __tmp = *this;
            *this = __sv;
            __sv = __tmp;
        }
        std::basic_string_view::size_type copy(_CharT *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos = 0) const         {
            ;
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::copy");
            const std::basic_string_view::size_type __rlen = std::min(__n, this->_M_len - __pos);
            traits_type::copy(__str, this->data() + __pos, __rlen);
            return __rlen;
        }
        constexpr basic_string_view<_CharT, _Traits> substr(std::basic_string_view::size_type __pos = 0, std::basic_string_view::size_type __n = npos) const noexcept(falsesubstr(std::basic_string_view::size_type __pos = 0, std::basic_string_view::size_type __n = npos) const noexcept(false)         {
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::substr");
            const std::basic_string_view::size_type __rlen = std::min(__n, this->_M_len - __pos);
            return basic_string_view<_CharT, _Traits>({this->_M_str + __pos, __rlen});
        }
        constexpr int compare(basic_string_view<_CharT, _Traits> __str) const noexcept         {
            const std::basic_string_view::size_type __rlen = std::min(this->_M_len, __str._M_len);
            int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
            if (__ret == 0)
                __ret = _S_compare(this->_M_len, __str._M_len);
            return __ret;
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __str) const         {
            return this->substr(__pos1, __n1).compare(__str);
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const         {
            return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
        }
        constexpr int compare(const _CharT *__str) const noexcept __attribute__((nonnull()))         {
            return this->compare(basic_string_view<_CharT, _Traits>({__str}));
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str) const __attribute__((nonnull()))         {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>({__str}));
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str, std::basic_string_view::size_type __n2) const noexcept(falsecompare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str, std::basic_string_view::size_type __n2) const noexcept(false)         {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>(__str, __n2));
        }
        constexpr std::basic_string_view::size_type find(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept;
        constexpr std::basic_string_view::size_type find(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type rfind(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->rfind(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type rfind(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept;
        constexpr std::basic_string_view::size_type rfind(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type rfind(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->rfind(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_first_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find_first_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_first_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find(__c, __pos);
        }
        constexpr std::basic_string_view::size_type find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find_first_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_last_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->find_last_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_last_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->rfind(__c, __pos);
        }
        constexpr std::basic_string_view::size_type find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->find_last_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_first_not_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find_first_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_first_not_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept;
        constexpr std::basic_string_view::size_type find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find_first_not_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_last_not_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->find_last_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_last_not_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept;
        constexpr std::basic_string_view::size_type find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->find_last_not_of(__str, __pos, traits_type::length(__str));
        }
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept         {
            const std::basic_string_view::difference_type __diff = __n1 - __n2;
            if (__diff > __detail::__int_limits<int>::max())
                return __detail::__int_limits<int>::max();
            if (__diff < __detail::__int_limits<int>::min())
                return __detail::__int_limits<int>::min();
            return static_cast<int>(__diff);
        }
        std::size_t _M_len;
        const _CharT *_M_str;
    };
template<> class basic_string_view<char, std::char_traits<char>> {
        static_assert(!is_array_v<char>);
        static_assert(is_trivial_v<char> && is_standard_layout_v<char>);
        static_assert(is_same_v<char, typename char_traits<char>::char_type>);
    public:
        using traits_type = std::char_traits<char>;
        using value_type = char;
        using pointer = std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using const_pointer = const std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using reference = std::basic_string_view<char, std::char_traits<char>>::value_type &;
        using const_reference = const std::basic_string_view<char, std::char_traits<char>>::value_type &;
        using const_iterator = const std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using iterator = std::basic_string_view<char, std::char_traits<char>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char, std::char_traits<char>> &) noexcept = default
        constexpr basic_string_view(const char *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        std::basic_string_view<char, std::char_traits<char>> &operator=(const std::basic_string_view<char, std::char_traits<char>> &) noexcept = default
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char, std::char_traits<char>> &__sv) noexcept;
        std::basic_string_view<char, std::char_traits<char>>::size_type copy(char *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char, std::char_traits<char>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char, std::char_traits<char>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char, std::char_traits<char>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char *__str, std::basic_string_view::size_type __n2) const;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char *_M_str;
    };
template<> class basic_string_view<wchar_t, std::char_traits<wchar_t>> {
        static_assert(!is_array_v<wchar_t>);
        static_assert(is_trivial_v<wchar_t> && is_standard_layout_v<wchar_t>);
        static_assert(is_same_v<wchar_t, typename char_traits<wchar_t>::char_type>);
    public:
        using traits_type = std::char_traits<wchar_t>;
        using value_type = wchar_t;
        using pointer = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using const_pointer = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using reference = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type &;
        using const_reference = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type &;
        using const_iterator = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using iterator = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &) noexcept = default
        constexpr basic_string_view(const wchar_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const wchar_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &operator=(const std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &) noexcept = default
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &__sv) noexcept;
        std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type copy(wchar_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const wchar_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const wchar_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const wchar_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const wchar_t *_M_str;
    };
template<> class basic_string_view<char16_t, std::char_traits<char16_t>> {
        static_assert(!is_array_v<char16_t>);
        static_assert(is_trivial_v<char16_t> && is_standard_layout_v<char16_t>);
        static_assert(is_same_v<char16_t, typename char_traits<char16_t>::char_type>);
    public:
        using traits_type = std::char_traits<char16_t>;
        using value_type = char16_t;
        using pointer = std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using reference = std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type &;
        using const_reference = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using iterator = std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char16_t, std::char_traits<char16_t>> &) noexcept = default
        constexpr basic_string_view(const char16_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char16_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        std::basic_string_view<char16_t, std::char_traits<char16_t>> &operator=(const std::basic_string_view<char16_t, std::char_traits<char16_t>> &) noexcept = default
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char16_t, std::char_traits<char16_t>> &__sv) noexcept;
        std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type copy(char16_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char16_t, std::char_traits<char16_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char16_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char16_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char16_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char16_t *_M_str;
    };
template<> class basic_string_view<char32_t, std::char_traits<char32_t>> {
        static_assert(!is_array_v<char32_t>);
        static_assert(is_trivial_v<char32_t> && is_standard_layout_v<char32_t>);
        static_assert(is_same_v<char32_t, typename char_traits<char32_t>::char_type>);
    public:
        using traits_type = std::char_traits<char32_t>;
        using value_type = char32_t;
        using pointer = std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using reference = std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type &;
        using const_reference = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using iterator = std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char32_t, std::char_traits<char32_t>> &) noexcept = default
        constexpr basic_string_view(const char32_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char32_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        std::basic_string_view<char32_t, std::char_traits<char32_t>> &operator=(const std::basic_string_view<char32_t, std::char_traits<char32_t>> &) noexcept = default
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char32_t, std::char_traits<char32_t>> &__sv) noexcept;
        std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type copy(char32_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char32_t, std::char_traits<char32_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char32_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char32_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char32_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char32_t *_M_str;
    };
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator==(__type_identity_t<basic_string_view<_CharT, _Traits>> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator!=(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return !(__x == __y);
    }
    template <typename _CharT, typename _Traits> constexpr bool operator!=(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return !(__x == __y);
    }
    template <typename _CharT, typename _Traits> constexpr bool operator!=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return !(__x == __y);
    }
    template <typename _CharT, typename _Traits> constexpr bool operator<(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) < 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator<(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return __x.compare(__y) < 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator<(__type_identity_t<basic_string_view<_CharT, _Traits>> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) < 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator>(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) > 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator>(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return __x.compare(__y) > 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator>(__type_identity_t<basic_string_view<_CharT, _Traits>> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) > 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator<=(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) <= 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator<=(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return __x.compare(__y) <= 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator<=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) <= 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator>=(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) >= 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator>=(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return __x.compare(__y) >= 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator>=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.compare(__y) >= 0;
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, basic_string_view<_CharT, _Traits> __str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__os, basic_string_view<char, std::char_traits<char>> __str)    using string_view = basic_string_view<char>;
    using wstring_view = basic_string_view<wchar_t>;
    using u16string_view = basic_string_view<char16_t>;
    using u32string_view = basic_string_view<char32_t>;
    template <typename _Tp> struct hash;
    template<> struct hash<std::string_view> : public __hash_base<std::size_t, std::string_view> {
        std::size_t operator()(const std::string_view &__str) const noexcept         {
            return std::_Hash_impl::hash(__str.data(), __str.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::string_view>> : std::false_type {
    };
    template<> struct hash<std::wstring_view> : public __hash_base<std::size_t, std::wstring_view> {
        std::size_t operator()(const std::wstring_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::wstring_view>> : std::false_type {
    };
    template<> struct hash<std::u16string_view> : public __hash_base<std::size_t, std::u16string_view> {
        std::size_t operator()(const std::u16string_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u16string_view>> : std::false_type {
    };
    template<> struct hash<std::u32string_view> : public __hash_base<std::size_t, std::u32string_view> {
        std::size_t operator()(const std::u32string_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u32string_view>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_view_literals {
            inline constexpr basic_string_view<char> operator""sv(const char *__str, std::size_t __len) noexcept             {
                return basic_string_view<char>{__str, __len};
            }
            inline constexpr basic_string_view<wchar_t> operator""sv(const wchar_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<wchar_t>{__str, __len};
            }
            inline constexpr basic_string_view<char16_t> operator""sv(const char16_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char16_t>{__str, __len};
            }
            inline constexpr basic_string_view<char32_t> operator""sv(const char32_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char32_t>{__str, __len};
            }
        }
    }
}
namespace std {
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        if (__n == 0)
            return __pos <= this->_M_len ? __pos : npos;
        if (__n <= this->_M_len) {
            for (; __pos <= this->_M_len - __n; ++__pos)
                if (traits_type::eq(this->_M_str[__pos], __str[0]) && traits_type::compare(this->_M_str + __pos + 1, __str + 1, __n - 1) == 0)
                    return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept     {
        std::basic_string_view::size_type __ret = npos;
        if (__pos < this->_M_len) {
            const std::basic_string_view::size_type __n = this->_M_len - __pos;
            const _CharT *__p = traits_type::find(this->_M_str + __pos, __n, __c);
            if (__p)
                __ret = __p - this->_M_str;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        if (__n <= this->_M_len) {
            __pos = std::min(std::basic_string_view::size_type(this->_M_len - __n), __pos);
            do {
                if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept     {
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size > 0) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(this->_M_str[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        for (; __n && __pos < this->_M_len; ++__pos) {
            const _CharT *__p = traits_type::find(__str, __n, this->_M_str[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        std::basic_string_view::size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::find(__str, __n, this->_M_str[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept     {
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::eq(this->_M_str[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept     {
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(this->_M_str[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
}
namespace std {
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef _Traits traits_type;
            typedef typename _Traits::char_type value_type;
            typedef std::__cxx11::basic_string::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string::size_type npos = static_cast<std::__cxx11::basic_string::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string::const_iterator __const_iterator;
        private:
            typedef basic_string_view<_CharT, _Traits> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<_CharT, _Traits, _Alloc> *>>, __not_<is_convertible<const _Tp &, const _CharT *>>>::value, _Res>;
            static std::__cxx11::basic_string::__sv_type _S_to_string_view(std::__cxx11::basic_string::__sv_type __svt) noexcept             {
                return __svt;
            }
            struct __sv_wrapper {
                explicit __sv_wrapper(std::__cxx11::basic_string::__sv_type __sv) noexcept : _M_sv(__sv)                 {
                }
                std::__cxx11::basic_string::__sv_type _M_sv;
            };
            explicit basic_string<_CharT, _Traits, _Alloc>(std::__cxx11::basic_string::__sv_wrapper __svw, const _Alloc &__a) : basic_string<_CharT, _Traits, _Alloc>(__svw._M_sv.data(), __svw._M_sv.size(), __a)             {
            }
            struct _Alloc_hider : std::__cxx11::basic_string::allocator_type {
                _Alloc_hider(std::__cxx11::basic_string::pointer __dat, const _Alloc &__a) : std::__cxx11::basic_string::allocator_type(__a), _M_p(__dat)                 {
                }
                _Alloc_hider(std::__cxx11::basic_string::pointer __dat, _Alloc &&__a = _Alloc()) : std::__cxx11::basic_string::allocator_type(std::move(__a)), _M_p(__dat)                 {
                }
                std::__cxx11::basic_string::pointer _M_p;
            };
            std::__cxx11::basic_string::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(_CharT)
            };
            union {
                _CharT _M_local_buf[_S_local_capacity + 1];
                std::__cxx11::basic_string::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(_M_data()[__n], _CharT());
            }
            bool _M_is_local() const             {
                return _M_data() == _M_local_data();
            }
            std::__cxx11::basic_string::pointer _M_create(std::__cxx11::basic_string::size_type &, std::__cxx11::basic_string::size_type);
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string::size_type __size) throw()             {
                _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type)             {
                typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                _M_construct(__beg, __end, _Tag());
            }
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)             {
                this->_M_construct_aux_2(static_cast<std::__cxx11::basic_string::size_type>(__beg), __end);
            }
            void _M_construct_aux_2(std::__cxx11::basic_string::size_type __req, _CharT __c)             {
                _M_construct(__req, __c);
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end)             {
                typedef typename std::__is_integer<_InIterator>::__type _Integral;
                _M_construct_aux(__beg, __end, _Integral());
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(std::__cxx11::basic_string::size_type __req, _CharT __c);
            std::__cxx11::basic_string::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string::size_type _M_check(std::__cxx11::basic_string::size_type __pos, const char *__s) const             {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            void _M_check_length(std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, const char *__s) const             {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            std::__cxx11::basic_string::size_type _M_limit(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __off) const noexcept             {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const _CharT *__s) const noexcept             {
                return (less<const _CharT *>()(__s, _M_data()) || less<const _CharT *>()(_M_data() + this->size(), __s));
            }
            static void _S_copy(_CharT *__d, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(_CharT *__d, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static void _S_assign(_CharT *__d, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template <class _Iterator> static void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2)             {
                for (; __k1 != __k2; ++__k1 , (void)++__p)
                    traits_type::assign(*__p, *__k1);
            }
            static void _S_copy_chars(_CharT *__p, std::__cxx11::basic_string::iterator __k1, std::__cxx11::basic_string::iterator __k2) noexcept             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT *__p, std::__cxx11::basic_string::const_iterator __k1, std::__cxx11::basic_string::const_iterator __k2) noexcept             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2) noexcept             {
                const std::__cxx11::basic_string::difference_type __d = std::__cxx11::basic_string::difference_type(__n1 - __n2);
                if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                    return __gnu_cxx::__numeric_traits<int>::__max;
                else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                    return __gnu_cxx::__numeric_traits<int>::__min;
                else
                    return int(__d);
            }
            void _M_assign(const basic_string<_CharT, _Traits, _Alloc> &);
            void _M_mutate(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, std::__cxx11::basic_string::size_type __len2);
            void _M_erase(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n);
        public:
            basic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::valuebasic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::value) : _M_dataplus(_M_local_data())             {
                this->_M_set_length(0);
            }
            explicit basic_string<_CharT, _Traits, _Alloc>(const _Alloc &__a) noexcept : _M_dataplus(_M_local_data(), __a)             {
                this->_M_set_length(0);
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str) : _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))             {
                _M_construct(__str._M_data(), __str._M_data() + __str.length());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, npos));
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) : _M_dataplus(_M_local_data())             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, std::__cxx11::basic_string::size_type __n, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__s, __s + __n);
            }
            template <typename = _RequireAllocator<_Alloc>> basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos);
            }
            template <typename = _RequireAllocator<_Alloc>> basic_string<_CharT, _Traits, _Alloc>(std::__cxx11::basic_string::size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__n, __c);
            }
            basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                } else {
                    _M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string<_CharT, _Traits, _Alloc>(initializer_list<_CharT> __l, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__l.begin(), __l.end());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__str.begin(), __str.end());
            }
            basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()) : _M_dataplus(_M_local_data(), __a)             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                    this->_M_length(__str.length());
                    __str._M_set_length(0);
                } else if (_Alloc_traits::_S_always_equal() || __str.get_allocator() == __a) {
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    __str._M_data(__str._M_local_buf);
                    __str._M_set_length(0);
                } else
                    _M_construct(__str.begin(), __str.end());
            }
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc>(_InputIterator __beg, _InputIterator __end, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__beg, __end);
            }
            template <typename _Tp, typename = _If_sv<_Tp, void>> basic_string<_CharT, _Traits, _Alloc>(const _Tp &__t, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Alloc &__a = _Alloc()) : basic_string<_CharT, _Traits, _Alloc>(_S_to_string_view(__t).substr(__pos, __n), __a)             {
            }
            template <typename _Tp, typename = _If_sv<_Tp, void>> explicit basic_string<_CharT, _Traits, _Alloc>(const _Tp &__t, const _Alloc &__a = _Alloc()) : basic_string<_CharT, _Traits, _Alloc>(std::__cxx11::basic_string::__sv_wrapper(_S_to_string_view(__t)), __a)             {
            }
            ~basic_string<_CharT, _Traits, _Alloc>()             {
                this->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->assign(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(const _CharT *__s)             {
                return this->assign(__s);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(_CharT __c)             {
                this->assign(1, __c);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move())             {
                if (!this->_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign() && !_Alloc_traits::_S_always_equal() && _M_get_allocator() != __str._M_get_allocator()) {
                    this->_M_destroy(this->_M_allocated_capacity);
                    _M_data(_M_local_data());
                    this->_M_set_length(0);
                }
                std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
                if (__str._M_is_local()) {
                    if (__str.size())
                        this->_S_copy(_M_data(), __str._M_data(), __str.size());
                    this->_M_set_length(__str.size());
                } else if (_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal() || _M_get_allocator() == __str._M_get_allocator()) {
                    std::__cxx11::basic_string::pointer __data = nullptr;
                    std::__cxx11::basic_string::size_type __capacity;
                    if (!this->_M_is_local()) {
                        if (_Alloc_traits::_S_always_equal()) {
                            __data = _M_data();
                            __capacity = this->_M_allocated_capacity;
                        } else
                            this->_M_destroy(this->_M_allocated_capacity);
                    }
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    if (__data) {
                        __str._M_data(__data);
                        __str._M_capacity(__capacity);
                    } else
                        __str._M_data(__str._M_local_buf);
                } else
                    assign(__str);
                __str.clear();
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(initializer_list<_CharT> __l)             {
                this->assign(__l.begin(), __l.size());
                return *this;
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> operator=(const _Tp &__svt)             {
                return this->assign(__svt);
            }
            operator __sv_type() const noexcept             {
                return std::__cxx11::basic_string::__sv_type(data(), this->size());
            }
            std::__cxx11::basic_string::iterator begin() noexcept             {
                return std::__cxx11::basic_string::iterator(_M_data());
            }
            std::__cxx11::basic_string::const_iterator begin() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(_M_data());
            }
            std::__cxx11::basic_string::iterator end() noexcept             {
                return std::__cxx11::basic_string::iterator(_M_data() + this->size());
            }
            std::__cxx11::basic_string::const_iterator end() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(_M_data() + this->size());
            }
            std::__cxx11::basic_string::reverse_iterator rbegin() noexcept             {
                return std::__cxx11::basic_string::reverse_iterator(this->end());
            }
            std::__cxx11::basic_string::const_reverse_iterator rbegin() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->end());
            }
            std::__cxx11::basic_string::reverse_iterator rend() noexcept             {
                return std::__cxx11::basic_string::reverse_iterator(this->begin());
            }
            std::__cxx11::basic_string::const_reverse_iterator rend() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->begin());
            }
            std::__cxx11::basic_string::const_iterator cbegin() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(this->_M_data());
            }
            std::__cxx11::basic_string::const_iterator cend() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(this->_M_data() + this->size());
            }
            std::__cxx11::basic_string::const_reverse_iterator crbegin() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->end());
            }
            std::__cxx11::basic_string::const_reverse_iterator crend() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->begin());
            }
        public:
            std::__cxx11::basic_string::size_type size() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string::size_type __n, _CharT __c);
            void resize(std::__cxx11::basic_string::size_type __n)             {
                this->resize(__n, _CharT());
            }
            void shrink_to_fit() noexcept             {
                if (this->capacity() > this->size()) {
                    try {
                        this->reserve(0);
                    } catch (...) {
                    }
                }
            }
            std::__cxx11::basic_string::size_type capacity() const noexcept             {
                return this->_M_is_local() ? std::__cxx11::basic_string::size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            void reserve(std::__cxx11::basic_string::size_type __res_arg = 0);
            void clear() noexcept             {
                this->_M_set_length(0);
            }
            bool empty() const noexcept [[nodiscard("")]]             {
                return this->size() == 0;
            }
            std::__cxx11::basic_string::const_reference operator[](std::__cxx11::basic_string::size_type __pos) const noexcept             {
                ;
                return _M_data()[__pos];
            }
            std::__cxx11::basic_string::reference operator[](std::__cxx11::basic_string::size_type __pos)             {
                ;
                ;
                return _M_data()[__pos];
            }
            std::__cxx11::basic_string::const_reference at(std::__cxx11::basic_string::size_type __n) const             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            std::__cxx11::basic_string::reference at(std::__cxx11::basic_string::size_type __n)             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            std::__cxx11::basic_string::reference front() noexcept             {
                ;
                return operator[](0);
            }
            std::__cxx11::basic_string::const_reference front() const noexcept             {
                ;
                return operator[](0);
            }
            std::__cxx11::basic_string::reference back() noexcept             {
                ;
                return operator[](this->size() - 1);
            }
            std::__cxx11::basic_string::const_reference back() const noexcept             {
                ;
                return operator[](this->size() - 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->append(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(const _CharT *__s)             {
                return this->append(__s);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(_CharT __c)             {
                this->push_back(__c);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(initializer_list<_CharT> __l)             {
                return this->append(__l.begin(), __l.size());
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> operator+=(const _Tp &__svt)             {
                return this->append(__svt);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->_M_append(__str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->_M_append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                this->_M_check_length(std::__cxx11::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)             {
                ;
                const std::__cxx11::basic_string::size_type __n = traits_type::length(__s);
                this->_M_check_length(std::__cxx11::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->size(), std::__cxx11::basic_string::size_type(0), __n, __c);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(initializer_list<_CharT> __l)             {
                return this->append(__l.begin(), __l.size());
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)             {
                return this->replace(end(), end(), __first, __last);
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> append(const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->append(__sv.data(), __sv.size());
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> append(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->_M_append(__sv.data() + std::__sv_check(__sv.size(), __pos, "basic_string::append"), std::__sv_limit(__sv.size(), __pos, __n));
            }
            void push_back(_CharT __c)             {
                const std::__cxx11::basic_string::size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, std::__cxx11::basic_string::size_type(0), 0, std::__cxx11::basic_string::size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                if (_Alloc_traits::_S_propagate_on_copy_assign()) {
                    if (!_Alloc_traits::_S_always_equal() && !this->_M_is_local() && _M_get_allocator() != __str._M_get_allocator()) {
                        if (__str.size() <= _S_local_capacity) {
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(_M_local_data());
                            this->_M_set_length(0);
                        } else {
                            const auto __len = __str.size();
                            auto __alloc = __str._M_get_allocator();
                            auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(__ptr);
                            this->_M_capacity(__len);
                            this->_M_set_length(__len);
                        }
                    }
                    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
                }
                this->_M_assign(__str);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move())             {
                return *this = std::move(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)             {
                ;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(std::__cxx11::basic_string::size_type(0), this->size(), __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)             {
                return this->replace(begin(), end(), __first, __last);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(initializer_list<_CharT> __l)             {
                return this->assign(__l.begin(), __l.size());
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> assign(const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->assign(__sv.data(), __sv.size());
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> assign(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __sv.data() + std::__sv_check(__sv.size(), __pos, "basic_string::assign"), std::__sv_limit(__sv.size(), __pos, __n));
            }
            std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __n, __c);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, _InputIterator __beg, _InputIterator __end)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __beg, __end);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, initializer_list<_CharT> __l)             {
                return this->insert(__p, __l.begin(), __l.end());
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                return this->replace(__pos, std::__cxx11::basic_string::size_type(0), __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, const _CharT *__s)             {
                ;
                return this->replace(__pos, std::__cxx11::basic_string::size_type(0), __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::insert"), std::__cxx11::basic_string::size_type(0), __n, __c);
            }
            std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::__const_iterator __p, _CharT __c)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->_M_replace_aux(__pos, std::__cxx11::basic_string::size_type(0), std::__cxx11::basic_string::size_type(1), __c);
                return std::__cxx11::basic_string::iterator(_M_data() + __pos);
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> insert(std::__cxx11::basic_string::size_type __pos, const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->insert(__pos, __sv.data(), __sv.size());
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> insert(std::__cxx11::basic_string::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __sv.data() + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"), std::__sv_limit(__sv.size(), __pos2, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &erase(std::__cxx11::basic_string::size_type __pos = 0, std::__cxx11::basic_string::size_type __n = npos)             {
                this->_M_check(__pos, "basic_string::erase");
                if (__n == npos)
                    this->_M_set_length(__pos);
                else if (__n != 0)
                    this->_M_erase(__pos, this->_M_limit(__pos, __n));
                return *this;
            }
            std::__cxx11::basic_string::iterator erase(std::__cxx11::basic_string::__const_iterator __position)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __position - begin();
                this->_M_erase(__pos, std::__cxx11::basic_string::size_type(1));
                return std::__cxx11::basic_string::iterator(_M_data() + __pos);
            }
            std::__cxx11::basic_string::iterator erase(std::__cxx11::basic_string::__const_iterator __first, std::__cxx11::basic_string::__const_iterator __last)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __first - begin();
                if (__last == end())
                    this->_M_set_length(__pos);
                else
                    this->_M_erase(__pos, __last - __first);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            void pop_back() noexcept             {
                ;
                this->_M_erase(this->size() - 1, 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos, __n, __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos)             {
                return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2)             {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s)             {
                ;
                return this->replace(__pos, __n1, __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __n2, __c);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__i1, __i2, __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__s)             {
                ;
                return this->replace(__i1, __i2, __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                ;
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2)             {
                ;
                ;
                return this->_M_replace_dispatch(__i1, __i2, __k1, __k2, std::__false_type());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, _CharT *__k1, _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__k1, const _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::iterator __k1, std::__cxx11::basic_string::iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::const_iterator __k1, std::__cxx11::basic_string::const_iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, initializer_list<_CharT> __l)             {
                return this->replace(__i1, __i2, __l.begin(), __l.size());
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__pos, __n, __sv.data(), __sv.size());
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__pos1, __n1, __sv.data() + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"), std::__sv_limit(__sv.size(), __pos2, __n2));
            }
            template <typename _Tp> _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__i1 - begin(), __i2 - __i1, __sv);
            }
        private:
            template <class _Integer> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type)             {
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
            }
            template <class _InputIterator> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, const std::__cxx11::basic_string::size_type __len2);
            basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, std::__cxx11::basic_string::size_type __n);
        public:
            std::__cxx11::basic_string::size_type copy(_CharT *__s, std::__cxx11::basic_string::size_type __n, std::__cxx11::basic_string::size_type __pos = 0) const;
            void swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept;
            const _CharT *c_str() const noexcept             {
                return _M_data();
            }
            const _CharT *data() const noexcept             {
                return _M_data();
            }
            _CharT *data() noexcept             {
                return _M_data();
            }
            std::__cxx11::basic_string::allocator_type get_allocator() const noexcept             {
                return _M_get_allocator();
            }
            std::__cxx11::basic_string::size_type find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string::size_type> find(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::valuefind(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find(__sv.data(), __pos, __sv.size());
            }
            std::__cxx11::basic_string::size_type find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept;
            std::__cxx11::basic_string::size_type rfind(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->rfind(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::valuerfind(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->rfind(__sv.data(), __pos, __sv.size());
            }
            std::__cxx11::basic_string::size_type rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const             {
                ;
                return this->rfind(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type rfind(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept;
            std::__cxx11::basic_string::size_type find_first_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find_first_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::valuefind_first_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_first_of(__sv.data(), __pos, __sv.size());
            }
            std::__cxx11::basic_string::size_type find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find_first_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_first_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find(__c, __pos);
            }
            std::__cxx11::basic_string::size_type find_last_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->find_last_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::valuefind_last_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_last_of(__sv.data(), __pos, __sv.size());
            }
            std::__cxx11::basic_string::size_type find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                ;
                return this->find_last_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_last_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->rfind(__c, __pos);
            }
            std::__cxx11::basic_string::size_type find_first_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find_first_not_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::valuefind_first_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_first_not_of(__sv.data(), __pos, __sv.size());
            }
            std::__cxx11::basic_string::size_type find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find_first_not_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_first_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept;
            std::__cxx11::basic_string::size_type find_last_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->find_last_not_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::valuefind_last_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_last_not_of(__sv.data(), __pos, __sv.size());
            }
            std::__cxx11::basic_string::size_type find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                ;
                return this->find_last_not_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_last_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept;
            basic_string<_CharT, _Traits, _Alloc> substr(std::__cxx11::basic_string::size_type __pos = 0, std::__cxx11::basic_string::size_type __n = npos) const             {
                return basic_string<_CharT, _Traits, _Alloc>(*this, this->_M_check(__pos, "basic_string::substr"), __n);
            }
            int compare(const basic_string<_CharT, _Traits, _Alloc> &__str) const             {
                const std::__cxx11::basic_string::size_type __size = this->size();
                const std::__cxx11::basic_string::size_type __osize = __str.size();
                const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            template <typename _Tp> _If_sv<_Tp, int> compare(const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::valuecompare(const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                const std::__cxx11::basic_string::size_type __size = this->size();
                const std::__cxx11::basic_string::size_type __osize = __sv.size();
                const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __sv.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::valuecompare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return std::__cxx11::basic_string::__sv_type(*this).substr(__pos, __n).compare(__sv);
            }
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const noexcept(is_same<_Tp, __sv_type>::valuecompare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return std::__cxx11::basic_string::__sv_type(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
            }
            int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const;
            int compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const;
            int compare(const _CharT *__s) const noexcept;
            int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s) const;
            int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2) const;
            friend template <typename, typename, typename> class basic_stringbuf;
        };
template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char16_t, std::char_traits<char16_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>, __not_<is_convertible<const _Tp &, const char16_t *>>>::value, _Res>;
            static std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _M_sv;
            };
            explicit basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_wrapper __svw, const std::allocator<char16_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_create(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type &__capacity, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char16_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __req, char16_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end)             {
                typedef typename std::__is_integer<const char16_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __req, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_check(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_limit(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static void _S_copy(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            static void _S_assign(char16_t *__d, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _Iterator> static void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &);
            void _M_mutate(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            basic_string(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            template <typename = _RequireAllocator<std::allocator<char16_t>>> basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            template<> basic_string<std::allocator<char16_t>>(const char16_t *__s, const std::allocator<char16_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char16_t>>> basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str) noexcept;
            basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> basic_string(const _Tp &__t, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> explicit basic_string(const _Tp &__t, const std::allocator<char16_t> &__a);
            ~basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator=(const _Tp &__svt);
            operator __sv_type() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator begin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator end() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type size() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept [[nodiscard("")]];
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference front() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference front() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference back() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator+=(const _Tp &__svt);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            void push_back(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __p, char16_t __c);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __position);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __first, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, initializer_list<char16_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_aux(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type copy(char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__s) noexcept;
            const char16_t *c_str() const noexcept;
            const char16_t *data() const noexcept             {
                return this->_M_data();
            }
            char16_t *data() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> substr(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            int compare(const char16_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char32_t, std::char_traits<char32_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>, __not_<is_convertible<const _Tp &, const char32_t *>>>::value, _Res>;
            static std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _M_sv;
            };
            explicit basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_wrapper __svw, const std::allocator<char32_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_create(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type &__capacity, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char32_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __req, char32_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end)             {
                typedef typename std::__is_integer<const char32_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __req, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_check(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_limit(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static void _S_copy(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            static void _S_assign(char32_t *__d, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _Iterator> static void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &);
            void _M_mutate(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            basic_string(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            template <typename = _RequireAllocator<std::allocator<char32_t>>> basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            template<> basic_string<std::allocator<char32_t>>(const char32_t *__s, const std::allocator<char32_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char32_t>>> basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str) noexcept;
            basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> basic_string(const _Tp &__t, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> explicit basic_string(const _Tp &__t, const std::allocator<char32_t> &__a);
            ~basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator=(const _Tp &__svt);
            operator __sv_type() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator begin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator end() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type size() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept [[nodiscard("")]];
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference front() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference front() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference back() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator+=(const _Tp &__svt);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            void push_back(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __p, char32_t __c);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __position);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __first, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, initializer_list<char32_t> __l);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_aux(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type copy(char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__s) noexcept;
            const char32_t *c_str() const noexcept;
            const char32_t *data() const noexcept             {
                return this->_M_data();
            }
            char32_t *data() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> substr(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            int compare(const char32_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
    inline namespace __cxx11 {
        template <typename _InputIterator, typename _CharT = typename iterator_traits<_InputIterator>::value_type, typename _Allocator = allocator<_CharT>, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator()) -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;
        template <typename _CharT, typename _Traits, typename _Allocator = allocator<_CharT>, typename = _RequireAllocator<_Allocator>> basic_string(basic_string_view<_CharT, _Traits>, const _Allocator & = _Allocator()) -> basic_string<_CharT, _Traits, _Allocator>;
        template <typename _CharT, typename _Traits, typename _Allocator = allocator<_CharT>, typename = _RequireAllocator<_Allocator>> basic_string(basic_string_view<_CharT, _Traits>, typename basic_string<_CharT, _Traits, _Allocator>::size_type, typename basic_string<_CharT, _Traits, _Allocator>::size_type, const _Allocator & = _Allocator()) -> basic_string<_CharT, _Traits, _Allocator>;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, const char *__rhs)     {
        basic_string<char, std::char_traits<char>, std::allocator<char>> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str(__lhs);
        __str.append(__size_type(1), __rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        using _Alloc_traits = allocator_traits<_Alloc>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal({}))
            __use_rhs = true;
        else if (__lhs.get_allocator() == __rhs.get_allocator())
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs)     {
        using _Alloc_traits = allocator_traits<std::allocator<char>>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal{})
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, 1, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs)     {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, const char *__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs)     {
        return std::move(__lhs.append(1, __rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT> inline typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator==(const basic_string<_CharT> &__lhs, const basic_string<_CharT> &__rhs) noexcept     {
        return (__lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size()));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) == 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline void swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs)))     {
        __lhs.swap(__rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str);
    template<> basic_istream<char> &operator>><char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__is, basic_string<char> &__str);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return std::getline(__is, __str, __is.widen('\n'));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)     {
        return std::getline(__is, __str, __delim);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return std::getline(__is, __str);
    }
    template<> basic_istream<char> &getline<char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__in, basic_string<char> &__str, char __delim);
    template<> basic_istream<wchar_t> &getline<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim);
}
extern "C" {
    typedef enum  {
        P_ALL,
        P_PID,
        P_PGID
    } idtype_t;
    typedef struct {
        int quot;
        int rem;
    } div_t;
    typedef struct {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct {
        long long quot;
        long long rem;
    } lldiv_t;
    extern size_t __ctype_get_mb_cur_max() throw();
    extern double atof(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern int atoi(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern long atol(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern long long atoll(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float32 strtof32(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float64 strtof64(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float32x strtof32x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float64x strtof64x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern int strfromd(char *__dest, size_t __size, const char *__format, double __f) throw() __attribute__((nonnull(3)));
    extern int strfromf(char *__dest, size_t __size, const char *__format, float __f) throw() __attribute__((nonnull(3)));
    extern int strfroml(char *__dest, size_t __size, const char *__format, long double __f) throw() __attribute__((nonnull(3)));
    extern int strfromf32(char *__dest, size_t __size, const char *__format, _Float32 __f) throw() __attribute__((nonnull(3)));
    extern int strfromf64(char *__dest, size_t __size, const char *__format, _Float64 __f) throw() __attribute__((nonnull(3)));
    extern int strfromf32x(char *__dest, size_t __size, const char *__format, _Float32x __f) throw() __attribute__((nonnull(3)));
    extern int strfromf64x(char *__dest, size_t __size, const char *__format, _Float64x __f) throw() __attribute__((nonnull(3)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float32 strtof32_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float64 strtof64_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float32x strtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float64x strtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern char *l64a(long __n) throw();
    extern long a64l(const char *__s) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern "C" {
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __id_t id_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long ulong;
        typedef unsigned short ushort;
        typedef unsigned int uint;
        typedef unsigned int u_int8_t __attribute__((mode(__QI__)));
        typedef unsigned int u_int16_t __attribute__((mode(__HI__)));
        typedef unsigned int u_int32_t __attribute__((mode(__SI__)));
        typedef unsigned int u_int64_t __attribute__((mode(__DI__)));
        typedef int register_t __attribute__((mode(__word__)));
        typedef struct {
            unsigned long __val[16];
        } __sigset_t;
        typedef __sigset_t sigset_t;
        typedef long __fd_mask;
        typedef struct {
            __fd_mask fds_bits[16];
        } fd_set;
        typedef __fd_mask fd_mask;
        extern "C" {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
    }
    extern long random() throw();
    extern void srandom(unsigned int __seed) throw();
    extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen) throw() __attribute__((nonnull(2)));
    extern char *setstate(char *__statebuf) throw() __attribute__((nonnull(1)));
    struct random_data {
        int32_t *fptr;
        int32_t *rptr;
        int32_t *state;
        int rand_type;
        int rand_deg;
        int rand_sep;
        int32_t *end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int srandom_r(unsigned int __seed, struct random_data *__buf) throw() __attribute__((nonnull(2)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) throw() __attribute__((nonnull(2, 4)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) throw() __attribute__((nonnull(1, 2)));
    extern int rand() throw();
    extern void srand(unsigned int __seed) throw();
    extern int rand_r(unsigned int *__seed) throw();
    extern double drand48() throw();
    extern double erand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern long lrand48() throw();
    extern long nrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern long mrand48() throw();
    extern long jrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern void srand48(long __seedval) throw();
    extern unsigned short *seed48(unsigned short __seed16v[3]) throw() __attribute__((nonnull(1)));
    extern void lcong48(unsigned short __param[7]) throw() __attribute__((nonnull(1)));
    struct drand48_data {
        unsigned short __x[3];
        unsigned short __old_x[3];
        unsigned short __c;
        unsigned short __init;
        unsigned long long __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int srand48_r(long __seedval, struct drand48_data *__buffer) throw() __attribute__((nonnull(2)));
    extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) throw() __attribute__((nonnull(1, 2)));
    extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer) throw() __attribute__((nonnull(1, 2)));
    extern void *malloc(size_t __size) throw() __attribute__((malloc));
    extern void *calloc(size_t __nmemb, size_t __size) throw() __attribute__((malloc));
    extern void *realloc(void *__ptr, size_t __size) throw() __attribute__((warn_unused_result("")));
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) throw() __attribute__((warn_unused_result("")));
    extern void free(void *__ptr) throw();
    extern "C" {
        extern void *alloca(size_t __size) throw();
    }
    extern void *valloc(size_t __size) throw() __attribute__((malloc));
    extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size) throw() __attribute__((nonnull(1)));
    extern void *aligned_alloc(size_t __alignment, size_t __size) throw() __attribute__((malloc));
    extern void abort() throw();
    extern int atexit(void (*__func)()) throw() __attribute__((nonnull(1)));
    extern "C++" int at_quick_exit(void (*__func)()) throw() asm("at_quick_exit") __attribute__((nonnull(1)))
    extern int on_exit(void (*__func)(int, void *), void *__arg) throw() __attribute__((nonnull(1)));
    extern void exit(int __status) throw();
    extern void quick_exit(int __status) throw();
    extern void _Exit(int __status) throw();
    extern char *getenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern char *secure_getenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern int putenv(char *__string) throw() __attribute__((nonnull(1)));
    extern int setenv(const char *__name, const char *__value, int __replace) throw() __attribute__((nonnull(2)));
    extern int unsetenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern int clearenv() throw();
    extern char *mktemp(char *__template) throw() __attribute__((nonnull(1)));
    extern int mkstemp(char *__template) __attribute__((nonnull(1)));
    extern int mkstemp64(char *__template) __attribute__((nonnull(1)));
    extern int mkstemps(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern int mkstemps64(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern char *mkdtemp(char *__template) throw() __attribute__((nonnull(1)));
    extern int mkostemp(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemp64(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int system(const char *__command);
    extern char *canonicalize_file_name(const char *__name) throw() __attribute__((nonnull(1)));
    extern char *realpath(const char *__restrict __name, char *__restrict __resolved) throw();
    typedef int (*__compar_fn_t)(const void *, const void *);
    typedef __compar_fn_t comparison_fn_t;
    typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
    extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 2, 5)));
    extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 4)));
    extern void qsort_r(void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg) __attribute__((nonnull(1, 4)));
    extern int abs(int __x) throw() __attribute__((const));
    extern long labs(long __x) throw() __attribute__((const));
    extern long long llabs(long long __x) throw() __attribute__((const));
    extern div_t div(int __numer, int __denom) throw() __attribute__((const));
    extern ldiv_t ldiv(long __numer, long __denom) throw() __attribute__((const));
    extern lldiv_t lldiv(long long __numer, long long __denom) throw() __attribute__((const));
    extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *gcvt(double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(3)));
    extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(3)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int mblen(const char *__s, size_t __n) throw();
    extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) throw();
    extern int wctomb(char *__s, wchar_t __wchar) throw();
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) throw();
    extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) throw();
    extern int rpmatch(const char *__response) throw() __attribute__((nonnull(1)));
    extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw() __attribute__((nonnull(1, 2, 3)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) throw();
    extern int unlockpt(int __fd) throw();
    extern char *ptsname(int __fd) throw();
    extern int ptsname_r(int __fd, char *__buf, size_t __buflen) throw() __attribute__((nonnull(2)));
    extern int getpt();
    extern int getloadavg(double __loadavg[], int __nelem) throw() __attribute__((nonnull(1)));
}
extern "C++" {
    namespace std {
        using ::abs;
        inline long abs(long __i)         {
            return __builtin_labs(__i);
        }
        inline long long abs(long long __x)         {
            return __builtin_llabs(__x);
        }
        inline constexpr double abs(double __x)         {
            return __builtin_fabs(__x);
        }
        inline constexpr float abs(float __x)         {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double abs(long double __x)         {
            return __builtin_fabsl(__x);
        }
    }
}
extern "C++" {
    namespace std {
        using ::div_t;
        using ::ldiv_t;
        using ::abort;
        using ::aligned_alloc;
        using ::atexit;
        using ::at_quick_exit;
        using ::atof;
        using ::atoi;
        using ::atol;
        using ::bsearch;
        using ::calloc;
        using ::div;
        using ::exit;
        using ::free;
        using ::getenv;
        using ::labs;
        using ::ldiv;
        using ::malloc;
        using ::mblen;
        using ::mbstowcs;
        using ::mbtowc;
        using ::qsort;
        using ::quick_exit;
        using ::rand;
        using ::realloc;
        using ::srand;
        using ::strtod;
        using ::strtol;
        using ::strtoul;
        using ::system;
        using ::wcstombs;
        using ::wctomb;
        inline ldiv_t div(long __i, long __j)         {
            return ldiv(__i, __j);
        }
    }
    namespace __gnu_cxx {
        using ::lldiv_t;
        using ::_Exit;
        using ::llabs;
        inline lldiv_t div(long long __n, long long __d)         {
            lldiv_t __q;
            __q.quot = __n / __d;
            __q.rem = __n % __d;
            return __q;
        }
        using ::lldiv;
        using ::atoll;
        using ::strtoll;
        using ::strtoull;
        using ::strtof;
        using ::strtold;
    }
    namespace std {
        using ::__gnu_cxx::lldiv_t;
        using ::__gnu_cxx::_Exit;
        using ::__gnu_cxx::llabs;
        using ::__gnu_cxx::div;
        using ::__gnu_cxx::lldiv;
        using ::__gnu_cxx::atoll;
        using ::__gnu_cxx::strtof;
        using ::__gnu_cxx::strtoll;
        using ::__gnu_cxx::strtoull;
        using ::__gnu_cxx::strtold;
    }
}
extern "C" {
    extern int *__errno_location() throw() __attribute__((const));
    extern char *program_invocation_name;
    extern char *program_invocation_short_name;
    typedef int error_t;
}
namespace __gnu_cxx {
    template <typename _TRet, typename _Ret = _TRet, typename _CharT, typename ..._Base> _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base...), const char *__name, const _CharT *__str, std::size_t *__idx, _Base ...__base)     {
        _Ret __ret;
        _CharT *__endptr;
        const struct _Save_errno {
            _Save_errno() : _M_errno((*__errno_location()))             {
                (*__errno_location()) = 0;
            }
            ~_Save_errno()             {
                if ((*__errno_location()) == 0)
                    (*__errno_location()) = this->_M_errno;
            }
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
            static bool _S_chk(_TRet, std::false_type)             {
                return false;
            }
            static bool _S_chk(_TRet __val, std::true_type)             {
                return __val < _TRet(__numeric_traits<int>::__min) || __val > _TRet(__numeric_traits<int>::__max);
            }
        };
        const _TRet __tmp = __convf(__str, &__endptr, __base...);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>({})))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        int __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, char, <int>>(unsigned long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        unsigned long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, char, <int>>(long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, char, <int>>(unsigned long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        unsigned long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, char, <>>(float (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        float __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, char, <>>(double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, char, <>>(long double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        long double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        int __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, wchar_t, <int>>(unsigned long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        unsigned long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, wchar_t, <int>>(long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, wchar_t, <int>>(unsigned long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        unsigned long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, wchar_t, <>>(float (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        float __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, wchar_t, <>>(double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, wchar_t, <>>(long double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        long double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template <typename _String, typename _CharT = typename _String::value_type> _String __to_xstring(int (*__convf)(_CharT *, std::size_t, const _CharT *, __va_list_tag *), std::size_t __n, const _CharT *__fmt, ...)     {
        _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return _String(__s, __s + __len);
    }
    template<> std::__cxx11::basic_string<char> __to_xstring<std::__cxx11::basic_string<char>, char>(int (*__convf)(char *, std::size_t, const char *, __va_list_tag *), std::size_t __n, const char *__fmt, ...)     {
        char *__s = static_cast<char *>(__builtin_alloca(sizeof(char) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::__cxx11::basic_string<char>(__s, __s + __len);
    }
    template<> std::__cxx11::basic_string<wchar_t> __to_xstring<std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*__convf)(wchar_t *, std::size_t, const wchar_t *, __va_list_tag *), std::size_t __n, const wchar_t *__fmt, ...)     {
        wchar_t *__s = static_cast<wchar_t *>(__builtin_alloca(sizeof(wchar_t) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::__cxx11::basic_string<wchar_t>(__s, __s + __len);
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp> constexpr unsigned int __to_chars_len(_Tp __value, int __base = 10) noexcept         {
            static_assert(is_integral<_Tp>::value, "implementation bug");
            static_assert(is_unsigned<_Tp>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned int>(unsigned int __value, int __base = 10) noexcept         {
            static_assert(is_integral<unsigned int>::value, "implementation bug");
            static_assert(is_unsigned<unsigned int>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long>(unsigned long __value, int __base = 10) noexcept         {
            static_assert(is_integral<unsigned long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long long>(unsigned long long __value, int __base = 10) noexcept         {
            static_assert(is_integral<unsigned long long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long long>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template <typename _Tp> void __to_chars_10_impl(char *__first, unsigned int __len, _Tp __val) noexcept         {
            static_assert(is_integral<_Tp>::value, "implementation bug");
            static_assert(is_unsigned<_Tp>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned int>(char *__first, unsigned int __len, unsigned int __val) noexcept         {
            static_assert(is_integral<unsigned int>::value, "implementation bug");
            static_assert(is_unsigned<unsigned int>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long>(char *__first, unsigned int __len, unsigned long __val) noexcept         {
            static_assert(is_integral<unsigned long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long long>(char *__first, unsigned int __len, unsigned long long __val) noexcept         {
            static_assert(is_integral<unsigned long long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long long>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
    }
}
namespace std {
    inline namespace __cxx11 {
        inline int stoi(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx);
        }
        inline std::string to_string(int __val)         {
            const bool __neg = __val < 0;
            const unsigned int __uval = __neg ? (unsigned int)~__val + 1U : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned int __val)         {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(long __val)         {
            const bool __neg = __val < 0;
            const unsigned long __uval = __neg ? (unsigned long)~__val + 1UL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned long __val)         {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(long long __val)         {
            const bool __neg = __val < 0;
            const unsigned long long __uval = __neg ? (unsigned long long)~__val + 1ULL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned long long __val)         {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(float __val)         {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(long double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%Lf", __val);
        }
        inline int stoi(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx);
        }
        inline std::wstring to_wstring(int __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(int), L"%d", __val);
        }
        inline std::wstring to_wstring(unsigned int __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned int), L"%u", __val);
        }
        inline std::wstring to_wstring(long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long), L"%ld", __val);
        }
        inline std::wstring to_wstring(unsigned long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long), L"%lu", __val);
        }
        inline std::wstring to_wstring(long long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long long), L"%lld", __val);
        }
        inline std::wstring to_wstring(unsigned long long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long long), L"%llu", __val);
        }
        inline std::wstring to_wstring(float __val)         {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(long double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%Lf", __val);
        }
    }
}
namespace std {
    template<> struct hash<std::string> : public __hash_base<std::size_t, std::string> {
        std::size_t operator()(const std::string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::string>> : std::false_type {
    };
    template<> struct hash<std::wstring> : public __hash_base<std::size_t, std::wstring> {
        std::size_t operator()(const std::wstring &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::wstring>> : std::false_type {
    };
    template<> struct hash<std::u16string> : public __hash_base<std::size_t, std::u16string> {
        std::size_t operator()(const std::u16string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u16string>> : std::false_type {
    };
    template<> struct hash<std::u32string> : public __hash_base<std::size_t, std::u32string> {
        std::size_t operator()(const std::u32string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u32string>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_literals {
            inline basic_string<char> operator""s(const char *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char>{__str, __len};
            }
            inline basic_string<wchar_t> operator""s(const wchar_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<wchar_t>{__str, __len};
            }
            inline basic_string<char16_t> operator""s(const char16_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char16_t>{__str, __len};
            }
            inline basic_string<char32_t> operator""s(const char32_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char32_t>{__str, __len};
            }
        }
    }
    namespace __detail {
        namespace __variant {
            template <typename> struct _Never_valueless_alt;
            template <typename _Tp, typename _Traits, typename _Alloc> struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>> : __and_<is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>, is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>>::type {
            };
        }
    }
}
namespace std {
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type npos;
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept     {
        if (this == &__s)
            return;
        _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());
        if (this->_M_is_local())
            if (__s._M_is_local()) {
                if (this->length() && __s.length()) {
                    _CharT __tmp_data[_S_local_capacity + 1];
                    traits_type::copy(__tmp_data, __s._M_local_buf, _S_local_capacity + 1);
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                    traits_type::copy(this->_M_local_buf, __tmp_data, _S_local_capacity + 1);
                } else if (__s.length()) {
                    traits_type::copy(this->_M_local_buf, __s._M_local_buf, _S_local_capacity + 1);
                    this->_M_length(__s.length());
                    __s._M_set_length(0);
                    return;
                } else if (this->length()) {
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                    __s._M_length(this->length());
                    this->_M_set_length(0);
                    return;
                }
            } else {
                const std::__cxx11::basic_string::size_type __tmp_capacity = __s._M_allocated_capacity;
                traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                _M_data(__s._M_data());
                __s._M_data(__s._M_local_buf);
                this->_M_capacity(__tmp_capacity);
            }
        else {
            const std::__cxx11::basic_string::size_type __tmp_capacity = this->_M_allocated_capacity;
            if (__s._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __s._M_local_buf, _S_local_capacity + 1);
                __s._M_data(_M_data());
                _M_data(this->_M_local_buf);
            } else {
                std::__cxx11::basic_string::pointer __tmp_ptr = _M_data();
                _M_data(__s._M_data());
                __s._M_data(__tmp_ptr);
                this->_M_capacity(__s._M_allocated_capacity);
            }
            __s._M_capacity(__tmp_capacity);
        }
        const std::__cxx11::basic_string::size_type __tmp_length = this->length();
        this->_M_length(__s.length());
        __s._M_length(__tmp_length);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::pointer basic_string<_CharT, _Traits, _Alloc>::_M_create(std::__cxx11::basic_string::size_type &__capacity, std::__cxx11::basic_string::size_type __old_capacity)     {
        if (__capacity > this->max_size())
            std::__throw_length_error(("basic_string::_M_create"));
        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
            __capacity = 2 * __old_capacity;
            if (__capacity > this->max_size())
                __capacity = this->max_size();
        }
        return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag)     {
        std::__cxx11::basic_string::size_type __len = 0;
        std::__cxx11::basic_string::size_type __capacity = std::__cxx11::basic_string::size_type(_S_local_capacity);
        while (__beg != __end && __len < __capacity)
            {
                _M_data()[__len++] = *__beg;
                ++__beg;
            }
        try {
            while (__beg != __end)
                {
                    if (__len == __capacity) {
                        __capacity = __len + 1;
                        std::__cxx11::basic_string::pointer __another = this->_M_create(__capacity, __len);
                        this->_S_copy(__another, _M_data(), __len);
                        this->_M_dispose();
                        _M_data(__another);
                        this->_M_capacity(__capacity);
                    }
                    _M_data()[__len++] = *__beg;
                    ++__beg;
                }
        } catch (...) {
            this->_M_dispose();
            throw;
        }
        this->_M_set_length(__len);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::forward_iterator_tag)     {
        if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
            std::__throw_logic_error(("basic_string::_M_construct null not valid"));
        std::__cxx11::basic_string::size_type __dnew = static_cast<std::__cxx11::basic_string::size_type>(std::distance(__beg, __end));
        if (__dnew > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__dnew, std::__cxx11::basic_string::size_type(0)));
            this->_M_capacity(__dnew);
        }
        try {
            this->_S_copy_chars(_M_data(), __beg, __end);
        } catch (...) {
            this->_M_dispose();
            throw;
        }
        this->_M_set_length(__dnew);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(std::__cxx11::basic_string::size_type __n, _CharT __c)     {
        if (__n > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__n, std::__cxx11::basic_string::size_type(0)));
            this->_M_capacity(__n);
        }
        if (__n)
            this->_S_assign(_M_data(), __n, __c);
        this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_assign(const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        if (this != &__str) {
            const std::__cxx11::basic_string::size_type __rsize = __str.length();
            const std::__cxx11::basic_string::size_type __capacity = this->capacity();
            if (__rsize > __capacity) {
                std::__cxx11::basic_string::size_type __new_capacity = __rsize;
                std::__cxx11::basic_string::pointer __tmp = this->_M_create(__new_capacity, __capacity);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__new_capacity);
            }
            if (__rsize)
                this->_S_copy(_M_data(), __str._M_data(), __rsize);
            this->_M_set_length(__rsize);
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::reserve(std::__cxx11::basic_string::size_type __res = 0)     {
        if (__res < this->length())
            __res = this->length();
        const std::__cxx11::basic_string::size_type __capacity = this->capacity();
        if (__res != __capacity) {
            if (__res > __capacity || __res > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
                std::__cxx11::basic_string::pointer __tmp = this->_M_create(__res, __capacity);
                this->_S_copy(__tmp, _M_data(), this->length() + 1);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__res);
            } else if (!this->_M_is_local()) {
                this->_S_copy(_M_local_data(), _M_data(), this->length() + 1);
                this->_M_destroy(__capacity);
                _M_data(_M_local_data());
            }
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, std::__cxx11::basic_string::size_type __len2)     {
        const std::__cxx11::basic_string::size_type __how_much = this->length() - __pos - __len1;
        std::__cxx11::basic_string::size_type __new_capacity = this->length() + __len2 - __len1;
        std::__cxx11::basic_string::pointer __r = this->_M_create(__new_capacity, this->capacity());
        if (__pos)
            this->_S_copy(__r, _M_data(), __pos);
        if (__s && __len2)
            this->_S_copy(__r + __pos, __s, __len2);
        if (__how_much)
            this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1, __how_much);
        this->_M_dispose();
        _M_data(__r);
        this->_M_capacity(__new_capacity);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_erase(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n)     {
        const std::__cxx11::basic_string::size_type __how_much = this->length() - __pos - __n;
        if (__how_much && __n)
            this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
        this->_M_set_length(this->length() - __n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::resize(std::__cxx11::basic_string::size_type __n, _CharT __c)     {
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__size < __n)
            this->append(__n - __size, __c);
        else if (__n < __size)
            this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s, std::__cxx11::basic_string::size_type __n)     {
        const std::__cxx11::basic_string::size_type __len = __n + this->size();
        if (__len <= this->capacity()) {
            if (__n)
                this->_S_copy(this->_M_data() + this->size(), __s, __n);
        } else
            this->_M_mutate(this->size(), std::__cxx11::basic_string::size_type(0), __s, __n);
        this->_M_set_length(__len);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InputIterator> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type)     {
        const basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2, this->get_allocator());
        const std::__cxx11::basic_string::size_type __n1 = __i2 - __i1;
        return this->_M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c)     {
        this->_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
        const std::__cxx11::basic_string::size_type __old_size = this->size();
        const std::__cxx11::basic_string::size_type __new_size = __old_size + __n2 - __n1;
        if (__new_size <= this->capacity()) {
            std::__cxx11::basic_string::pointer __p = this->_M_data() + __pos1;
            const std::__cxx11::basic_string::size_type __how_much = __old_size - __pos1 - __n1;
            if (__how_much && __n1 != __n2)
                this->_S_move(__p + __n2, __p + __n1, __how_much);
        } else
            this->_M_mutate(__pos1, __n1, 0, __n2);
        if (__n2)
            this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, const std::__cxx11::basic_string::size_type __len2)     {
        this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
        const std::__cxx11::basic_string::size_type __old_size = this->size();
        const std::__cxx11::basic_string::size_type __new_size = __old_size + __len2 - __len1;
        if (__new_size <= this->capacity()) {
            std::__cxx11::basic_string::pointer __p = this->_M_data() + __pos;
            const std::__cxx11::basic_string::size_type __how_much = __old_size - __pos - __len1;
            if (this->_M_disjunct(__s)) {
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2)
                    this->_S_copy(__p, __s, __len2);
            } else {
                if (__len2 && __len2 <= __len1)
                    this->_S_move(__p, __s, __len2);
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2 > __len1) {
                    if (__s + __len2 <= __p + __len1)
                        this->_S_move(__p, __s, __len2);
                    else if (__s >= __p + __len1)
                        this->_S_copy(__p, __s + __len2 - __len1, __len2);
                    else {
                        const std::__cxx11::basic_string::size_type __nleft = (__p + __len1) - __s;
                        this->_S_move(__p, __s, __nleft);
                        this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                    }
                }
            }
        } else
            this->_M_mutate(__pos, __len1, __s, __len2);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, std::__cxx11::basic_string::size_type __n, std::__cxx11::basic_string::size_type __pos = 0) const     {
        this->_M_check(__pos, "basic_string::copy");
        __n = this->_M_limit(__pos, __n);
        ;
        if (__n)
            _S_copy(__s, _M_data() + __pos, __n);
        return __n;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        ;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        const __size_type __len = _Traits::length(__lhs);
        __string_type __str(_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
        __str.reserve(__len + __rhs.size());
        __str.append(__lhs, __len);
        __str.append(__rhs);
        return __str;
    }
    template<> basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        __string_type __str(_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
        const __size_type __len = __rhs.size();
        __str.reserve(__len + 1);
        __str.append(__size_type(1), __lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__n == 0)
            return __pos <= __size ? __pos : npos;
        if (__pos >= __size)
            return npos;
        const _CharT __elem0 = __s[0];
        const _CharT *const __data = data();
        const _CharT *__first = __data + __pos;
        const _CharT *const __last = __data + __size;
        std::__cxx11::basic_string::size_type __len = __size - __pos;
        while (__len >= __n)
            {
                __first = traits_type::find(__first, __len - __n + 1, __elem0);
                if (!__first)
                    return npos;
                if (traits_type::compare(__first, __s, __n) == 0)
                    return __first - __data;
                __len = __last - ++__first;
            }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept     {
        std::__cxx11::basic_string::size_type __ret = npos;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__pos < __size) {
            const _CharT *__data = _M_data();
            const std::__cxx11::basic_string::size_type __n = __size - __pos;
            const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
            if (__p)
                __ret = __p - __data;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__n <= __size) {
            __pos = std::min(std::__cxx11::basic_string::size_type(__size - __n), __pos);
            const _CharT *__data = _M_data();
            do {
                if (traits_type::compare(__data + __pos, __s, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept     {
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(_M_data()[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        for (; __n && __pos < this->size(); ++__pos) {
            const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::find(__s, __n, _M_data()[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept     {
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::eq(_M_data()[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept     {
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(_M_data()[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const     {
        this->_M_check(__pos, "basic_string::compare");
        __n = this->_M_limit(__pos, __n);
        const std::__cxx11::basic_string::size_type __osize = __str.size();
        const std::__cxx11::basic_string::size_type __len = std::min(__n, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
        if (!__r)
            __r = _S_compare(__n, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const     {
        this->_M_check(__pos1, "basic_string::compare");
        __str._M_check(__pos2, "basic_string::compare");
        __n1 = this->_M_limit(__pos1, __n1);
        __n2 = __str._M_limit(__pos2, __n2);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        const std::__cxx11::basic_string::size_type __osize = traits_type::length(__s);
        const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
        int __r = traits_type::compare(_M_data(), __s, __len);
        if (!__r)
            __r = _S_compare(__size, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::__cxx11::basic_string::size_type __osize = traits_type::length(__s);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        typedef ctype<_CharT> __ctype_type;
        typedef typename __ctype_type::ctype_base __ctype_base;
        __size_type __extracted = 0;
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                __str.erase();
                _CharT __buf[128];
                __size_type __len = 0;
                const std::streamsize __w = __in.width();
                const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        if (__len == sizeof (__buf) / sizeof(_CharT)) {
                            __str.append(__buf, sizeof (__buf) / sizeof(_CharT));
                            __len = 0;
                        }
                        __buf[__len++] = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                __str.append(__buf, __len);
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        __size_type __extracted = 0;
        const __size_type __n = __str.max_size();
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            try {
                __str.erase();
                const __int_type __idelim = _Traits::to_int_type(__delim);
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !_Traits::eq_int_type(__c, __idelim))
                    {
                        __str += _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                else if (_Traits::eq_int_type(__c, __idelim)) {
                    ++__extracted;
                    __in.rdbuf()->sbumpc();
                } else
                    __err |= __ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template<> class basic_string<char> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<char>>::rebind<char>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<char> traits_type;
        typedef typename char_traits<char>::char_type value_type;
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char>> iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char>> const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type npos = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type>(-1);
    protected:
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __const_iterator;
    private:
        typedef basic_string_view<char, std::char_traits<char>> __sv_type;
        template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char> *>>, __not_<is_convertible<const _Tp &, const char *>>>::value, _Res>;
        static std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type __svt) noexcept;
        struct __sv_wrapper {
            explicit __sv_wrapper(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type __sv) noexcept;
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type _M_sv;
        };
        explicit basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_wrapper __svw, const std::allocator<char> &__a);
        struct _Alloc_hider : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type {
            _Alloc_hider(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __dat, const std::allocator<char> &__a) : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type(__a), _M_p(__dat)             {
            }
            _Alloc_hider(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __dat, std::allocator<char> &&__a) : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type(std::move(__a)), _M_p(__dat)             {
            }
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_p;
        };
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_Alloc_hider _M_dataplus;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_string_length;
        enum  {
            _S_local_capacity = 15 / sizeof(char)
        };
        union {
            char _M_local_buf[16];
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_allocated_capacity;
        };
        void _M_data(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __p)         {
            this->_M_dataplus._M_p = __p;
        }
        void _M_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __length)         {
            this->_M_string_length = __length;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_data() const         {
            return this->_M_dataplus._M_p;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_local_data()         {
            return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_pointer _M_local_data() const         {
            return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
        }
        void _M_capacity(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __capacity)         {
            this->_M_allocated_capacity = __capacity;
        }
        void _M_set_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)         {
            this->_M_length(__n);
            traits_type::assign(this->_M_data()[__n], char());
        }
        bool _M_is_local() const         {
            return this->_M_data() == this->_M_local_data();
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type &, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type);
        void _M_dispose()         {
            if (!this->_M_is_local())
                this->_M_destroy(this->_M_allocated_capacity);
        }
        void _M_destroy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __size) throw()         {
            _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
        }
        template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
        template<> void _M_construct_aux<char *>(char *__beg, char *__end, std::__false_type)         {
            typedef typename iterator_traits<char *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template<> void _M_construct_aux<const char *>(const char *__beg, const char *__end, std::__false_type)         {
            typedef typename iterator_traits<const char *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
        void _M_construct_aux_2(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __req, char __c);
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
        template<> void _M_construct<char *>(char *__beg, char *__end)         {
            typedef typename std::__is_integer<char *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template<> void _M_construct<const char *>(const char *__beg, const char *__end)         {
            typedef typename std::__is_integer<const char *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template<> void _M_construct<char *>(char *__beg, char *__end, std::input_iterator_tag);
        template<> void _M_construct<const char *>(const char *__beg, const char *__end, std::input_iterator_tag);
        template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        template<> void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<char *>(char *__beg, char *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        template<> void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<const char *>(const char *__beg, const char *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        void _M_construct(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __req, char __c);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type &_M_get_allocator()         {
            return this->_M_dataplus;
        }
        const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type &_M_get_allocator() const         {
            return this->_M_dataplus;
        }
    private:
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_check(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s) const         {
            if (__pos > this->size())
                __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
            return __pos;
        }
        void _M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, const char *__s) const         {
            if (this->max_size() - (this->size() - __n1) < __n2)
                __throw_length_error((__s));
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_limit(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __off) const noexcept         {
            const bool __testoff = __off < this->size() - __pos;
            return __testoff ? __off : this->size() - __pos;
        }
        bool _M_disjunct(const char *__s) const noexcept;
        static void _S_copy(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)         {
            if (__n == 1)
                traits_type::assign(*__d, *__s);
            else
                traits_type::copy(__d, __s, __n);
        }
        static void _S_move(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        static void _S_assign(char *__d, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
        template <class _Iterator> static void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
        template<> static void _S_copy_chars<char *>(char *__p, char *__k1, char *__k2);
        template<> static void _S_copy_chars<const char *>(char *__p, const char *__k1, const char *__k2);
        static void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k2) noexcept;
        static void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k2) noexcept;
        static void _S_copy_chars(char *__p, char *__k1, char *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static void _S_copy_chars(char *__p, const char *__k1, const char *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static int _S_compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) noexcept;
        void _M_assign(const std::__cxx11::basic_string<char> &);
        void _M_mutate(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len2);
        void _M_erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
    public:
        basic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::valuebasic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::value);
        explicit basic_string(const std::allocator<char> &__a) noexcept;
        basic_string(const std::__cxx11::basic_string<char> &__str) : _M_dataplus(this->_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))         {
            this->_M_construct(__str._M_data(), __str._M_data() + __str.length());
        }
        basic_string(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const std::allocator<char> &__a);
        basic_string(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        basic_string(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a);
        basic_string(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__s, __s + __n);
        }
        template <typename = _RequireAllocator<std::allocator<char>>> basic_string(const char *__s, const std::allocator<char> &__a);
        template<> basic_string<std::allocator<char>>(const char *__s, const std::allocator<char> &__a);
        template <typename = _RequireAllocator<std::allocator<char>>> basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c, const std::allocator<char> &__a);
        template<> basic_string<std::allocator<char>>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__n, __c);
        }
;
        basic_string(std::__cxx11::basic_string<char> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))         {
            if (__str._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
            } else {
                this->_M_data(__str._M_data());
                this->_M_capacity(__str._M_allocated_capacity);
            }
            this->_M_length(__str.length());
            __str._M_data(__str._M_local_data());
            __str._M_set_length(0);
        }
        basic_string(initializer_list<char> __l, const std::allocator<char> &__a);
        basic_string(const std::__cxx11::basic_string<char> &__str, const std::allocator<char> &__a);
        basic_string(std::__cxx11::basic_string<char> &&__str, const std::allocator<char> &__a);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
        template<> basic_string<char *, void>(char *__beg, char *__end, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__beg, __end);
        }
;
        template <typename _Tp, typename = _If_sv<_Tp, void>> basic_string(const _Tp &__t, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a);
        template <typename _Tp, typename = _If_sv<_Tp, void>> explicit basic_string(const _Tp &__t, const std::allocator<char> &__a);
        ~basic_string<char>() noexcept         {
            this->_M_dispose();
        }
        std::__cxx11::basic_string<char> &operator=(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &operator=(const char *__s);
        std::__cxx11::basic_string<char> &operator=(char __c);
        std::__cxx11::basic_string<char> &operator=(std::__cxx11::basic_string<char> &&__str);
        std::__cxx11::basic_string<char> &operator=(initializer_list<char> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> operator=(const _Tp &__svt);
        operator __sv_type() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator begin() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator begin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator end() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator end() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reverse_iterator rbegin() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator rbegin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reverse_iterator rend() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator rend() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator cbegin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator cend() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator crbegin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator crend() const noexcept;
    public:
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type size() const noexcept         {
            return this->_M_string_length;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type length() const noexcept         {
            return this->_M_string_length;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type max_size() const noexcept         {
            return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
        }
        void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
        void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        void shrink_to_fit() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type capacity() const noexcept         {
            return this->_M_is_local() ? std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(_S_local_capacity) : this->_M_allocated_capacity;
        }
        void reserve(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __res_arg);
        void clear() noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos)         {
            ;
            ;
            return this->_M_data()[__pos];
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference front() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference front() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference back() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference back() const noexcept;
        std::__cxx11::basic_string<char> &operator+=(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &operator+=(const char *__s);
        std::__cxx11::basic_string<char> &operator+=(char __c);
        std::__cxx11::basic_string<char> &operator+=(initializer_list<char> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> operator+=(const _Tp &__svt);
        std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str)         {
            return this->_M_append(__str._M_data(), __str.size());
        }
        std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &append(const char *__s)         {
            ;
            const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n = traits_type::length(__s);
            this->_M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __n, "basic_string::append");
            return this->_M_append(__s, __n);
        }
        std::__cxx11::basic_string<char> &append(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
        std::__cxx11::basic_string<char> &append(initializer_list<char> __l);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char> &append(_InputIterator __first, _InputIterator __last);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> append(const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> append(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        void push_back(char __c);
        std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &assign(std::__cxx11::basic_string<char> &&__str);
        std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &assign(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &assign(const char *__s);
        std::__cxx11::basic_string<char> &assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
        std::__cxx11::basic_string<char> &assign(initializer_list<char> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> assign(const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, initializer_list<char> __l);
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const std::__cxx11::basic_string<char> &__str)         {
            return this->replace(__pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __str._M_data(), __str.size());
        }
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s)         {
            ;
            return this->replace(__pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __s, traits_type::length(__s));
        }
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __p, char __c);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __position);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __first, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __last);
        void pop_back() noexcept;
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2)         {
            ;
            return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
        }
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, char __c);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__s);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, char *__k1, char *__k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__k1, const char *__k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, initializer_list<char> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, const _Tp &__svt);
    private:
        template <class _Integer> std::__cxx11::basic_string<char> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::__cxx11::basic_string<char> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::__cxx11::basic_string<char> &_M_replace_aux(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, char __c);
        std::__cxx11::basic_string<char> &_M_replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len1, const char *__s, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len2);
        std::__cxx11::basic_string<char> &_M_append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
    public:
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type copy(char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos = 0) const;
        void swap(std::__cxx11::basic_string<char> &__s) noexcept;
        const char *c_str() const noexcept         {
            return this->_M_data();
        }
        const char *data() const noexcept         {
            return this->_M_data();
        }
        char *data() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type get_allocator() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char> substr(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const;
        int compare(const std::__cxx11::basic_string<char> &__str) const;
        template <typename _Tp> _If_sv<_Tp, int> compare(const _Tp &__svt) const;
        template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const _Tp &__svt) const;
        template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::__cxx11::basic_string<char> &__str) const;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
        int compare(const char *__s) const noexcept;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s) const;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
        friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
    };
    template<> class basic_string<wchar_t> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t>>::rebind<wchar_t>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename char_traits<wchar_t>::char_type value_type;
        typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::_Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t>> iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t>> const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type npos = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type>(-1);
    protected:
        typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __const_iterator;
    private:
        typedef basic_string_view<wchar_t, std::char_traits<wchar_t>> __sv_type;
        template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<wchar_t> *>>, __not_<is_convertible<const _Tp &, const wchar_t *>>>::value, _Res>;
        static std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type __svt) noexcept;
        struct __sv_wrapper {
            explicit __sv_wrapper(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type __sv) noexcept;
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type _M_sv;
        };
        explicit basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_wrapper __svw, const std::allocator<wchar_t> &__a);
        struct _Alloc_hider : std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type {
            _Alloc_hider(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer __dat, const std::allocator<wchar_t> &__a) : std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type(__a), _M_p(__dat)             {
            }
            _Alloc_hider(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer __dat, std::allocator<wchar_t> &&__a);
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_p;
        };
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::_Alloc_hider _M_dataplus;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_string_length;
        enum  {
            _S_local_capacity = 15 / sizeof(wchar_t)
        };
        union {
            wchar_t _M_local_buf[4];
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_allocated_capacity;
        };
        void _M_data(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer __p)         {
            this->_M_dataplus._M_p = __p;
        }
        void _M_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __length)         {
            this->_M_string_length = __length;
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_data() const         {
            return this->_M_dataplus._M_p;
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_local_data()         {
            return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_pointer _M_local_data() const         {
            return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
        }
        void _M_capacity(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __capacity)         {
            this->_M_allocated_capacity = __capacity;
        }
        void _M_set_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n)         {
            this->_M_length(__n);
            traits_type::assign(this->_M_data()[__n], wchar_t());
        }
        bool _M_is_local() const         {
            return this->_M_data() == this->_M_local_data();
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_create(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type &, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type);
        void _M_dispose()         {
            if (!this->_M_is_local())
                this->_M_destroy(this->_M_allocated_capacity);
        }
        void _M_destroy(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __size) throw()         {
            _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
        }
        template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
        template<> void _M_construct_aux<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::__false_type)         {
            typedef typename iterator_traits<wchar_t *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template<> void _M_construct_aux<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::__false_type)         {
            typedef typename iterator_traits<const wchar_t *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
        void _M_construct_aux_2(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __req, wchar_t __c);
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
        template<> void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end)         {
            typedef typename std::__is_integer<wchar_t *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template<> void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end)         {
            typedef typename std::__is_integer<const wchar_t *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template<> void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::input_iterator_tag);
        template<> void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::input_iterator_tag);
        template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        template<> void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        template<> void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        void _M_construct(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __req, wchar_t __c);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type &_M_get_allocator()         {
            return this->_M_dataplus;
        }
        const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type &_M_get_allocator() const;
    private:
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_check(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const char *__s) const;
        void _M_check_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, const char *__s) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_limit(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __off) const noexcept;
        bool _M_disjunct(const wchar_t *__s) const noexcept;
        static void _S_copy(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n)         {
            if (__n == 1)
                traits_type::assign(*__d, *__s);
            else
                traits_type::copy(__d, __s, __n);
        }
        static void _S_move(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        static void _S_assign(wchar_t *__d, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
        template <class _Iterator> static void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
        template<> static void _S_copy_chars<wchar_t *>(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
        template<> static void _S_copy_chars<const wchar_t *>(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
        static void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k2) noexcept;
        static void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k2) noexcept;
        static void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static int _S_compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) noexcept;
        void _M_assign(const std::__cxx11::basic_string<wchar_t> &);
        void _M_mutate(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len2);
        void _M_erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
    public:
        basic_string();
        explicit basic_string(const std::allocator<wchar_t> &__a) noexcept;
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const std::allocator<wchar_t> &__a);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a);
        basic_string(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__s, __s + __n);
        }
        template <typename = _RequireAllocator<std::allocator<wchar_t>>> basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
        template<> basic_string<std::allocator<wchar_t>>(const wchar_t *__s, const std::allocator<wchar_t> &__a);
        template <typename = _RequireAllocator<std::allocator<wchar_t>>> basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
        basic_string(std::__cxx11::basic_string<wchar_t> &&__str) noexcept;
        basic_string(initializer_list<wchar_t> __l, const std::allocator<wchar_t> &__a);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, const std::allocator<wchar_t> &__a);
        basic_string(std::__cxx11::basic_string<wchar_t> &&__str, const std::allocator<wchar_t> &__a);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
        template<> basic_string<wchar_t *, void>(wchar_t *__beg, wchar_t *__end, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__beg, __end);
        }
;
        template <typename _Tp, typename = _If_sv<_Tp, void>> basic_string(const _Tp &__t, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a);
        template <typename _Tp, typename = _If_sv<_Tp, void>> explicit basic_string(const _Tp &__t, const std::allocator<wchar_t> &__a);
        ~basic_string<wchar_t>() noexcept         {
            this->_M_dispose();
        }
        std::__cxx11::basic_string<wchar_t> &operator=(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &operator=(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &operator=(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &operator=(std::__cxx11::basic_string<wchar_t> &&__str);
        std::__cxx11::basic_string<wchar_t> &operator=(initializer_list<wchar_t> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> operator=(const _Tp &__svt);
        operator __sv_type() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator begin() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator begin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator end() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator end() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reverse_iterator rbegin() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator rbegin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reverse_iterator rend() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator rend() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator cbegin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator cend() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator crbegin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator crend() const noexcept;
    public:
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type size() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type length() const noexcept         {
            return this->_M_string_length;
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type max_size() const noexcept;
        void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
        void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        void shrink_to_fit() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type capacity() const noexcept;
        void reserve(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __res_arg);
        void clear() noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference front() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference front() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference back() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference back() const noexcept;
        std::__cxx11::basic_string<wchar_t> &operator+=(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &operator+=(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &operator+=(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &operator+=(initializer_list<wchar_t> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> operator+=(const _Tp &__svt);
        std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &append(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &append(initializer_list<wchar_t> __l);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> append(const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> append(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        void push_back(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &assign(std::__cxx11::basic_string<wchar_t> &&__str);
        std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &assign(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
        std::__cxx11::basic_string<wchar_t> &assign(initializer_list<wchar_t> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> assign(const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> assign(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, initializer_list<wchar_t> __l);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __p, wchar_t __c);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __position);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __first, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __last);
        void pop_back() noexcept;
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, initializer_list<wchar_t> __l);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const _Tp &__svt);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, const _Tp &__svt);
    private:
        template <class _Integer> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::__cxx11::basic_string<wchar_t> &_M_replace_aux(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &_M_replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len1, const wchar_t *__s, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len2);
        std::__cxx11::basic_string<wchar_t> &_M_append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
    public:
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type copy(wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        void swap(std::__cxx11::basic_string<wchar_t> &__s) noexcept;
        const wchar_t *c_str() const noexcept         {
            return this->_M_data();
        }
        const wchar_t *data() const noexcept         {
            return this->_M_data();
        }
        wchar_t *data() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type get_allocator() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        template <typename _Tp> _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t> substr(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const;
        int compare(const std::__cxx11::basic_string<wchar_t> &__str) const;
        template <typename _Tp> _If_sv<_Tp, int> compare(const _Tp &__svt) const;
        template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const _Tp &__svt) const;
        template <typename _Tp> _If_sv<_Tp, int> compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::__cxx11::basic_string<wchar_t> &__str) const;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
        int compare(const wchar_t *__s) const noexcept;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s) const;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
        friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
    };
}
namespace std {
    namespace pmr {
        template <typename _Tp> class polymorphic_allocator;
        template <typename _CharT, typename _Traits = char_traits<_CharT>> using basic_string = std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;
        using string = basic_string<char>;
        using u16string = basic_string<char16_t>;
        using u32string = basic_string<char32_t>;
        using wstring = basic_string<wchar_t>;
    }
    template <typename _Str> struct __hash_string_base : public __hash_base<std::size_t, _Str> {
        std::size_t operator()(const _Str &__s) const noexcept         {
            return hash<basic_string_view<typename _Str::value_type>>({})(__s);
        }
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>>> {
        std::size_t operator()(const std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>> &__s) const noexcept;
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>>> {
        std::size_t operator()(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>> &__s) const noexcept;
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>>> {
        std::size_t operator()(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>> &__s) const noexcept;
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>>> {
        std::size_t operator()(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>> &__s) const noexcept;
    };
    template<> struct hash<pmr::string> : public __hash_string_base<pmr::string> {
    };
    template<> struct hash<pmr::u16string> : public __hash_string_base<pmr::u16string> {
    };
    template<> struct hash<pmr::u32string> : public __hash_string_base<pmr::u32string> {
    };
    template<> struct hash<pmr::wstring> : public __hash_string_base<pmr::wstring> {
    };
}
namespace std {
    class locale {
    public:
        typedef int category;
        class facet;
        class id;
        class _Impl;
        friend  class facet;
        friend  class _Impl;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
        static const std::locale::category none = 0;
        static const std::locale::category ctype = 1L << 0;
        static const std::locale::category numeric = 1L << 1;
        static const std::locale::category collate = 1L << 2;
        static const std::locale::category time = 1L << 3;
        static const std::locale::category monetary = 1L << 4;
        static const std::locale::category messages = 1L << 5;
        static const std::locale::category all = (ctype | numeric | collate | time | monetary | messages);
        locale() throw();
        locale(const std::locale &__other) throw();
        explicit locale(const char *__s);
        locale(const std::locale &__base, const char *__s, std::locale::category __cat);
        explicit locale(const std::string &__s) : NULL TYPE(__s.c_str())         {
        }
        locale(const std::locale &__base, const std::string &__s, std::locale::category __cat) : NULL TYPE(__base, __s.c_str(), __cat)         {
        }
        locale(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        template <typename _Facet> locale(const std::locale &__other, _Facet *__f);
        ~locale() throw();
        const std::locale &operator=(const std::locale &__other) throw();
        template <typename _Facet> std::locale combine(const std::locale &__other) const;
        std::string name() const __attribute__((abi_tag("cxx11")));
        bool operator==(const std::locale &__other) const throw();
        bool operator!=(const std::locale &__other) const throw()         {
            return !(this->operator==(__other));
        }
        template <typename _Char, typename _Traits, typename _Alloc> bool operator()(const basic_string<_Char, _Traits, _Alloc> &__s1, const basic_string<_Char, _Traits, _Alloc> &__s2) const;
        static std::locale global(const std::locale &__loc);
        static const std::locale &classic();
    private:
        std::locale::_Impl *_M_impl;
        static std::locale::_Impl *_S_classic;
        static std::locale::_Impl *_S_global;
        static const char *const *const _S_categories;
        enum  {
            _S_categories_size = 6 + 6
        };
        static __gthread_once_t _S_once;
        explicit locale(std::locale::_Impl *) throw();
        static void _S_initialize();
        static void _S_initialize_once() throw();
        static std::locale::category _S_normalize_category(std::locale::category);
        void _M_coalesce(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        static const std::locale::id *const _S_twinned_facets[];
    };
    class facet {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        mutable _Atomic_word _M_refcount;
        static std::__c_locale _S_c_locale;
        static const char _S_c_name[2];
        static __gthread_once_t _S_once;
        static void _S_initialize_once();
    protected:
        explicit facet(std::size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)         {
        }
        virtual ~facet() noexcept;
        static void _S_create_c_locale(std::__c_locale &__cloc, const char *__s, std::__c_locale __old = 0);
        static std::__c_locale _S_clone_c_locale(std::__c_locale &__cloc) throw();
        static void _S_destroy_c_locale(std::__c_locale &__cloc);
        static std::__c_locale _S_lc_ctype_c_locale(std::__c_locale __cloc, const char *__s);
        static std::__c_locale _S_get_c_locale();
        static const char *_S_get_c_name() throw() __attribute__((const));
        facet(const std::locale::facet &) = delete
        std::locale::facet &operator=(const std::locale::facet &) = delete
    private:
        void _M_add_reference() const throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() const throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        const std::locale::facet *_M_sso_shim(const std::locale::id *) const;
        const std::locale::facet *_M_cow_shim(const std::locale::id *) const;
    protected:
        class __shim;
    };
    class id {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        mutable std::size_t _M_index;
        static _Atomic_word _S_refcount;
        void operator=(const std::locale::id &);
        id(const std::locale::id &);
    public:
        id()         {
        }
        std::size_t _M_id() const throw();
    };
    class _Impl {
    public:
        friend  class locale;
        friend  class locale::facet;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
    private:
        _Atomic_word _M_refcount;
        const std::locale::facet **_M_facets;
        std::size_t _M_facets_size;
        const std::locale::facet **_M_caches;
        char **_M_names;
        static const locale::id *const _S_id_ctype[];
        static const locale::id *const _S_id_numeric[];
        static const locale::id *const _S_id_collate[];
        static const locale::id *const _S_id_time[];
        static const locale::id *const _S_id_monetary[];
        static const locale::id *const _S_id_messages[];
        static const locale::id *const *const _S_facet_categories[];
        void _M_add_reference() throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        _Impl(const std::locale::_Impl &, std::size_t);
        _Impl(const char *, std::size_t);
        _Impl(std::size_t) throw();
        ~_Impl() throw();
        _Impl(const std::locale::_Impl &);
        void operator=(const std::locale::_Impl &);
        bool _M_check_same_name()         {
            bool __ret = true;
            if (this->_M_names[1])
                for (std::size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
                    __ret = __builtin_strcmp(this->_M_names[__i], this->_M_names[__i + 1]) == 0;
            return __ret;
        }
        void _M_replace_categories(const std::locale::_Impl *, std::locale::category);
        void _M_replace_category(const std::locale::_Impl *, const locale::id *const *);
        void _M_replace_facet(const std::locale::_Impl *, const locale::id *);
        void _M_install_facet(const locale::id *, const std::locale::facet *);
        template <typename _Facet> void _M_init_facet(_Facet *__facet)         {
            this->_M_install_facet(&_Facet::id, __facet);
        }
        template <typename _Facet> void _M_init_facet_unchecked(_Facet *__facet)         {
            __facet->_M_add_reference();
            this->_M_facets[_Facet::id._M_id()] = __facet;
        }
        void _M_install_cache(const std::locale::facet *, std::size_t);
        void _M_init_extra(std::locale::facet **);
        void _M_init_extra(void *, void *, const char *, const char *);
    };
    template <typename _CharT> class collate : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale())         {
        }
        explicit collate<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))         {
        }
        int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const         {
            return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }
        std::__cxx11::collate::string_type transform(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_transform(__lo, __hi);
        }
        long hash(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_hash(__lo, __hi);
        }
        int _M_compare(const _CharT *, const _CharT *) const throw();
        std::size_t _M_transform(_CharT *, const _CharT *, std::size_t) const throw();
    protected:
        virtual ~collate<_CharT>()         {
            _S_destroy_c_locale(this->_M_c_locale_collate);
        }
        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const;
        virtual std::__cxx11::collate::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const;
        virtual long do_hash(const _CharT *__lo, const _CharT *__hi) const;
    };
    locale::id id;
    template <> int collate<char>::_M_compare(const char *, const char *) const throw();
    template <> std::size_t collate<char>::_M_transform(char *, const char *, std::size_t) const throw();
    template <> int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const throw();
    template <> std::size_t collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    template <typename _CharT> class collate_byname : public collate<_CharT> {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
        explicit collate_byname<_CharT>(const char *__s, std::size_t __refs = 0) : collate<_CharT>(__refs)         {
            if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                this->_S_destroy_c_locale(this->_M_c_locale_collate);
                this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }
        explicit collate_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : collate_byname<_CharT>(__s.c_str(), __refs)         {
        }
    protected:
        virtual ~collate_byname<_CharT>()         {
        }
    };
}
namespace std {
    template <typename _Facet> locale::locale(const std::locale &__other, _Facet *__f)     {
        this->_M_impl = new std::locale::_Impl(*__other._M_impl, 1);
        try {
            this->_M_impl->_M_install_facet(&_Facet::id, __f);
        } catch (...) {
            this->_M_impl->_M_remove_reference();
            throw;
        }
        delete [] this->_M_impl->_M_names[0];
        this->_M_impl->_M_names[0] = 0;
    }
    template <typename _Facet> std::locale locale::combine(const std::locale &__other) const     {
        std::locale::_Impl *__tmp = new std::locale::_Impl(*this->_M_impl, 1);
        try {
            __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
        } catch (...) {
            __tmp->_M_remove_reference();
            throw;
        }
        return std::locale(__tmp);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> bool locale::operator()(const basic_string<_CharT, _Traits, _Alloc> &__s1, const basic_string<_CharT, _Traits, _Alloc> &__s2) const     {
        typedef std::collate<_CharT> __collate_type;
        const __collate_type &__collate = use_facet<__collate_type>(*this);
        return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0);
    }
    template <typename _Facet> bool has_facet(const std::locale &__loc) throw()     {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        return (__i < __loc._M_impl->_M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]));
    }
    template <typename _Facet> const _Facet &use_facet(const std::locale &__loc)     {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
            __throw_bad_cast();
        return dynamic_cast<const _Facet &>(*__facets[__i]);
    }
    template <typename _CharT> int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const throw()     {
        return 0;
    }
    template <typename _CharT> std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, std::size_t) const throw()     {
        return 0;
    }
    template <typename _CharT> int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const     {
        const std::__cxx11::collate::string_type __one(__lo1, __hi1);
        const std::__cxx11::collate::string_type __two(__lo2, __hi2);
        const _CharT *__p = __one.c_str();
        const _CharT *__pend = __one.data() + __one.length();
        const _CharT *__q = __two.c_str();
        const _CharT *__qend = __two.data() + __two.length();
        for (;;) {
            const int __res = this->_M_compare(__p, __q);
            if (__res)
                return __res;
            __p += char_traits<_CharT>::length(__p);
            __q += char_traits<_CharT>::length(__q);
            if (__p == __pend && __q == __qend)
                return 0;
            else if (__p == __pend)
                return -1;
            else if (__q == __qend)
                return 1;
            __p++;
            __q++;
        }
    }
    template <typename _CharT> typename collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const     {
        std::__cxx11::collate::string_type __ret;
        const std::__cxx11::collate::string_type __str(__lo, __hi);
        const _CharT *__p = __str.c_str();
        const _CharT *__pend = __str.data() + __str.length();
        std::size_t __len = (__hi - __lo) * 2;
        _CharT *__c = new _CharT [__len];
        try {
            for (;;) {
                std::size_t __res = this->_M_transform(__c, __p, __len);
                if (__res >= __len) {
                    __len = __res + 1;
                    delete [] __c , __c = 0;
                    __c = new _CharT [__len];
                    __res = this->_M_transform(__c, __p, __len);
                }
                __ret.append(__c, __res);
                __p += char_traits<_CharT>::length(__p);
                if (__p == __pend)
                    break;
                __p++;
                __ret.push_back(_CharT());
            }
        } catch (...) {
            delete [] __c;
            throw;
        }
        delete [] __c;
        return __ret;
    }
    template <typename _CharT> long collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const     {
        unsigned long __val = 0;
        for (; __lo < __hi; ++__lo)
            __val = *__lo + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::__digits - 7)));
        return static_cast<long>(__val);
    }
    template<> class collate<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        std::__cxx11::collate<char>::string_type transform(const char *__lo, const char *__hi) const;
        long hash(const char *__lo, const char *__hi) const;
        int _M_compare(const char *, const char *) const throw();
        std::size_t _M_transform(char *, const char *, std::size_t) const throw();
    protected:
        virtual ~collate<char>() noexcept;
        virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        virtual std::__cxx11::collate<char>::string_type do_transform(const char *__lo, const char *__hi) const;
        virtual long do_hash(const char *__lo, const char *__hi) const;
    };
    template<> class collate_byname<char> : public collate<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<char>() noexcept;
    };
    template<> class collate<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        std::__cxx11::collate<wchar_t>::string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
        long hash(const wchar_t *__lo, const wchar_t *__hi) const;
        int _M_compare(const wchar_t *, const wchar_t *) const throw();
        std::size_t _M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    protected:
        virtual ~collate<wchar_t>() noexcept;
        virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        virtual std::__cxx11::collate<wchar_t>::string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
        virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
    };
    template<> class collate_byname<wchar_t> : public collate<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<wchar_t>() noexcept;
    };
}
namespace std {
    enum class errc : int {
        address_family_not_supported = 97,
        address_in_use = 98,
        address_not_available = 99,
        already_connected = 106,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 74,
        broken_pipe = 32,
        connection_aborted = 103,
        connection_already_in_progress = 114,
        connection_refused = 111,
        connection_reset = 104,
        cross_device_link = 18,
        destination_address_required = 89,
        device_or_resource_busy = 16,
        directory_not_empty = 39,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 36,
        function_not_supported = 38,
        host_unreachable = 113,
        identifier_removed = 43,
        illegal_byte_sequence = 84,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 90,
        network_down = 100,
        network_reset = 102,
        network_unreachable = 101,
        no_buffer_space = 105,
        no_child_process = 10,
        no_link = 67,
        no_lock_available = 37,
        no_message_available = 61,
        no_message = 42,
        no_protocol_option = 92,
        no_space_on_device = 28,
        no_stream_resources = 63,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 88,
        not_a_stream = 60,
        not_connected = 107,
        not_enough_memory = 12,
        not_supported = 95,
        operation_canceled = 125,
        operation_in_progress = 115,
        operation_not_permitted = 1,
        operation_not_supported = 95,
        operation_would_block = 11,
        owner_dead = 130,
        permission_denied = 13,
        protocol_error = 71,
        protocol_not_supported = 93,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 35,
        resource_unavailable_try_again = 11,
        result_out_of_range = 34,
        state_not_recoverable = 131,
        stream_timeout = 62,
        text_file_busy = 26,
        timed_out = 110,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_symbolic_link_levels = 40,
        value_too_large = 75,
        wrong_protocol_type = 91
    };
}
namespace std {
    struct __cow_string {
        union {
            const char *_M_p;
            char _M_bytes[8];
        };
        __cow_string();
        __cow_string(const std::string &);
        __cow_string(const char *, std::size_t);
        __cow_string(const std::__cow_string &) noexcept;
        std::__cow_string &operator=(const std::__cow_string &) noexcept;
        ~__cow_string();
        __cow_string(std::__cow_string &&) noexcept;
        std::__cow_string &operator=(std::__cow_string &&) noexcept;
    };
    typedef basic_string<char> __sso_string;
    class logic_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit logic_error(const std::string &__arg);
        explicit logic_error(const char *);
        logic_error(std::logic_error &&) noexcept;
        std::logic_error &operator=(std::logic_error &&) noexcept;
        logic_error(const std::logic_error &) noexcept;
        std::logic_error &operator=(const std::logic_error &) noexcept;
        virtual ~logic_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class domain_error : public std::logic_error {
    public:
        explicit domain_error(const std::string &__arg);
        explicit domain_error(const char *);
        domain_error(const std::domain_error &) = default
        std::domain_error &operator=(const std::domain_error &) = default
        domain_error(std::domain_error &&) = default
        std::domain_error &operator=(std::domain_error &&) = default
        virtual ~domain_error() noexcept;
    };
    class invalid_argument : public std::logic_error {
    public:
        explicit invalid_argument(const std::string &__arg);
        explicit invalid_argument(const char *);
        invalid_argument(const std::invalid_argument &) = default
        std::invalid_argument &operator=(const std::invalid_argument &) = default
        invalid_argument(std::invalid_argument &&) = default
        std::invalid_argument &operator=(std::invalid_argument &&) = default
        virtual ~invalid_argument() noexcept;
    };
    class length_error : public std::logic_error {
    public:
        explicit length_error(const std::string &__arg);
        explicit length_error(const char *);
        length_error(const std::length_error &) = default
        std::length_error &operator=(const std::length_error &) = default
        length_error(std::length_error &&) = default
        std::length_error &operator=(std::length_error &&) = default
        virtual ~length_error() noexcept;
    };
    class out_of_range : public std::logic_error {
    public:
        explicit out_of_range(const std::string &__arg);
        explicit out_of_range(const char *);
        out_of_range(const std::out_of_range &) = default
        std::out_of_range &operator=(const std::out_of_range &) = default
        out_of_range(std::out_of_range &&) = default
        std::out_of_range &operator=(std::out_of_range &&) = default
        virtual ~out_of_range() noexcept;
    };
    class runtime_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit runtime_error(const std::string &__arg);
        explicit runtime_error(const char *);
        runtime_error(std::runtime_error &&) noexcept;
        std::runtime_error &operator=(std::runtime_error &&) noexcept;
        runtime_error(const std::runtime_error &) noexcept;
        std::runtime_error &operator=(const std::runtime_error &) noexcept;
        virtual ~runtime_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class range_error : public std::runtime_error {
    public:
        explicit range_error(const std::string &__arg);
        explicit range_error(const char *);
        range_error(const std::range_error &) = default
        std::range_error &operator=(const std::range_error &) = default
        range_error(std::range_error &&) = default
        std::range_error &operator=(std::range_error &&) = default
        virtual ~range_error() noexcept;
    };
    class overflow_error : public std::runtime_error {
    public:
        explicit overflow_error(const std::string &__arg);
        explicit overflow_error(const char *);
        overflow_error(const std::overflow_error &) = default
        std::overflow_error &operator=(const std::overflow_error &) = default
        overflow_error(std::overflow_error &&) = default
        std::overflow_error &operator=(std::overflow_error &&) = default
        virtual ~overflow_error() noexcept;
    };
    class underflow_error : public std::runtime_error {
    public:
        explicit underflow_error(const std::string &__arg);
        explicit underflow_error(const char *);
        underflow_error(const std::underflow_error &) = default
        std::underflow_error &operator=(const std::underflow_error &) = default
        underflow_error(std::underflow_error &&) = default
        std::underflow_error &operator=(std::underflow_error &&) = default
        virtual ~underflow_error() noexcept;
    };
}
namespace std {
    class error_code;
    class error_condition;
    class system_error;
    template <typename _Tp> struct is_error_code_enum : public std::false_type {
    };
template<> struct is_error_code_enum<std::_V2::error_category> : public std::false_type {
    };
template<> struct is_error_code_enum<int> : public std::false_type {
    };
template<> struct is_error_code_enum<std::error_condition> : public std::false_type {
    };
template<> struct is_error_code_enum<std::error_code> : public std::false_type {
    };
template<> struct is_error_code_enum<const char *> : public std::false_type {
    };
    template <typename _Tp> struct is_error_condition_enum : public std::false_type {
    };
template<> struct is_error_condition_enum<std::_V2::error_category> : public std::false_type {
    };
template<> struct is_error_condition_enum<std::error_code> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::errc> : public std::true_type {
    };
    template <typename _Tp> constexpr bool is_error_code_enum_v = is_error_code_enum<_Tp>::value;
    template <typename _Tp> constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;
    inline namespace _V2 {
        class error_category {
        public:
            error_category() noexcept = default
            virtual ~error_category();
            error_category(const std::_V2::error_category &) = delete
            std::_V2::error_category &operator=(const std::_V2::error_category &) = delete
            virtual const char *name() const noexcept = 0;
        private:
            virtual std::__cow_string _M_message(int) const __attribute__((abi_tag("cxx11")));
        public:
            virtual std::string message(int) const __attribute__((abi_tag("cxx11"))) = 0;
        public:
            virtual std::error_condition default_error_condition(int __i) const noexcept;
            virtual bool equivalent(int __i, const std::error_condition &__cond) const noexcept;
            virtual bool equivalent(const std::error_code &__code, int __i) const noexcept;
            bool operator==(const std::_V2::error_category &__other) const noexcept             {
                return this == &__other;
            }
            bool operator!=(const std::_V2::error_category &__other) const noexcept             {
                return this != &__other;
            }
            bool operator<(const std::_V2::error_category &__other) const noexcept             {
                return less<const std::_V2::error_category *>()(this, &__other);
            }
        };
        const std::_V2::error_category &generic_category() noexcept __attribute__((const));
        const std::_V2::error_category &system_category() noexcept __attribute__((const));
    }
    std::error_code make_error_code(std::errc) noexcept;
    struct error_code {
        error_code() noexcept : _M_value(0), _M_cat(&system_category())         {
        }
        error_code(int __v, const std::_V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat)         {
        }
        template <typename _ErrorCodeEnum, typename = typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type> error_code(_ErrorCodeEnum __e) noexcept         {
            *this = make_error_code(__e);
        }
        template<> error_code<std::io_errc, void>(std::io_errc __e) noexcept        void assign(int __v, const std::_V2::error_category &__cat) noexcept         {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        void clear() noexcept         {
            this->assign(0, system_category());
        }
        template <typename _ErrorCodeEnum> typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value, error_code &>::type operator=(_ErrorCodeEnum __e) noexcept         {
            return *this = make_error_code(__e);
        }
        int value() const noexcept         {
            return this->_M_value;
        }
        const std::_V2::error_category &category() const noexcept         {
            return *this->_M_cat;
        }
        std::error_condition default_error_condition() const noexcept;
        std::string message() const __attribute__((abi_tag("cxx11")))         {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept         {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const std::_V2::error_category *_M_cat;
    };
    inline std::error_code make_error_code(std::errc __e) noexcept     {
        return std::error_code(static_cast<int>(__e), generic_category());
    }
    inline bool operator<(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        return (__lhs.category() < __rhs.category() || (__lhs.category() == __rhs.category() && __lhs.value() < __rhs.value()));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::error_code &__e)     {
        return (__os << __e.category().name() << ':' << __e.value());
    }
    std::error_condition make_error_condition(std::errc) noexcept;
    struct error_condition {
        error_condition() noexcept : _M_value(0), _M_cat(&generic_category())         {
        }
        error_condition(int __v, const std::_V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat)         {
        }
        template <typename _ErrorConditionEnum, typename = typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type> error_condition(_ErrorConditionEnum __e) noexcept         {
            *this = make_error_condition(__e);
        }
        void assign(int __v, const std::_V2::error_category &__cat) noexcept         {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        template <typename _ErrorConditionEnum> typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value, error_condition &>::type operator=(_ErrorConditionEnum __e) noexcept         {
            return *this = make_error_condition(__e);
        }
        void clear() noexcept         {
            this->assign(0, generic_category());
        }
        int value() const noexcept         {
            return this->_M_value;
        }
        const std::_V2::error_category &category() const noexcept         {
            return *this->_M_cat;
        }
        std::string message() const __attribute__((abi_tag("cxx11")))         {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept         {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const std::_V2::error_category *_M_cat;
    };
    inline std::error_condition make_error_condition(std::errc __e) noexcept     {
        return std::error_condition(static_cast<int>(__e), generic_category());
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value()));
    }
    inline bool operator==(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline bool operator<(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category() < __rhs.category() || (__lhs.category() == __rhs.category() && __lhs.value() < __rhs.value()));
    }
    inline bool operator==(const std::error_condition &__lhs, const std::error_code &__rhs) noexcept     {
        return (__rhs.category().equivalent(__rhs.value(), __lhs) || __lhs.category().equivalent(__rhs, __lhs.value()));
    }
    inline bool operator!=(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_code &__lhs, const std::error_condition &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_condition &__lhs, const std::error_code &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    class system_error : public std::runtime_error {
    private:
        std::error_code _M_code;
    public:
        system_error(std::error_code __ec = std::error_code()) : std::runtime_error(__ec.message()), _M_code(__ec)         {
        }
        system_error(std::error_code __ec, const std::string &__what) : std::runtime_error(__what + ": " + __ec.message()), _M_code(__ec)         {
        }
        system_error(std::error_code __ec, const char *__what) : std::runtime_error(__what + (": " + __ec.message())), _M_code(__ec)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat, const char *__what) : NULL TYPE(std::error_code(__v, __ecat), __what)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat) : std::runtime_error(std::error_code(__v, __ecat).message()), _M_code(__v, __ecat)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat, const std::string &__what) : std::runtime_error(__what + ": " + std::error_code(__v, __ecat).message()), _M_code(__v, __ecat)         {
        }
        system_error(const std::system_error &) = default
        std::system_error &operator=(const std::system_error &) = default
        virtual ~system_error() noexcept;
        const std::error_code &code() const noexcept         {
            return this->_M_code;
        }
    };
}
namespace std {
    template<> struct hash<std::error_code> : public __hash_base<std::size_t, std::error_code> {
        std::size_t operator()(const std::error_code &__e) const noexcept         {
            const std::size_t __tmp = std::_Hash_impl::hash(__e.value());
            return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
        }
    };
    template<> struct hash<std::error_condition> : public __hash_base<std::size_t, std::error_condition> {
        std::size_t operator()(const std::error_condition &__e) const noexcept         {
            const std::size_t __tmp = std::_Hash_impl::hash(__e.value());
            return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
        }
    };
}
namespace std {
    enum _Ios_Fmtflags {
        _S_boolalpha = 1L << 0,
        _S_dec = 1L << 1,
        _S_fixed = 1L << 2,
        _S_hex = 1L << 3,
        _S_internal = 1L << 4,
        _S_left = 1L << 5,
        _S_oct = 1L << 6,
        _S_right = 1L << 7,
        _S_scientific = 1L << 8,
        _S_showbase = 1L << 9,
        _S_showpoint = 1L << 10,
        _S_showpos = 1L << 11,
        _S_skipws = 1L << 12,
        _S_unitbuf = 1L << 13,
        _S_uppercase = 1L << 14,
        _S_adjustfield = _S_left | _S_right | _S_internal,
        _S_basefield = _S_dec | _S_oct | _S_hex,
        _S_floatfield = _S_scientific | _S_fixed,
        _S_ios_fmtflags_end = 1L << 16,
        _S_ios_fmtflags_max = 2147483647,
        _S_ios_fmtflags_min = ~2147483647
    };
    inline constexpr std::_Ios_Fmtflags operator&(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator|(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator^(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator~(std::_Ios_Fmtflags __a)     {
        return std::_Ios_Fmtflags(~static_cast<int>(__a));
    }
    inline const std::_Ios_Fmtflags &operator|=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Fmtflags &operator&=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Fmtflags &operator^=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Openmode {
        _S_app = 1L << 0,
        _S_ate = 1L << 1,
        _S_bin = 1L << 2,
        _S_in = 1L << 3,
        _S_out = 1L << 4,
        _S_trunc = 1L << 5,
        _S_ios_openmode_end = 1L << 16,
        _S_ios_openmode_max = 2147483647,
        _S_ios_openmode_min = ~2147483647
    };
    inline constexpr std::_Ios_Openmode operator&(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator|(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator^(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator~(std::_Ios_Openmode __a)     {
        return std::_Ios_Openmode(~static_cast<int>(__a));
    }
    inline const std::_Ios_Openmode &operator|=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Openmode &operator&=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Openmode &operator^=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Iostate {
        _S_goodbit = 0,
        _S_badbit = 1L << 0,
        _S_eofbit = 1L << 1,
        _S_failbit = 1L << 2,
        _S_ios_iostate_end = 1L << 16,
        _S_ios_iostate_max = 2147483647,
        _S_ios_iostate_min = ~2147483647
    };
    inline constexpr std::_Ios_Iostate operator&(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator|(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator^(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator~(std::_Ios_Iostate __a)     {
        return std::_Ios_Iostate(~static_cast<int>(__a));
    }
    inline const std::_Ios_Iostate &operator|=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Iostate &operator&=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Iostate &operator^=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Seekdir {
        _S_beg = 0,
        _S_cur = 1,
        _S_end = 2,
        _S_ios_seekdir_end = 1L << 16
    };
    enum class io_errc : int {
        stream = 1
    };
    template<> struct is_error_code_enum<std::io_errc> : public std::true_type {
    };
    const std::_V2::error_category &iostream_category() noexcept;
    inline std::error_code make_error_code(std::io_errc __e) noexcept     {
        return std::error_code(static_cast<int>(__e), iostream_category());
    }
    inline std::error_condition make_error_condition(std::io_errc __e) noexcept     {
        return std::error_condition(static_cast<int>(__e), iostream_category());
    }
    class ios_base {
    public:
        class __attribute__((abi_tag("cxx11"))) failure : public std::system_error {
        public:
            explicit failure(const std::string &__str);
            explicit failure(const std::string &, const std::error_code &);
            explicit failure(const char *, const std::error_code & = io_errc::stream);
            virtual ~failure() throw();
            virtual const char *what() const throw();
        };
        typedef std::_Ios_Fmtflags fmtflags;
        static const std::ios_base::fmtflags boolalpha = _S_boolalpha;
        static const std::ios_base::fmtflags dec = _S_dec;
        static const std::ios_base::fmtflags fixed = _S_fixed;
        static const std::ios_base::fmtflags hex = _S_hex;
        static const std::ios_base::fmtflags internal = _S_internal;
        static const std::ios_base::fmtflags left = _S_left;
        static const std::ios_base::fmtflags oct = _S_oct;
        static const std::ios_base::fmtflags right = _S_right;
        static const std::ios_base::fmtflags scientific = _S_scientific;
        static const std::ios_base::fmtflags showbase = _S_showbase;
        static const std::ios_base::fmtflags showpoint = _S_showpoint;
        static const std::ios_base::fmtflags showpos = _S_showpos;
        static const std::ios_base::fmtflags skipws = _S_skipws;
        static const std::ios_base::fmtflags unitbuf = _S_unitbuf;
        static const std::ios_base::fmtflags uppercase = _S_uppercase;
        static const std::ios_base::fmtflags adjustfield = _S_adjustfield;
        static const std::ios_base::fmtflags basefield = _S_basefield;
        static const std::ios_base::fmtflags floatfield = _S_floatfield;
        typedef std::_Ios_Iostate iostate;
        static const std::ios_base::iostate badbit = _S_badbit;
        static const std::ios_base::iostate eofbit = _S_eofbit;
        static const std::ios_base::iostate failbit = _S_failbit;
        static const std::ios_base::iostate goodbit = _S_goodbit;
        typedef std::_Ios_Openmode openmode;
        static const std::ios_base::openmode app = _S_app;
        static const std::ios_base::openmode ate = _S_ate;
        static const std::ios_base::openmode binary = _S_bin;
        static const std::ios_base::openmode in = _S_in;
        static const std::ios_base::openmode out = _S_out;
        static const std::ios_base::openmode trunc = _S_trunc;
        typedef std::_Ios_Seekdir seekdir;
        static const std::ios_base::seekdir beg = _S_beg;
        static const std::ios_base::seekdir cur = _S_cur;
        static const std::ios_base::seekdir end = _S_end;
        enum event {
            erase_event,
            imbue_event,
            copyfmt_event
        };
        typedef void (*event_callback)(std::ios_base::event, std::ios_base &, int);
        void register_callback(std::ios_base::event_callback __fn, int __index);
    protected:
        std::streamsize _M_precision;
        std::streamsize _M_width;
        std::ios_base::fmtflags _M_flags;
        std::ios_base::iostate _M_exception;
        std::ios_base::iostate _M_streambuf_state;
        struct _Callback_list {
            std::ios_base::_Callback_list *_M_next;
            ios_base::event_callback _M_fn;
            int _M_index;
            _Atomic_word _M_refcount;
            _Callback_list(ios_base::event_callback __fn, int __index, std::ios_base::_Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)             {
            }
            void _M_add_reference()             {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
            }
            int _M_remove_reference()             {
                ;
                int __res = __gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1);
                if (__res == 0) {
                    ;
                }
                return __res;
            }
        };
        std::ios_base::_Callback_list *_M_callbacks;
        void _M_call_callbacks(std::ios_base::event __ev) throw();
        void _M_dispose_callbacks() throw();
        struct _Words {
            void *_M_pword;
            long _M_iword;
            _Words() : _M_pword(0), _M_iword(0)             {
            }
        };
        std::ios_base::_Words _M_word_zero;
        enum  {
            _S_local_word_size = 8
        };
        std::ios_base::_Words _M_local_word[8];
        int _M_word_size;
        std::ios_base::_Words *_M_word;
        std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
        std::locale _M_ios_locale;
        void _M_init() throw();
    public:
        class Init {
            friend  class ios_base;
        public:
            Init();
            ~Init() noexcept;
            Init(const std::ios_base::Init &) = default
            std::ios_base::Init &operator=(const std::ios_base::Init &) = default
        private:
            static _Atomic_word _S_refcount;
            static bool _S_synced_with_stdio;
        };
        std::ios_base::fmtflags flags() const         {
            return this->_M_flags;
        }
        std::ios_base::fmtflags flags(std::ios_base::fmtflags __fmtfl)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags = __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags |= __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl, std::ios_base::fmtflags __mask)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags &= ~ __mask;
            this->_M_flags |= (__fmtfl & __mask);
            return __old;
        }
        void unsetf(std::ios_base::fmtflags __mask)         {
            this->_M_flags &= ~ __mask;
        }
        std::streamsize precision() const         {
            return this->_M_precision;
        }
        std::streamsize precision(std::streamsize __prec)         {
            std::streamsize __old = this->_M_precision;
            this->_M_precision = __prec;
            return __old;
        }
        std::streamsize width() const         {
            return this->_M_width;
        }
        std::streamsize width(std::streamsize __wide)         {
            std::streamsize __old = this->_M_width;
            this->_M_width = __wide;
            return __old;
        }
        static bool sync_with_stdio(bool __sync = true);
        std::locale imbue(const std::locale &__loc) throw();
        std::locale getloc() const         {
            return this->_M_ios_locale;
        }
        const std::locale &_M_getloc() const         {
            return this->_M_ios_locale;
        }
        static int xalloc() throw();
        long &iword(int __ix)         {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, true);
            return __word._M_iword;
        }
        void *&pword(int __ix)         {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, false);
            return __word._M_pword;
        }
        virtual ~ios_base() throw();
    protected:
        ios_base() throw();
    public:
        ios_base(const std::ios_base &) = delete
        std::ios_base &operator=(const std::ios_base &) = delete
    protected:
        void _M_move(std::ios_base &) noexcept;
        void _M_swap(std::ios_base &__rhs) noexcept;
    };
    inline std::ios_base &boolalpha(std::ios_base &__base)     {
        __base.setf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &noboolalpha(std::ios_base &__base)     {
        __base.unsetf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &showbase(std::ios_base &__base)     {
        __base.setf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &noshowbase(std::ios_base &__base)     {
        __base.unsetf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &showpoint(std::ios_base &__base)     {
        __base.setf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &noshowpoint(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &showpos(std::ios_base &__base)     {
        __base.setf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &noshowpos(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &skipws(std::ios_base &__base)     {
        __base.setf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &noskipws(std::ios_base &__base)     {
        __base.unsetf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &uppercase(std::ios_base &__base)     {
        __base.setf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &nouppercase(std::ios_base &__base)     {
        __base.unsetf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &unitbuf(std::ios_base &__base)     {
        __base.setf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &nounitbuf(std::ios_base &__base)     {
        __base.unsetf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &internal(std::ios_base &__base)     {
        __base.setf(ios_base::internal, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &left(std::ios_base &__base)     {
        __base.setf(ios_base::left, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &right(std::ios_base &__base)     {
        __base.setf(ios_base::right, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &dec(std::ios_base &__base)     {
        __base.setf(ios_base::dec, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &hex(std::ios_base &__base)     {
        __base.setf(ios_base::hex, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &oct(std::ios_base &__base)     {
        __base.setf(ios_base::oct, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &fixed(std::ios_base &__base)     {
        __base.setf(ios_base::fixed, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &scientific(std::ios_base &__base)     {
        __base.setf(ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &hexfloat(std::ios_base &__base)     {
        __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &defaultfloat(std::ios_base &__base)     {
        __base.unsetf(ios_base::floatfield);
        return __base;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf::char_type, std::basic_streambuf::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf::char_type *_M_in_beg;
        std::basic_streambuf::char_type *_M_in_cur;
        std::basic_streambuf::char_type *_M_in_end;
        std::basic_streambuf::char_type *_M_out_beg;
        std::basic_streambuf::char_type *_M_out_cur;
        std::basic_streambuf::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<_CharT, _Traits>()         {
        }
        std::locale pubimbue(const std::locale &__loc)         {
            std::locale __tmp(this->getloc());
            this->imbue(__loc);
            this->_M_buf_locale = __loc;
            return __tmp;
        }
        std::locale getloc() const         {
            return this->_M_buf_locale;
        }
        basic_streambuf<_CharT, _Traits> *pubsetbuf(std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->setbuf(__s, __n);
        }
        std::basic_streambuf::pos_type pubseekoff(std::basic_streambuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekoff(__off, __way, __mode);
        }
        std::basic_streambuf::pos_type pubseekpos(std::basic_streambuf::pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekpos(__sp, __mode);
        }
        int pubsync()         {
            return this->sync();
        }
        std::streamsize in_avail()         {
            const std::streamsize __ret = this->egptr() - this->gptr();
            return __ret ? __ret : this->showmanyc();
        }
        std::basic_streambuf::int_type snextc()         {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
                __ret = this->sgetc();
            return __ret;
        }
        std::basic_streambuf::int_type sbumpc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true)) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            } else
                __ret = this->uflow();
            return __ret;
        }
        std::basic_streambuf::int_type sgetc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true))
                __ret = traits_type::to_int_type(*this->gptr());
            else
                __ret = this->underflow();
            return __ret;
        }
        std::streamsize sgetn(std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->xsgetn(__s, __n);
        }
        std::basic_streambuf::int_type sputbackc(std::basic_streambuf::char_type __c)         {
            std::basic_streambuf::int_type __ret;
            const bool __testpos = this->eback() < this->gptr();
            if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
                __ret = this->pbackfail(traits_type::to_int_type(__c));
            else {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            }
            return __ret;
        }
        std::basic_streambuf::int_type sungetc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->eback() < this->gptr(), true)) {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            } else
                __ret = this->pbackfail();
            return __ret;
        }
        std::basic_streambuf::int_type sputc(std::basic_streambuf::char_type __c)         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->pptr() < this->epptr(), true)) {
                *this->pptr() = __c;
                this->pbump(1);
                __ret = traits_type::to_int_type(__c);
            } else
                __ret = this->overflow(traits_type::to_int_type(__c));
            return __ret;
        }
        std::streamsize sputn(const std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->xsputn(__s, __n);
        }
    protected:
        basic_streambuf<_CharT, _Traits>() : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(std::locale())         {
        }
        std::basic_streambuf::char_type *eback() const         {
            return this->_M_in_beg;
        }
        std::basic_streambuf::char_type *gptr() const         {
            return this->_M_in_cur;
        }
        std::basic_streambuf::char_type *egptr() const         {
            return this->_M_in_end;
        }
        void gbump(int __n)         {
            this->_M_in_cur += __n;
        }
        void setg(std::basic_streambuf::char_type *__gbeg, std::basic_streambuf::char_type *__gnext, std::basic_streambuf::char_type *__gend)         {
            this->_M_in_beg = __gbeg;
            this->_M_in_cur = __gnext;
            this->_M_in_end = __gend;
        }
        std::basic_streambuf::char_type *pbase() const         {
            return this->_M_out_beg;
        }
        std::basic_streambuf::char_type *pptr() const         {
            return this->_M_out_cur;
        }
        std::basic_streambuf::char_type *epptr() const         {
            return this->_M_out_end;
        }
        void pbump(int __n)         {
            this->_M_out_cur += __n;
        }
        void setp(std::basic_streambuf::char_type *__pbeg, std::basic_streambuf::char_type *__pend)         {
            this->_M_out_beg = this->_M_out_cur = __pbeg;
            this->_M_out_end = __pend;
        }
        virtual void imbue(const std::locale &__loc __attribute__((unused)))         {
        }
        virtual basic_streambuf<std::basic_streambuf::char_type, _Traits> *setbuf(std::basic_streambuf::char_type *, std::streamsize)         {
            return this;
        }
        virtual std::basic_streambuf::pos_type seekoff(std::basic_streambuf::off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual std::basic_streambuf::pos_type seekpos(std::basic_streambuf::pos_type, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual int sync()         {
            return 0;
        }
        virtual std::streamsize showmanyc()         {
            return 0;
        }
        virtual std::streamsize xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type underflow()         {
            return traits_type::eof();
        }
        virtual std::basic_streambuf::int_type uflow()         {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
            if (!__testeof) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            }
            return __ret;
        }
        virtual std::basic_streambuf::int_type pbackfail(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused)))         {
            return traits_type::eof();
        }
        virtual std::streamsize xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type overflow(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused)))         {
            return traits_type::eof();
        }
        void __safe_gbump(std::streamsize __n)         {
            this->_M_in_cur += __n;
        }
        void __safe_pbump(std::streamsize __n)         {
            this->_M_out_cur += __n;
        }
    protected:
        basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &);
        basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &);
        void swap(basic_streambuf<_CharT, _Traits> &__sb)         {
            std::swap(this->_M_in_beg, __sb._M_in_beg);
            std::swap(this->_M_in_cur, __sb._M_in_cur);
            std::swap(this->_M_in_end, __sb._M_in_end);
            std::swap(this->_M_out_beg, __sb._M_out_beg);
            std::swap(this->_M_out_cur, __sb._M_out_cur);
            std::swap(this->_M_out_end, __sb._M_out_end);
            std::swap(this->_M_buf_locale, __sb._M_buf_locale);
        }
    };
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits>::basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &) = default
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits> &std::basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf<_CharT, _Traits> &) = default
    template<> std::streamsize __copy_streambufs_eof<char, std::char_traits<char>>(basic_streambuf<char> *__sbin, basic_streambuf<char> *__sbout, bool &__ineof);
    template<> std::streamsize __copy_streambufs_eof<wchar_t, std::char_traits<wchar_t>>(basic_streambuf<wchar_t> *__sbin, basic_streambuf<wchar_t> *__sbout, bool &__ineof);
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n)     {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->egptr() - this->gptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(__s, this->gptr(), __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_gbump(__len);
                }
                if (__ret < __n) {
                    const std::basic_streambuf::int_type __c = this->uflow();
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        traits_type::assign(*__s++, traits_type::to_char_type(__c));
                        ++__ret;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n)     {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->epptr() - this->pptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(this->pptr(), __s, __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_pbump(__len);
                }
                if (__ret < __n) {
                    std::basic_streambuf::int_type __c = this->overflow(traits_type::to_int_type(*__s));
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        ++__ret;
                        ++__s;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)     {
        std::streamsize __ret = 0;
        __ineof = true;
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
            {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof())) {
                    __ineof = false;
                    break;
                }
                ++__ret;
                __c = __sbin->snextc();
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> inline std::streamsize __copy_streambufs(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout)     {
        bool __ineof;
        return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
    template<> class basic_streambuf<char> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<char, std::char_traits<char>>::char_type, std::basic_streambuf<char, std::char_traits<char>>::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_in_beg;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_in_cur;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_in_end;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_out_beg;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_out_cur;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<char>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<char> *pubsetbuf(std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char, std::char_traits<char>>::pos_type pubseekoff(std::basic_streambuf<char, std::char_traits<char>>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<char, std::char_traits<char>>::pos_type pubseekpos(std::basic_streambuf<char, std::char_traits<char>>::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<char, std::char_traits<char>>::int_type snextc();
        std::basic_streambuf<char, std::char_traits<char>>::int_type sbumpc();
        std::basic_streambuf<char, std::char_traits<char>>::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char, std::char_traits<char>>::int_type sputbackc(std::basic_streambuf<char, std::char_traits<char>>::char_type __c);
        std::basic_streambuf<char, std::char_traits<char>>::int_type sungetc();
        std::basic_streambuf<char, std::char_traits<char>>::int_type sputc(std::basic_streambuf<char, std::char_traits<char>>::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf();
        std::basic_streambuf<char, std::char_traits<char>>::char_type *eback() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *gptr() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *egptr() const;
        void gbump(int __n);
        void setg(std::basic_streambuf<char, std::char_traits<char>>::char_type *__gbeg, std::basic_streambuf<char, std::char_traits<char>>::char_type *__gnext, std::basic_streambuf<char, std::char_traits<char>>::char_type *__gend);
        std::basic_streambuf<char, std::char_traits<char>>::char_type *pbase() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *pptr() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<char, std::char_traits<char>>::char_type *__pbeg, std::basic_streambuf<char, std::char_traits<char>>::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<char, std::char_traits<char>>::char_type, std::char_traits<char>> *setbuf(std::basic_streambuf<char, std::char_traits<char>>::char_type *, std::streamsize);
        virtual std::basic_streambuf<char, std::char_traits<char>>::pos_type seekoff(std::basic_streambuf<char, std::char_traits<char>>::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<char, std::char_traits<char>>::pos_type seekpos(std::basic_streambuf<char, std::char_traits<char>>::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type underflow();
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type uflow();
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type pbackfail(std::basic_streambuf<char, std::char_traits<char>>::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type overflow(std::basic_streambuf<char, std::char_traits<char>>::int_type __c __attribute__((unused)));
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<char> &);
        std::basic_streambuf<char> &operator=(const std::basic_streambuf<char> &);
        void swap(std::basic_streambuf<char> &__sb);
    };
    template<> class basic_streambuf<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_in_beg;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_in_cur;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_in_end;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_out_beg;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_out_cur;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<wchar_t>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<wchar_t> *pubsetbuf(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type pubseekoff(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type pubseekpos(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type snextc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sbumpc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sputbackc(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sungetc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sputc(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *eback() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *gptr() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *egptr() const;
        void gbump(int __n);
        void setg(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__gbeg, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__gnext, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__gend);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *pbase() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *pptr() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__pbeg, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type, std::char_traits<wchar_t>> *setbuf(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *, std::streamsize);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type seekoff(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type seekpos(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type underflow();
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type uflow();
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type pbackfail(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type overflow(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type __c __attribute__((unused)));
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<wchar_t> &);
        std::basic_streambuf<wchar_t> &operator=(const std::basic_streambuf<wchar_t> &);
        void swap(std::basic_streambuf<wchar_t> &__sb);
    };
}
typedef unsigned long wctype_t;
enum  {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = ((__ISwupper) < 8 ? (int)((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int)((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int)((1UL << (__ISwupper)) >> 8) : (int)((1UL << (__ISwupper)) >> 24)))),
    _ISwlower = ((__ISwlower) < 8 ? (int)((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int)((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int)((1UL << (__ISwlower)) >> 8) : (int)((1UL << (__ISwlower)) >> 24)))),
    _ISwalpha = ((__ISwalpha) < 8 ? (int)((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int)((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int)((1UL << (__ISwalpha)) >> 8) : (int)((1UL << (__ISwalpha)) >> 24)))),
    _ISwdigit = ((__ISwdigit) < 8 ? (int)((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int)((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int)((1UL << (__ISwdigit)) >> 8) : (int)((1UL << (__ISwdigit)) >> 24)))),
    _ISwxdigit = ((__ISwxdigit) < 8 ? (int)((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int)((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int)((1UL << (__ISwxdigit)) >> 8) : (int)((1UL << (__ISwxdigit)) >> 24)))),
    _ISwspace = ((__ISwspace) < 8 ? (int)((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int)((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int)((1UL << (__ISwspace)) >> 8) : (int)((1UL << (__ISwspace)) >> 24)))),
    _ISwprint = ((__ISwprint) < 8 ? (int)((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int)((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int)((1UL << (__ISwprint)) >> 8) : (int)((1UL << (__ISwprint)) >> 24)))),
    _ISwgraph = ((__ISwgraph) < 8 ? (int)((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int)((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int)((1UL << (__ISwgraph)) >> 8) : (int)((1UL << (__ISwgraph)) >> 24)))),
    _ISwblank = ((__ISwblank) < 8 ? (int)((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int)((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int)((1UL << (__ISwblank)) >> 8) : (int)((1UL << (__ISwblank)) >> 24)))),
    _ISwcntrl = ((__ISwcntrl) < 8 ? (int)((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int)((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int)((1UL << (__ISwcntrl)) >> 8) : (int)((1UL << (__ISwcntrl)) >> 24)))),
    _ISwpunct = ((__ISwpunct) < 8 ? (int)((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int)((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int)((1UL << (__ISwpunct)) >> 8) : (int)((1UL << (__ISwpunct)) >> 24)))),
    _ISwalnum = ((__ISwalnum) < 8 ? (int)((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int)((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int)((1UL << (__ISwalnum)) >> 8) : (int)((1UL << (__ISwalnum)) >> 24))))
};
extern "C" {
    extern int iswalnum(wint_t __wc) throw();
    extern int iswalpha(wint_t __wc) throw();
    extern int iswcntrl(wint_t __wc) throw();
    extern int iswdigit(wint_t __wc) throw();
    extern int iswgraph(wint_t __wc) throw();
    extern int iswlower(wint_t __wc) throw();
    extern int iswprint(wint_t __wc) throw();
    extern int iswpunct(wint_t __wc) throw();
    extern int iswspace(wint_t __wc) throw();
    extern int iswupper(wint_t __wc) throw();
    extern int iswxdigit(wint_t __wc) throw();
    extern int iswblank(wint_t __wc) throw();
    extern wctype_t wctype(const char *__property) throw();
    extern int iswctype(wint_t __wc, wctype_t __desc) throw();
    extern wint_t towlower(wint_t __wc) throw();
    extern wint_t towupper(wint_t __wc) throw();
}
extern "C" {
    typedef const __int32_t *wctrans_t;
    extern wctrans_t wctrans(const char *__property) throw();
    extern wint_t towctrans(wint_t __wc, wctrans_t __desc) throw();
    extern int iswalnum_l(wint_t __wc, locale_t __locale) throw();
    extern int iswalpha_l(wint_t __wc, locale_t __locale) throw();
    extern int iswcntrl_l(wint_t __wc, locale_t __locale) throw();
    extern int iswdigit_l(wint_t __wc, locale_t __locale) throw();
    extern int iswgraph_l(wint_t __wc, locale_t __locale) throw();
    extern int iswlower_l(wint_t __wc, locale_t __locale) throw();
    extern int iswprint_l(wint_t __wc, locale_t __locale) throw();
    extern int iswpunct_l(wint_t __wc, locale_t __locale) throw();
    extern int iswspace_l(wint_t __wc, locale_t __locale) throw();
    extern int iswupper_l(wint_t __wc, locale_t __locale) throw();
    extern int iswxdigit_l(wint_t __wc, locale_t __locale) throw();
    extern int iswblank_l(wint_t __wc, locale_t __locale) throw();
    extern wctype_t wctype_l(const char *__property, locale_t __locale) throw();
    extern int iswctype_l(wint_t __wc, wctype_t __desc, locale_t __locale) throw();
    extern wint_t towlower_l(wint_t __wc, locale_t __locale) throw();
    extern wint_t towupper_l(wint_t __wc, locale_t __locale) throw();
    extern wctrans_t wctrans_l(const char *__property, locale_t __locale) throw();
    extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, locale_t __locale) throw();
}
namespace std {
    using ::wctrans_t;
    using ::wctype_t;
    using ::wint_t;
    using ::iswalnum;
    using ::iswalpha;
    using ::iswblank;
    using ::iswcntrl;
    using ::iswctype;
    using ::iswdigit;
    using ::iswgraph;
    using ::iswlower;
    using ::iswprint;
    using ::iswpunct;
    using ::iswspace;
    using ::iswupper;
    using ::iswxdigit;
    using ::towctrans;
    using ::towlower;
    using ::towupper;
    using ::wctrans;
    using ::wctype;
}
namespace std {
    struct ctype_base {
        typedef const int *__to_type;
        typedef unsigned short mask;
        static const std::ctype_base::mask upper = _ISupper;
        static const std::ctype_base::mask lower = _ISlower;
        static const std::ctype_base::mask alpha = _ISalpha;
        static const std::ctype_base::mask digit = _ISdigit;
        static const std::ctype_base::mask xdigit = _ISxdigit;
        static const std::ctype_base::mask space = _ISspace;
        static const std::ctype_base::mask print = _ISprint;
        static const std::ctype_base::mask graph = _ISalpha | _ISdigit | _ISpunct;
        static const std::ctype_base::mask cntrl = _IScntrl;
        static const std::ctype_base::mask punct = _ISpunct;
        static const std::ctype_base::mask alnum = _ISalpha | _ISdigit;
        static const std::ctype_base::mask blank = _ISblank;
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator : public iterator<std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename _Traits::int_type int_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_istream<_CharT, _Traits> istream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2, typename _Size> __enable_if_t<__is_char<_CharT2>::__value, _CharT2 *> __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
    private:
        mutable std::istreambuf_iterator::streambuf_type *_M_sbuf;
        std::istreambuf_iterator::int_type _M_c;
    public:
        constexpr istreambuf_iterator<_CharT, _Traits>() noexcept : _M_sbuf(0), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits>(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        ~istreambuf_iterator<_CharT, _Traits>() = default
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::istream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits> &operator=(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        std::istreambuf_iterator::char_type operator*() const         {
            std::istreambuf_iterator::int_type __c = this->_M_get();
            return traits_type::to_char_type(__c);
        }
        istreambuf_iterator<_CharT, _Traits> &operator++()         {
            ;
            this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return *this;
        }
        istreambuf_iterator<_CharT, _Traits> operator++(int)         {
            ;
            istreambuf_iterator<_CharT, _Traits> __old = *this;
            __old._M_c = this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return __old;
        }
        bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const         {
            return this->_M_at_eof() == __b._M_at_eof();
        }
    private:
        std::istreambuf_iterator::int_type _M_get() const         {
            std::istreambuf_iterator::int_type __ret = this->_M_c;
            if (this->_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = this->_M_sbuf->sgetc()))
                this->_M_sbuf = 0;
            return __ret;
        }
        bool _M_at_eof() const         {
            return _S_is_eof(this->_M_get());
        }
        static bool _S_is_eof(std::istreambuf_iterator::int_type __c)         {
            const std::istreambuf_iterator::int_type __eof = traits_type::eof();
            return traits_type::eq_int_type(__c, __eof);
        }
    };
    template <typename _CharT, typename _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b)     {
        return __a.equal(__b);
    }
    template <typename _CharT, typename _Traits> inline bool operator!=(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b)     {
        return !__a.equal(__b);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
    private:
        std::ostreambuf_iterator::streambuf_type *_M_sbuf;
        bool _M_failed;
    public:
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::ostream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_failed(!this->_M_sbuf)         {
        }
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_failed(!this->_M_sbuf)         {
        }
        ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c)         {
            if (!this->_M_failed && _Traits::eq_int_type(this->_M_sbuf->sputc(__c), _Traits::eof()))
                this->_M_failed = true;
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator*()         {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++(int)         {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++()         {
            return *this;
        }
        bool failed() const noexcept         {
            return this->_M_failed;
        }
        ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, std::streamsize __len)         {
            if (__builtin_expect(!this->_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
                this->_M_failed = true;
            return *this;
        }
    };
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type copy(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, ostreambuf_iterator<_CharT> __result)     {
        if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed) {
            bool __ineof;
            __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
            if (!__ineof)
                __result._M_failed = true;
        }
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, _CharT *__result)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf) {
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    const std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        traits_type::copy(__result, __sb->gptr(), __n);
                        __sb->__safe_gbump(__n);
                        __result += __n;
                        __c = __sb->underflow();
                    } else {
                        *__result++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                    }
                }
        }
        return __result;
    }
    template <typename _CharT, typename _Size> __enable_if_t<__is_char<_CharT>::__value, _CharT *> __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT *__result)     {
        if (__n == 0)
            return __result;
        ;
        _CharT *__beg = __result;
        __result += __it._M_sbuf->sgetn(__beg, __n);
        ;
        return __result;
    }
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, istreambuf_iterator<_CharT>>::__type find(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, const _CharT &__val)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        if (__first._M_sbuf && !__last._M_sbuf) {
            const int_type __ival = traits_type::to_int_type(__val);
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __ival))
                {
                    std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                        if (__p)
                            __n = __p - __sb->gptr();
                        __sb->__safe_gbump(__n);
                        __c = __sb->sgetc();
                    } else
                        __c = __sb->snextc();
                }
            __first._M_c = __eof;
        }
        return __first;
    }
    template <typename _CharT, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, void>::__type advance(istreambuf_iterator<_CharT> &__i, _Distance __n)     {
        if (__n == 0)
            return;
        ;
        ;
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        streambuf_type *__sb = __i._M_sbuf;
        while (__n > 0)
            {
                std::streamsize __size = __sb->egptr() - __sb->gptr();
                if (__size > __n) {
                    __sb->__safe_gbump(__n);
                    break;
                }
                __sb->__safe_gbump(__size);
                __n -= __size;
                if (traits_type::eq_int_type(__sb->underflow(), __eof)) {
                    ;
                    break;
                }
            }
        __i._M_c = __eof;
    }
}
namespace std {
    template <typename _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<float>(const char *, float &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<double>(const char *, double &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<long double>(const char *, long double &, ios_base::iostate &, const std::__c_locale &) throw();
    template <typename _CharT, typename _Traits> struct __pad {
        static void _S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen);
    };
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last);
    template <typename _CharT> inline ostreambuf_iterator<_CharT> __write(ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)     {
        __s._M_put(__ws, __len);
        return __s;
    }
    template <typename _CharT, typename _OutIter> inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)     {
        for (int __j = 0; __j < __len; __j++ , ++__s)
            *__s = __ws[__j];
        return __s;
    }
    template <typename _CharT> class __ctype_abstract_base : public locale::facet, public std::ctype_base {
    public:
        typedef _CharT char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const         {
            return this->do_is(__m, __c);
        }
        const std::__ctype_abstract_base::char_type *is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const         {
            return this->do_is(__lo, __hi, __vec);
        }
        const std::__ctype_abstract_base::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_scan_is(__m, __lo, __hi);
        }
        const std::__ctype_abstract_base::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_scan_not(__m, __lo, __hi);
        }
        std::__ctype_abstract_base::char_type toupper(std::__ctype_abstract_base::char_type __c) const         {
            return this->do_toupper(__c);
        }
        const std::__ctype_abstract_base::char_type *toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type tolower(std::__ctype_abstract_base::char_type __c) const         {
            return this->do_tolower(__c);
        }
        const std::__ctype_abstract_base::char_type *tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type widen(char __c) const         {
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const         {
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const         {
            return this->do_narrow(__c, __dfault);
        }
        const std::__ctype_abstract_base::char_type *narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const         {
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
    protected:
        explicit __ctype_abstract_base<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        virtual ~__ctype_abstract_base<_CharT>()         {
        }
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_toupper(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_tolower(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const = 0;
    };
template<> class __ctype_abstract_base<wchar_t> : public locale::facet, public std::ctype_base {
    public:
        typedef wchar_t char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type widen(char __c) const;
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const;
        char narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
    protected:
        explicit __ctype_abstract_base(std::size_t __refs);
        virtual ~__ctype_abstract_base<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template <typename _CharT> class ctype : public __ctype_abstract_base<_CharT> {
    public:
        typedef _CharT char_type;
        typedef typename __ctype_abstract_base<_CharT>::mask mask;
        static locale::id id;
        explicit ctype<_CharT>(std::size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs)         {
        }
    protected:
        virtual ~ctype<_CharT>();
        virtual bool do_is(std::ctype::mask __m, std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_is(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, std::ctype::mask *__vec) const;
        virtual const std::ctype::char_type *do_scan_is(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual const std::ctype::char_type *do_scan_not(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_toupper(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_toupper(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_tolower(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_tolower(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype::char_type *__dest) const;
        virtual char do_narrow(std::ctype::char_type, char __dfault) const;
        virtual const std::ctype::char_type *do_narrow(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, char __dfault, char *__to) const;
    };
    locale::id id;
    template<> class ctype<char> : public locale::facet, public std::ctype_base {
    public:
        typedef char char_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_del;
        std::ctype_base::__to_type _M_toupper;
        std::ctype_base::__to_type _M_tolower;
        const std::ctype_base::mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const std::size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        inline bool is(std::ctype_base::mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, std::ctype_base::mask *__vec) const;
        inline const char *scan_is(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        std::ctype<char>::char_type toupper(std::ctype<char>::char_type __c) const         {
            return this->do_toupper(__c);
        }
        const std::ctype<char>::char_type *toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }
        std::ctype<char>::char_type tolower(std::ctype<char>::char_type __c) const         {
            return this->do_tolower(__c);
        }
        const std::ctype<char>::char_type *tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }
        std::ctype<char>::char_type widen(char __c) const         {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const         {
            if (this->_M_widen_ok == 1) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::ctype<char>::char_type __c, char __dfault) const         {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }
        const std::ctype<char>::char_type *narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault, char *__to) const         {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
        const std::ctype_base::mask *table() const throw()         {
            return this->_M_table;
        }
        static const std::ctype_base::mask *classic_table() throw();
    protected:
        virtual ~ctype<char>() noexcept;
        virtual std::ctype<char>::char_type do_toupper(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_tolower(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_widen(char __c) const         {
            return __c;
        }
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const         {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
        virtual char do_narrow(std::ctype<char>::char_type __c, char __dfault __attribute__((unused))) const         {
            return __c;
        }
        virtual const std::ctype<char>::char_type *do_narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault __attribute__((unused)), char *__to) const         {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    };
    template<> class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        std::ctype_base::mask _M_bit[16];
        std::ctype<wchar_t>::__wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, std::size_t __refs = 0);
    protected:
        std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const std::ctype_base::mask __m) const throw();
        virtual ~ctype<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_is(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_toupper(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_toupper(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_tolower(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_tolower(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<wchar_t>::char_type *__to) const;
        virtual char do_narrow(std::ctype<wchar_t>::char_type __c, char __dfault) const;
        virtual const std::ctype<wchar_t>::char_type *do_narrow(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    };
    template <typename _CharT> class ctype_byname : public ctype<_CharT> {
    public:
        typedef typename ctype<_CharT>::mask mask;
        explicit ctype_byname<_CharT>(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : ctype_byname<_CharT>(__s.c_str(), __refs)         {
        }
    protected:
        virtual ~ctype_byname<_CharT>()         {
        }
    };
    template<> class ctype_byname<char> : public ctype<char> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<char>() noexcept;
    };
    template<> class ctype_byname<wchar_t> : public ctype<wchar_t> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<wchar_t>() noexcept;
    };
}
namespace std {
    bool ctype<char>::is(std::ctype_base::mask __m, char __c) const     {
        return this->_M_table[static_cast<unsigned char>(__c)] & __m;
    }
    const char *ctype<char>::is(const char *__low, const char *__high, std::ctype_base::mask *__vec) const     {
        while (__low < __high)
            *__vec++ = this->_M_table[static_cast<unsigned char>(*__low++)];
        return __high;
    }
    const char *ctype<char>::scan_is(std::ctype_base::mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && !(this->_M_table[static_cast<unsigned char>(*__low)] & __m))
            ++__low;
        return __low;
    }
    const char *ctype<char>::scan_not(std::ctype_base::mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && (this->_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
            ++__low;
        return __low;
    }
}
namespace std {
    class __num_base {
    public:
        enum  {
            _S_ominus,
            _S_oplus,
            _S_ox,
            _S_oX,
            _S_odigits,
            _S_odigits_end = _S_odigits + 16,
            _S_oudigits = _S_odigits_end,
            _S_oudigits_end = _S_oudigits + 16,
            _S_oe = _S_odigits + 14,
            _S_oE = _S_oudigits + 14,
            _S_oend = _S_oudigits_end
        };
        static const char *_S_atoms_out;
        static const char *_S_atoms_in;
        enum  {
            _S_iminus,
            _S_iplus,
            _S_ix,
            _S_iX,
            _S_izero,
            _S_ie = _S_izero + 14,
            _S_iE = _S_izero + 20,
            _S_iend = 26
        };
        static void _S_format_float(const std::ios_base &__io, char *__fptr, char __mod) throw();
    };
    template <typename _CharT> struct __numpunct_cache : public locale::facet {
        const char *_M_grouping;
        std::size_t _M_grouping_size;
        bool _M_use_grouping;
        const _CharT *_M_truename;
        std::size_t _M_truename_size;
        const _CharT *_M_falsename;
        std::size_t _M_falsename_size;
        _CharT _M_decimal_point;
        _CharT _M_thousands_sep;
        _CharT _M_atoms_out[36];
        _CharT _M_atoms_in[26];
        bool _M_allocated;
        __numpunct_cache<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)         {
        }
        ~__numpunct_cache<_CharT>();
        void _M_cache(const std::locale &__loc);
    private:
        __numpunct_cache<_CharT> &operator=(const __numpunct_cache<_CharT> &);
        explicit __numpunct_cache<_CharT>(const __numpunct_cache<_CharT> &);
    };
    template <typename _CharT> __numpunct_cache<_CharT>::~__numpunct_cache<_CharT>()     {
        if (this->_M_allocated) {
            delete [] this->_M_grouping;
            delete [] this->_M_truename;
            delete [] this->_M_falsename;
        }
    }
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            typedef __numpunct_cache<_CharT> __cache_type;
        protected:
            std::__cxx11::numpunct::__cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::__cxx11::numpunct::__cache_type *__cache, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(__cache)             {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct(__cloc);
            }
            std::__cxx11::numpunct::char_type decimal_point() const             {
                return this->do_decimal_point();
            }
            std::__cxx11::numpunct::char_type thousands_sep() const             {
                return this->do_thousands_sep();
            }
            std::string grouping() const             {
                return this->do_grouping();
            }
            std::__cxx11::numpunct::string_type truename() const             {
                return this->do_truename();
            }
            std::__cxx11::numpunct::string_type falsename() const             {
                return this->do_falsename();
            }
        protected:
            virtual ~numpunct<_CharT>();
            virtual std::__cxx11::numpunct::char_type do_decimal_point() const             {
                return this->_M_data->_M_decimal_point;
            }
            virtual std::__cxx11::numpunct::char_type do_thousands_sep() const             {
                return this->_M_data->_M_thousands_sep;
            }
            virtual std::string do_grouping() const             {
                return this->_M_data->_M_grouping;
            }
            virtual std::__cxx11::numpunct::string_type do_truename() const             {
                return this->_M_data->_M_truename;
            }
            virtual std::__cxx11::numpunct::string_type do_falsename() const             {
                return this->_M_data->_M_falsename;
            }
            void _M_initialize_numpunct(std::__c_locale __cloc = 0);
        };
        locale::id id;
        template <> numpunct<char>::~numpunct<char>() noexcept;
        template <> void numpunct<char>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <> numpunct<wchar_t>::~numpunct<wchar_t>() noexcept;
        template <> void numpunct<wchar_t>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <typename _CharT> class numpunct_byname : public numpunct<_CharT> {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit numpunct_byname<_CharT>(const char *__s, std::size_t __refs = 0) : numpunct<_CharT>(__refs)             {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                    std::__c_locale __tmp;
                    this->_S_create_c_locale(__tmp, __s);
                    this->_M_initialize_numpunct(__tmp);
                    this->_S_destroy_c_locale(__tmp);
                }
            }
            explicit numpunct_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : numpunct_byname<_CharT>(__s.c_str(), __refs)             {
            }
        protected:
            virtual ~numpunct_byname<_CharT>()             {
            }
        };
    }
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _InIter iter_type;
        static locale::id id;
        explicit num_get<_CharT, _InIter>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
    protected:
        virtual ~num_get<_CharT, _InIter>()         {
        }
        std::num_get::iter_type _M_extract_float(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get::iter_type _M_extract_int(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            if (__len <= 10) {
                if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
                    __ret = __c - _CharT2('0');
            } else {
                if (__c >= _CharT2('0') && __c <= _CharT2('9'))
                    __ret = __c - _CharT2('0');
                else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                    __ret = 10 + (__c - _CharT2('a'));
                else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                    __ret = 10 + (__c - _CharT2('A'));
            }
            return __ret;
        }
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            const std::num_get::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
            if (__q) {
                __ret = __q - __zero;
                if (__ret > 15)
                    __ret -= 6;
            }
            return __ret;
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    locale::id id;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _OutIter iter_type;
        static locale::id id;
        explicit num_put<_CharT, _OutIter>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
    protected:
        template <typename _ValueT> std::num_put::iter_type _M_insert_float(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, const std::num_put::char_type *__p, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put::iter_type _M_insert_int(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, std::ios_base &__io, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put::char_type *__new, const std::num_put::char_type *__cs, int &__len) const;
        virtual ~num_put<_CharT, _OutIter>()         {
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, long double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, const void *) const;
    };
    locale::id id;
    template <typename _CharT> inline bool isspace(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space, __c);
    }
    template <typename _CharT> inline bool isprint(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print, __c);
    }
    template <typename _CharT> inline bool iscntrl(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl, __c);
    }
    template <typename _CharT> inline bool isupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper, __c);
    }
    template <typename _CharT> inline bool islower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower, __c);
    }
    template <typename _CharT> inline bool isalpha(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha, __c);
    }
    template <typename _CharT> inline bool isdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit, __c);
    }
    template <typename _CharT> inline bool ispunct(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct, __c);
    }
    template <typename _CharT> inline bool isxdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit, __c);
    }
    template <typename _CharT> inline bool isalnum(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum, __c);
    }
    template <typename _CharT> inline bool isgraph(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph, __c);
    }
    template <typename _CharT> inline bool isblank(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::blank, __c);
    }
    template <typename _CharT> inline _CharT toupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).toupper(__c);
    }
    template <typename _CharT> inline _CharT tolower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).tolower(__c);
    }
}
namespace std {
    template <typename _Facet> struct __use_cache {
        const _Facet *operator()(const std::locale &__loc) const;
    };
    template <typename _CharT> struct __use_cache<__numpunct_cache<_CharT>> {
        const __numpunct_cache<_CharT> *operator()(const std::locale &__loc) const         {
            const std::size_t __i = numpunct<_CharT>::id._M_id();
            const locale::facet **__caches = __loc._M_impl->_M_caches;
            if (!__caches[__i]) {
                __numpunct_cache<_CharT> *__tmp = 0;
                try {
                    __tmp = new __numpunct_cache<_CharT>;
                    __tmp->_M_cache(__loc);
                } catch (...) {
                    delete __tmp;
                    throw;
                }
                __loc._M_impl->_M_install_cache(__tmp, __i);
            }
            return static_cast<const __numpunct_cache<_CharT> *>(__caches[__i]);
        }
    };
    template <typename _CharT> void __numpunct_cache<_CharT>::_M_cache(const std::locale &__loc)     {
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
        char *__grouping = 0;
        _CharT *__truename = 0;
        _CharT *__falsename = 0;
        try {
            const std::string &__g = __np.grouping();
            this->_M_grouping_size = __g.size();
            __grouping = new char [this->_M_grouping_size];
            __g.copy(__grouping, this->_M_grouping_size);
            this->_M_use_grouping = (this->_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0 && (__grouping[0] != __gnu_cxx::__numeric_traits<char>::__max));
            const basic_string<_CharT> &__tn = __np.truename();
            this->_M_truename_size = __tn.size();
            __truename = new _CharT [this->_M_truename_size];
            __tn.copy(__truename, this->_M_truename_size);
            const basic_string<_CharT> &__fn = __np.falsename();
            this->_M_falsename_size = __fn.size();
            __falsename = new _CharT [this->_M_falsename_size];
            __fn.copy(__falsename, this->_M_falsename_size);
            this->_M_decimal_point = __np.decimal_point();
            this->_M_thousands_sep = __np.thousands_sep();
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
            __ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, this->_M_atoms_out);
            __ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, this->_M_atoms_in);
            this->_M_grouping = __grouping;
            this->_M_truename = __truename;
            this->_M_falsename = __falsename;
            this->_M_allocated = true;
        } catch (...) {
            delete [] __grouping;
            delete [] __truename;
            delete [] __falsename;
            throw;
        }
    }
    bool __verify_grouping(const char *__grouping, std::size_t __grouping_size, const std::string &__grouping_tmp) throw() __attribute__((pure));
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, std::string &__xtrc) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        bool __testeof = __beg == __end;
        if (!__testeof) {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                __xtrc += __plus ? '+' : '-';
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_mantissa = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero]) {
                    if (!__found_mantissa) {
                        __xtrc += '0';
                        __found_mantissa = true;
                    }
                    ++__sep_pos;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                } else
                    break;
            }
        bool __found_dec = false;
        bool __found_sci = false;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    const int __digit = _M_find(__lit_zero, 10, __c);
                    if (__digit != -1) {
                        __xtrc += '0' + __digit;
                        __found_mantissa = true;
                    } else if (__c == __lc->_M_decimal_point && !__found_dec && !__found_sci) {
                        __xtrc += '.';
                        __found_dec = true;
                    } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                        __xtrc += 'e';
                        __found_sci = true;
                        if (++__beg != __end) {
                            __c = *__beg;
                            const bool __plus = __c == __lit[__num_base::_S_iplus];
                            if (__plus || __c == __lit[__num_base::_S_iminus])
                                __xtrc += __plus ? '+' : '-';
                            else
                                continue;
                        } else {
                            __testeof = true;
                            break;
                        }
                    } else
                        break;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (!__found_dec && !__found_sci) {
                            if (__sep_pos) {
                                __found_grouping += static_cast<char>(__sep_pos);
                                __sep_pos = 0;
                            } else {
                                __xtrc.clear();
                                break;
                            }
                        } else
                            break;
                    } else if (__c == __lc->_M_decimal_point) {
                        if (!__found_dec && !__found_sci) {
                            if (__found_grouping.size())
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += '.';
                            __found_dec = true;
                        } else
                            break;
                    } else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                        if (__q) {
                            __xtrc += '0' + (__q - __lit_zero);
                            __found_mantissa = true;
                            ++__sep_pos;
                        } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                            if (__found_grouping.size() && !__found_dec)
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end) {
                                __c = *__beg;
                                const bool __plus = __c == __lit[__num_base::_S_iplus];
                                if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
                                    __xtrc += __plus ? '+' : '-';
                                else
                                    continue;
                            } else {
                                __testeof = true;
                                break;
                            }
                        } else
                            break;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            if (!__found_dec && !__found_sci)
                __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> template <typename _ValueT> _InIter num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, _ValueT &__v) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
        const bool __oct = __basefield == ios_base::oct;
        int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
        bool __testeof = __beg == __end;
        bool __negative = false;
        if (!__testeof) {
            __c = *__beg;
            __negative = __c == __lit[__num_base::_S_iminus];
            if ((__negative || __c == __lit[__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_zero = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero] && (!__found_zero || __base == 10)) {
                    __found_zero = true;
                    ++__sep_pos;
                    if (__basefield == 0)
                        __base = 8;
                    if (__base == 8)
                        __sep_pos = 0;
                } else if (__found_zero && (__c == __lit[__num_base::_S_ix] || __c == __lit[__num_base::_S_iX])) {
                    if (__basefield == 0)
                        __base = 16;
                    if (__base == 16) {
                        __found_zero = false;
                        __sep_pos = 0;
                    } else
                        break;
                } else
                    break;
                if (++__beg != __end) {
                    __c = *__beg;
                    if (!__found_zero)
                        break;
                } else
                    __testeof = true;
            }
        const std::size_t __len = (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);
        typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        bool __testfail = false;
        bool __testoverflow = false;
        const __unsigned_type __max = (__negative && __num_traits::__is_signed) ? - static_cast<__unsigned_type>(__num_traits::__min) : __num_traits::__max;
        const __unsigned_type __smax = __max / __base;
        __unsigned_type __result = 0;
        int __digit = 0;
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    __digit = _M_find(__lit_zero, __len, __c);
                    if (__digit == -1)
                        break;
                    if (__result > __smax)
                        __testoverflow = true;
                    else {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                        ++__sep_pos;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (__sep_pos) {
                            __found_grouping += static_cast<char>(__sep_pos);
                            __sep_pos = 0;
                        } else {
                            __testfail = true;
                            break;
                        }
                    } else if (__c == __lc->_M_decimal_point)
                        break;
                    else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                        if (!__q)
                            break;
                        __digit = __q - __lit_zero;
                        if (__digit > 15)
                            __digit -= 6;
                        if (__result > __smax)
                            __testoverflow = true;
                        else {
                            __result *= __base;
                            __testoverflow |= __result > __max - __digit;
                            __result += __digit;
                            ++__sep_pos;
                        }
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        if ((!__sep_pos && !__found_zero && !__found_grouping.size()) || __testfail) {
            __v = 0;
            __err = ios_base::failbit;
        } else if (__testoverflow) {
            if (__negative && __num_traits::__is_signed)
                __v = __num_traits::__min;
            else
                __v = __num_traits::__max;
            __err = ios_base::failbit;
        } else
            __v = __negative ? - __result : __result;
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const     {
        if (!(__io.flags() & ios_base::boolalpha)) {
            long __l = -1;
            __beg = _M_extract_int(__beg, __end, __io, __err, __l);
            if (__l == 0 || __l == 1)
                __v = bool(__l);
            else {
                __v = true;
                __err = ios_base::failbit;
                if (__beg == __end)
                    __err |= ios_base::eofbit;
            }
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            bool __testf = true;
            bool __testt = true;
            bool __donef = __lc->_M_falsename_size == 0;
            bool __donet = __lc->_M_truename_size == 0;
            bool __testeof = false;
            std::size_t __n = 0;
            while (!__donef || !__donet)
                {
                    if (__beg == __end) {
                        __testeof = true;
                        break;
                    }
                    const std::num_get::char_type __c = *__beg;
                    if (!__donef)
                        __testf = __c == __lc->_M_falsename[__n];
                    if (!__testf && __donet)
                        break;
                    if (!__donet)
                        __testt = __c == __lc->_M_truename[__n];
                    if (!__testt && __donef)
                        break;
                    if (!__testt && !__testf)
                        break;
                    ++__n;
                    ++__beg;
                    __donef = !__testf || __n >= __lc->_M_falsename_size;
                    __donet = !__testt || __n >= __lc->_M_truename_size;
                }
            if (__testf && __n == __lc->_M_falsename_size && __n) {
                __v = false;
                if (__testt && __n == __lc->_M_truename_size)
                    __err = ios_base::failbit;
                else
                    __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else if (__testt && __n == __lc->_M_truename_size && __n) {
                __v = true;
                __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else {
                __v = false;
                __err = ios_base::failbit;
                if (__testeof)
                    __err |= ios_base::eofbit;
            }
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const     {
        typedef ios_base::fmtflags fmtflags;
        const fmtflags __fmt = __io.flags();
        __io.flags((__fmt & ~ ios_base::basefield) | ios_base::hex);
        typedef __gnu_cxx::__conditional_type<(sizeof(void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        _UIntPtrType __ul;
        __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
        __io.flags(__fmt);
        __v = reinterpret_cast<void *>(__ul);
        return __beg;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, std::streamsize __w, std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const     {
        __pad<_CharT, char_traits<_CharT>>::_S_pad(__io, __fill, __new, __cs, __w, __len);
        __len = static_cast<int>(__w);
    }
    template <typename _CharT, typename _ValueT> int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags __flags, bool __dec)     {
        _CharT *__buf = __bufend;
        if (__builtin_expect(__dec, true)) {
            do {
                *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
                __v /= 10;
            } while (__v != 0);
        } else if ((__flags & ios_base::basefield) == ios_base::oct) {
            do {
                *--__buf = __lit[(__v & 7) + __num_base::_S_odigits];
                __v >>= 3;
            } while (__v != 0);
        } else {
            const bool __uppercase = __flags & ios_base::uppercase;
            const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
            do {
                *--__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
            } while (__v != 0);
        }
        return __bufend - __buf;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, std::size_t __grouping_size, _CharT __sep, std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const     {
        _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
        __len = __p - __new;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, std::ios_base &__io, _CharT __fill, _ValueT __v) const     {
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_out;
        const ios_base::fmtflags __flags = __io.flags();
        const int __ilen = 5 * sizeof(_ValueT);
        _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
        const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
        const bool __dec = (__basefield != ios_base::oct && __basefield != ios_base::hex);
        const __unsigned_type __u = ((__v > 0 || !__dec) ? __unsigned_type(__v) : - __unsigned_type(__v));
        int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
        __cs += __ilen - __len;
        if (__lc->_M_use_grouping) {
            _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
            this->_M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
            __cs = __cs2 + 2;
        }
        if (__builtin_expect(__dec, true)) {
            if (__v >= 0) {
                if (bool(__flags & ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
                    *--__cs = __lit[__num_base::_S_oplus] , ++__len;
            } else
                *--__cs = __lit[__num_base::_S_ominus] , ++__len;
        } else if (bool(__flags & ios_base::showbase) && __v) {
            if (__basefield == ios_base::oct)
                *--__cs = __lit[__num_base::_S_odigits] , ++__len;
            else {
                const bool __uppercase = __flags & ios_base::uppercase;
                *--__cs = __lit[__num_base::_S_ox + __uppercase];
                *--__cs = __lit[__num_base::_S_odigits];
                __len += 2;
            }
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
        }
        __io.width(0);
        return std::__write(__s, __cs, __len);
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const     {
        const int __declen = __p ? __p - __cs : __len;
        _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
        int __newlen = __p2 - __new;
        if (__p) {
            char_traits<_CharT>::copy(__p2, __p, __len - __declen);
            __newlen += __len - __declen;
        }
        __len = __newlen;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const     {
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const std::streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
        const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
        int __len;
        char __fbuf[16];
        __num_base::_S_format_float(__io, __fbuf, __mod);
        const bool __use_prec = (__io.flags() & ios_base::floatfield) != ios_base::floatfield;
        int __cs_size = __max_digits * 3;
        char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        else
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        if (__len >= __cs_size) {
            __cs_size = __len + 1;
            __cs = static_cast<char *>(__builtin_alloca(__cs_size));
            if (__use_prec)
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
            else
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        }
        const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
        _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
        __ctype.widen(__cs, __cs + __len, __ws);
        _CharT *__wp = 0;
        const char *__p = char_traits<char>::find(__cs, __len, '.');
        if (__p) {
            __wp = __ws + (__p - __cs);
            *__wp = __lc->_M_decimal_point;
        }
        if (__lc->_M_use_grouping && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9' && __cs[1] >= '0' && __cs[2] >= '0'))) {
            _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
            std::streamsize __off = 0;
            if (__cs[0] == '-' || __cs[0] == '+') {
                __off = 1;
                __ws2[0] = __ws[0];
                __len -= 1;
            }
            this->_M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
            __len += __off;
            __ws = __ws2;
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __ws3, __ws, __len);
            __ws = __ws3;
        }
        __io.width(0);
        return std::__write(__s, __ws, __len);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        if ((__flags & ios_base::boolalpha) == 0) {
            const long __l = __v;
            __s = _M_insert_int(__s, __io, __fill, __l);
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
            int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
            const std::streamsize __w = __io.width();
            if (__w > static_cast<std::streamsize>(__len)) {
                const std::streamsize __plen = __w - __len;
                _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
                char_traits<_CharT>::assign(__ps, __plen, __fill);
                __io.width(0);
                if ((__flags & ios_base::adjustfield) == ios_base::left) {
                    __s = std::__write(__s, __name, __len);
                    __s = std::__write(__s, __ps, __plen);
                } else {
                    __s = std::__write(__s, __ps, __plen);
                    __s = std::__write(__s, __name, __len);
                }
                return __s;
            }
            __io.width(0);
            __s = std::__write(__s, __name, __len);
        }
        return __s;
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const     {
        return _M_insert_float(__s, __io, __fill, char(), __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const     {
        return _M_insert_float(__s, __io, __fill, 'L', __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        const ios_base::fmtflags __fmt = ~ (ios_base::basefield | ios_base::uppercase);
        __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
        typedef __gnu_cxx::__conditional_type<(sizeof(const void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
        __io.flags(__flags);
        return __s;
    }
    template <typename _CharT, typename _Traits> void __pad<_CharT, _Traits>::_S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen)     {
        const std::size_t __plen = static_cast<std::size_t>(__newlen - __oldlen);
        const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
        if (__adjust == ios_base::left) {
            _Traits::copy(__news, __olds, __oldlen);
            _Traits::assign(__news + __oldlen, __plen, __fill);
            return;
        }
        std::size_t __mod = 0;
        if (__adjust == ios_base::internal) {
            const std::locale &__loc = __io._M_getloc();
            const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
            if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0]) {
                __news[0] = __olds[0];
                __mod = 1;
                ++__news;
            } else if (__ctype.widen('0') == __olds[0] && __oldlen > 1 && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1])) {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
            }
        }
        _Traits::assign(__news, __plen, __fill);
        _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last)     {
        std::size_t __idx = 0;
        std::size_t __ctr = 0;
        while (__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0 && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
            {
                __last -= __gbeg[__idx];
                __idx < __gsize - 1 ? ++__idx : ++__ctr;
            }
        while (__first != __last)
            *__s++ = *__first++;
        while (__ctr--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        while (__idx--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        return __s;
    }
    template<> class numpunct<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        typedef __numpunct_cache<char> __cache_type;
    protected:
        std::__cxx11::numpunct<char>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::__cxx11::numpunct<char>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::__cxx11::numpunct<char>::char_type decimal_point() const;
        std::__cxx11::numpunct<char>::char_type thousands_sep() const;
        std::string grouping() const;
        std::__cxx11::numpunct<char>::string_type truename() const;
        std::__cxx11::numpunct<char>::string_type falsename() const;
    protected:
        virtual ~numpunct<char>() noexcept;
        virtual std::__cxx11::numpunct<char>::char_type do_decimal_point() const;
        virtual std::__cxx11::numpunct<char>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::__cxx11::numpunct<char>::string_type do_truename() const;
        virtual std::__cxx11::numpunct<char>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<char> : public numpunct<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<char>() noexcept;
    };
    template<> class num_get<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char, std::char_traits<char>> iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<char>() noexcept;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_extract_float(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_extract_int(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char, std::char_traits<char>> iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, bool __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, double __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long double __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_insert_float(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __sep, const std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__p, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__new, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_insert_int(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __sep, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__new, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__new, const std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__cs, int &__len) const;
        virtual ~num_put<char>() noexcept;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, bool __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type, double) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type, long double) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type, const void *) const;
    };
    template<> class ctype_byname<char>;
    template<> class numpunct<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        typedef __numpunct_cache<wchar_t> __cache_type;
    protected:
        std::__cxx11::numpunct<wchar_t>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::__cxx11::numpunct<wchar_t>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::__cxx11::numpunct<wchar_t>::char_type decimal_point() const;
        std::__cxx11::numpunct<wchar_t>::char_type thousands_sep() const;
        std::string grouping() const;
        std::__cxx11::numpunct<wchar_t>::string_type truename() const;
        std::__cxx11::numpunct<wchar_t>::string_type falsename() const;
    protected:
        virtual ~numpunct<wchar_t>() noexcept;
        virtual std::__cxx11::numpunct<wchar_t>::char_type do_decimal_point() const;
        virtual std::__cxx11::numpunct<wchar_t>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::__cxx11::numpunct<wchar_t>::string_type do_truename() const;
        virtual std::__cxx11::numpunct<wchar_t>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<wchar_t> : public numpunct<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<wchar_t>() noexcept;
    };
    template<> class num_get<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>> iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<wchar_t>() noexcept;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_extract_float(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_extract_int(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>> iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, bool __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, double __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long double __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_insert_float(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __sep, const std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__p, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__new, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_insert_int(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __sep, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__new, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__new, const std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__cs, int &__len) const;
        virtual ~num_put<wchar_t>() noexcept;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, bool __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type, double) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type, long double) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type, const void *) const;
    };
    template<> class ctype_byname<wchar_t>;
}
namespace std {
    template <typename _Facet> inline const _Facet &__check_facet(const _Facet *__f)     {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template<> inline const std::ctype<char> &__check_facet<std::ctype<char>>(const std::ctype<char> *__f)     {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios : public std::ios_base {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef ctype<_CharT> __ctype_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
    protected:
        basic_ostream<_CharT, _Traits> *_M_tie;
        mutable std::basic_ios::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<_CharT, _Traits> *_M_streambuf;
        const std::basic_ios::__ctype_type *_M_ctype;
        const std::basic_ios::__num_put_type *_M_num_put;
        const std::basic_ios::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const         {
            return !this->fail();
        }
        bool operator!() const         {
            return this->fail();
        }
        std::ios_base::iostate rdstate() const         {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state = goodbit);
        void setstate(std::ios_base::iostate __state)         {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state)         {
            this->_M_streambuf_state |= __state;
            if (this->exceptions() & __state)
                throw;
        }
        bool good() const         {
            return this->rdstate() == 0;
        }
        bool eof() const         {
            return (this->rdstate() & eofbit) != 0;
        }
        bool fail() const         {
            return (this->rdstate() & (badbit | failbit)) != 0;
        }
        bool bad() const         {
            return (this->rdstate() & badbit) != 0;
        }
        std::ios_base::iostate exceptions() const         {
            return this->_M_exception;
        }
        void exceptions(std::ios_base::iostate __except)         {
            this->_M_exception = __except;
            this->clear(this->_M_streambuf_state);
        }
        explicit basic_ios<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
            this->init(__sb);
        }
        virtual ~basic_ios<_CharT, _Traits>()         {
        }
        basic_ostream<_CharT, _Traits> *tie() const         {
            return this->_M_tie;
        }
        basic_ostream<_CharT, _Traits> *tie(basic_ostream<_CharT, _Traits> *__tiestr)         {
            basic_ostream<_CharT, _Traits> *__old = this->_M_tie;
            this->_M_tie = __tiestr;
            return __old;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf() const         {
            return this->_M_streambuf;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
        std::basic_ios::char_type fill() const         {
            if (!this->_M_fill_init) {
                this->_M_fill = this->widen(' ');
                this->_M_fill_init = true;
            }
            return this->_M_fill;
        }
        std::basic_ios::char_type fill(std::basic_ios::char_type __ch)         {
            std::basic_ios::char_type __old = this->fill();
            this->_M_fill = __ch;
            return __old;
        }
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios::char_type __c, char __dfault) const         {
            return __check_facet(this->_M_ctype).narrow(__c, __dfault);
        }
        std::basic_ios::char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios<_CharT, _Traits>() : std::ios_base(), _M_tie(0), _M_fill(std::basic_ios::char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
        }
        void init(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits>(const basic_ios<_CharT, _Traits> &) = delete
        basic_ios<_CharT, _Traits> &operator=(const basic_ios<_CharT, _Traits> &) = delete
        void move(basic_ios<_CharT, _Traits> &__rhs)         {
            this->ios_base::_M_move(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            this->tie(__rhs.tie(nullptr));
            this->_M_fill = __rhs._M_fill;
            this->_M_fill_init = __rhs._M_fill_init;
            this->_M_streambuf = nullptr;
        }
        void move(basic_ios<_CharT, _Traits> &&__rhs)         {
            this->move(__rhs);
        }
        void swap(basic_ios<_CharT, _Traits> &__rhs) noexcept         {
            this->ios_base::_M_swap(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            __rhs._M_cache_locale(__rhs._M_ios_locale);
            std::swap(this->_M_tie, __rhs._M_tie);
            std::swap(this->_M_fill, __rhs._M_fill);
            std::swap(this->_M_fill_init, __rhs._M_fill_init);
        }
        void set_rdbuf(basic_streambuf<_CharT, _Traits> *__sb)         {
            this->_M_streambuf = __sb;
        }
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::clear(std::ios_base::iostate __state = goodbit)     {
        if (this->rdbuf())
            this->_M_streambuf_state = __state;
        else
            this->_M_streambuf_state = __state | badbit;
        if (this->exceptions() & this->rdstate())
            __throw_ios_failure(("basic_ios::clear"));
    }
    template <typename _CharT, typename _Traits> basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits> *__sb)     {
        basic_streambuf<_CharT, _Traits> *__old = this->_M_streambuf;
        this->_M_streambuf = __sb;
        this->clear();
        return __old;
    }
    template <typename _CharT, typename _Traits> basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits> &__rhs)     {
        if (this != & __rhs) {
            std::ios_base::_Words *__words = (__rhs._M_word_size <= _S_local_word_size) ? this->_M_local_word : new std::ios_base::_Words [__rhs._M_word_size];
            std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
            if (__cb)
                __cb->_M_add_reference();
            this->_M_call_callbacks(erase_event);
            if (this->_M_word != this->_M_local_word) {
                delete [] this->_M_word;
                this->_M_word = 0;
            }
            this->_M_dispose_callbacks();
            this->_M_callbacks = __cb;
            for (int __i = 0; __i < __rhs._M_word_size; ++__i)
                __words[__i] = __rhs._M_word[__i];
            this->_M_word = __words;
            this->_M_word_size = __rhs._M_word_size;
            this->flags(__rhs.flags());
            this->width(__rhs.width());
            this->precision(__rhs.precision());
            this->tie(__rhs.tie());
            this->fill(__rhs.fill());
            this->_M_ios_locale = __rhs.getloc();
            this->_M_cache_locale(this->_M_ios_locale);
            this->_M_call_callbacks(copyfmt_event);
            this->exceptions(__rhs.exceptions());
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::locale basic_ios<_CharT, _Traits>::imbue(const std::locale &__loc)     {
        std::locale __old(this->getloc());
        this->ios_base::imbue(__loc);
        this->_M_cache_locale(__loc);
        if (this->rdbuf() != 0)
            this->rdbuf()->pubimbue(__loc);
        return __old;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits> *__sb)     {
        this->ios_base::_M_init();
        this->_M_cache_locale(this->_M_ios_locale);
        this->_M_fill = _CharT();
        this->_M_fill_init = false;
        this->_M_tie = 0;
        this->_M_exception = goodbit;
        this->_M_streambuf = __sb;
        this->_M_streambuf_state = __sb ? goodbit : badbit;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::_M_cache_locale(const std::locale &__loc)     {
        if (__builtin_expect(has_facet<std::basic_ios::__ctype_type>(__loc), true))
            this->_M_ctype = std::__addressof(use_facet<std::basic_ios::__ctype_type>(__loc));
        else
            this->_M_ctype = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_put_type>(__loc), true))
            this->_M_num_put = std::__addressof(use_facet<std::basic_ios::__num_put_type>(__loc));
        else
            this->_M_num_put = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_get_type>(__loc), true))
            this->_M_num_get = std::__addressof(use_facet<std::basic_ios::__num_get_type>(__loc));
        else
            this->_M_num_get = 0;
    }
    template<> class basic_ios<char> : public std::ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char>>> __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char>>> __num_get_type;
    protected:
        basic_ostream<char, std::char_traits<char>> *_M_tie;
        mutable std::basic_ios<char, std::char_traits<char>>::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, std::char_traits<char>> *_M_streambuf;
        const std::basic_ios<char, std::char_traits<char>>::__ctype_type *_M_ctype;
        const std::basic_ios<char, std::char_traits<char>>::__num_put_type *_M_num_put;
        const std::basic_ios<char, std::char_traits<char>>::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const         {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state)         {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<char, std::char_traits<char>> *__sb);
        virtual ~basic_ios<char>() throw();
        basic_ostream<char, std::char_traits<char>> *tie() const;
        basic_ostream<char, std::char_traits<char>> *tie(basic_ostream<char, std::char_traits<char>> *__tiestr);
        basic_streambuf<char, std::char_traits<char>> *rdbuf() const;
        basic_streambuf<char, std::char_traits<char>> *rdbuf(basic_streambuf<char, std::char_traits<char>> *__sb);
        std::basic_ios<char> &copyfmt(const std::basic_ios<char> &__rhs);
        std::basic_ios<char, std::char_traits<char>>::char_type fill() const;
        std::basic_ios<char, std::char_traits<char>>::char_type fill(std::basic_ios<char, std::char_traits<char>>::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<char, std::char_traits<char>>::char_type __c, char __dfault) const;
        std::basic_ios<char, std::char_traits<char>>::char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios();
        void init(basic_streambuf<char, std::char_traits<char>> *__sb);
        basic_ios(const std::basic_ios<char> &) = delete
        std::basic_ios<char> &operator=(const std::basic_ios<char> &) = delete
        void move(std::basic_ios<char> &__rhs);
        void move(std::basic_ios<char> &&__rhs);
        void swap(std::basic_ios<char> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<char, std::char_traits<char>> *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
    template<> class basic_ios<wchar_t> : public std::ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_get_type;
    protected:
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *_M_tie;
        mutable std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *_M_streambuf;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t>>::__ctype_type *_M_ctype;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t>>::__num_put_type *_M_num_put;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t>>::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const;
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state);
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        virtual ~basic_ios<wchar_t>() throw();
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *tie() const;
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *tie(basic_ostream<wchar_t, std::char_traits<wchar_t>> *__tiestr);
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *rdbuf() const;
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        std::basic_ios<wchar_t> &copyfmt(const std::basic_ios<wchar_t> &__rhs);
        std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type fill() const;
        std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type fill(std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type __c, char __dfault) const;
        std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        basic_ios(const std::basic_ios<wchar_t> &) = delete
        std::basic_ios<wchar_t> &operator=(const std::basic_ios<wchar_t> &) = delete
        void move(std::basic_ios<wchar_t> &__rhs);
        void move(std::basic_ios<wchar_t> &&__rhs);
        void swap(std::basic_ios<wchar_t> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef ctype<_CharT> __ctype_type;
        explicit basic_ostream<_CharT, _Traits>(std::basic_ostream::__streambuf_type *__sb)         {
            this->init(__sb);
        }
        virtual ~basic_ostream<_CharT, _Traits>()         {
        }
        class sentry;
        friend  class sentry;
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ostream_type &(*__pf)(std::basic_ostream::__ostream_type &))         {
            return __pf(*this);
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ios_type &(*__pf)(std::basic_ostream::__ios_type &))         {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(bool __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(short __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned short __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(int __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned int __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(long long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(double __f)         {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(float __f)         {
            return _M_insert(static_cast<double>(__f));
        }
        std::basic_ostream::__ostream_type &operator<<(long double __f)         {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(const void *__p)         {
            return _M_insert(__p);
        }
        std::basic_ostream::__ostream_type &operator<<(std::nullptr_t)         {
            return *this << "nullptr";
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__streambuf_type *__sb);
        std::basic_ostream::__ostream_type &put(std::basic_ostream::char_type __c);
        void _M_write(const std::basic_ostream::char_type *__s, std::streamsize __n)         {
            const std::streamsize __put = this->rdbuf()->sputn(__s, __n);
            if (__put != __n)
                this->setstate(ios_base::badbit);
        }
        std::basic_ostream::__ostream_type &write(const std::basic_ostream::char_type *__s, std::streamsize __n);
        std::basic_ostream::__ostream_type &flush();
        std::basic_ostream::pos_type tellp();
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::pos_type);
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::off_type, ios_base::seekdir);
    protected:
        basic_ostream<_CharT, _Traits>()         {
            this->init(0);
        }
        basic_ostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &)         {
        }
        basic_ostream<_CharT, _Traits>(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits>(basic_ostream<_CharT, _Traits> &&__rhs) : std::basic_ostream::__ios_type()         {
            __ios_type::move(__rhs);
        }
        basic_ostream<_CharT, _Traits> &operator=(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits> &operator=(basic_ostream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_ostream<_CharT, _Traits> &__rhs)         {
            __ios_type::swap(__rhs);
        }
        template <typename _ValueT> std::basic_ostream::__ostream_type &_M_insert(_ValueT __v);
    };
    class sentry {
        bool _M_ok;
        basic_ostream<_CharT, _Traits> &_M_os;
    public:
        explicit sentry(basic_ostream<_CharT, _Traits> &__os);
        ~sentry()         {
            if (bool(this->_M_os.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                if (this->_M_os.rdbuf() && this->_M_os.rdbuf()->pubsync() == -1)
                    this->_M_os.setstate(ios_base::badbit);
            }
        }
        explicit operator bool() const         {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, _CharT __c)     {
        return __ostream_insert(__out, & __c, 1);
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, char __c)    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, char __c)     {
        return (__out << __out.widen(__c));
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, char __c)    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, char __c)     {
        return __ostream_insert(__out, &__c, 1);
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, signed char __c)     {
        return (__out << static_cast<char>(__c));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, unsigned char __c)     {
        return (__out << static_cast<char>(__c));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, const char *__s)    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s);
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const signed char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const unsigned char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os)     {
        return flush(__os.put(__os.widen('\n')));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.put(_CharT());
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.flush();
    }
    template <typename _Ch, typename _Up> basic_ostream<_Ch, _Up> &__is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up> *);
    template<> basic_ostream<char, std::char_traits<char>> &__is_convertible_to_basic_ostream_test<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> *);
    template <typename _Tp, typename = void> struct __is_convertible_to_basic_ostream_impl {
        using __ostream_type = void;
    };
template<> struct __is_convertible_to_basic_ostream_impl<std::basic_ostream<char> &, void> {
        using __ostream_type = __do_is_convertible_to_basic_ostream_impl<std::basic_ostream<char> &>;
    };
    template <typename _Tp> using __do_is_convertible_to_basic_ostream_impl = decltype(__is_convertible_to_basic_ostream_test(declval<typename remove_reference<_Tp>::type *>()));
    template <typename _Tp> struct __is_convertible_to_basic_ostream_impl<_Tp, __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>> {
        using __ostream_type = __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };
    template <typename _Tp> struct __is_convertible_to_basic_ostream : __is_convertible_to_basic_ostream_impl<_Tp> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
        static constexpr bool value = type::value;
    };
template<> struct __is_convertible_to_basic_ostream<std::basic_ostream<char> &> : __is_convertible_to_basic_ostream_impl<std::basic_ostream<char> &> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_ostream_impl<basic_ostream<char> &>::__ostream_type>>;
        static constexpr bool value;
    };
    template <typename _Ostream, typename _Tp, typename = void> struct __is_insertable : std::false_type {
    };
    template <typename _Ostream, typename _Tp> struct __is_insertable<_Ostream, _Tp, __void_t<decltype(declval<_Ostream &>() << declval<const _Tp &>())>> : std::true_type {
    };
    template <typename _Ostream> using __rvalue_ostream_type = typename __is_convertible_to_basic_ostream<_Ostream>::__ostream_type;
    template <typename _Ostream, typename _Tp> inline typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>, __is_convertible_to_basic_ostream<_Ostream>, __is_insertable<__rvalue_ostream_type<_Ostream>, const _Tp &>>::value, __rvalue_ostream_type<_Ostream>>::type operator<<(_Ostream &&__os, const _Tp &__x)     {
        __rvalue_ostream_type<_Ostream> __ret_os = __os;
        __ret_os << __x;
        return __ret_os;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits> &__os) : _M_ok(false), _M_os(__os)     {
        if (__os.tie() && __os.good())
            __os.tie()->flush();
        if (__os.good())
            this->_M_ok = true;
        else
            __os.setstate(ios_base::failbit);
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::__num_put_type &__np = __check_facet(this->_M_num_put);
                if (__np.put(*this, *this, this->fill(), __v).failed())
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(short __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(int __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream::__streambuf_type *__sbin)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb && __sbin) {
            try {
                if (!__copy_streambufs(__sbin, this->rdbuf()))
                    __err |= ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbin)
            __err |= ios_base::badbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(std::basic_ostream::char_type __c)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::int_type __put = this->rdbuf()->sputc(__c);
                if (traits_type::eq_int_type(__put, traits_type::eof()))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, std::streamsize __n)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            try {
                this->_M_write(__s, __n);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush()     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
                __err |= ios_base::badbit;
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()     {
        std::basic_ostream::pos_type __ret = std::basic_ostream::pos_type(-1);
        try {
            if (!this->fail())
                __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::pos_type __pos)     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (!this->fail()) {
                const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
                if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                    __err |= ios_base::failbit;
            }
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::off_type __off, ios_base::seekdir __dir)     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (!this->fail()) {
                const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
                if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                    __err |= ios_base::failbit;
            }
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else {
            const std::size_t __clen = char_traits<char>::length(__s);
            try {
                struct __ptr_guard {
                    _CharT *__p;
                    __ptr_guard(_CharT *__ip) : __p(__ip)                     {
                    }
                    ~__ptr_guard()                     {
                        delete [] this->__p;
                    }
                    _CharT *__get()                     {
                        return this->__p;
                    }
                } __pg(new _CharT [__clen]);
                _CharT *__ws = __pg.__get();
                for (std::size_t __i = 0; __i < __clen; ++__i)
                    __ws[__i] = __out.widen(__s[__i]);
                __ostream_insert(__out, __ws, __clen);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(ios_base::badbit);
            }
        }
        return __out;
    }
    template<> basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, const char *__s)    template<> class basic_ostream<char> : virtual public basic_ios<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
        typedef basic_ios<char, std::char_traits<char>> __ios_type;
        typedef basic_ostream<char, std::char_traits<char>> __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char>>> __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(std::basic_ostream<char, std::char_traits<char>>::__streambuf_type *__sb);
        virtual ~basic_ostream<char>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<char, std::char_traits<char>> &_M_os;
        public:
            explicit sentry(basic_ostream<char, std::char_traits<char>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &(*__pf)(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &))         {
            return __pf(*this);
        }
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char>>::__ios_type &(*__pf)(std::basic_ostream<char, std::char_traits<char>>::__ios_type &));
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(bool __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(short __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(int __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(long long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(double __f);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(float __f);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(long double __f);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::nullptr_t);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char>>::__streambuf_type *__sb);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &put(std::basic_ostream<char, std::char_traits<char>>::char_type __c);
        void _M_write(const std::basic_ostream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &write(const std::basic_ostream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &flush();
        std::basic_ostream<char, std::char_traits<char>>::pos_type tellp();
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &seekp(std::basic_ostream<char, std::char_traits<char>>::pos_type);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &seekp(std::basic_ostream<char, std::char_traits<char>>::off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<char, std::char_traits<char>> &);
        basic_ostream(const std::basic_ostream<char> &) = delete
        basic_ostream(std::basic_ostream<char> &&__rhs);
        std::basic_ostream<char> &operator=(const std::basic_ostream<char> &) = delete
        std::basic_ostream<char> &operator=(std::basic_ostream<char> &&__rhs);
        void swap(std::basic_ostream<char> &__rhs);
        template <typename _ValueT> std::basic_ostream<char, std::char_traits<char>>::__ostream_type &_M_insert(_ValueT __v);
    };
    template<> class basic_ostream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t>> __ios_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t>> __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        virtual ~basic_ostream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, std::char_traits<wchar_t>> &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, std::char_traits<wchar_t>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &(*__pf)(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ios_type &(*__pf)(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ios_type &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(bool __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(short __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(int __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(long long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(double __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(float __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(long double __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::nullptr_t);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &put(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        void _M_write(const std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &write(const std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &flush();
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::pos_type tellp();
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &seekp(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::pos_type);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &seekp(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<wchar_t, std::char_traits<wchar_t>> &);
        basic_ostream(const std::basic_ostream<wchar_t> &) = delete
        basic_ostream(std::basic_ostream<wchar_t> &&__rhs);
        std::basic_ostream<wchar_t> &operator=(const std::basic_ostream<wchar_t> &) = delete
        std::basic_ostream<wchar_t> &operator=(std::basic_ostream<wchar_t> &&__rhs);
        void swap(std::basic_ostream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &_M_insert(_ValueT __v);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
        typedef ctype<_CharT> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream<_CharT, _Traits>(std::basic_istream::__streambuf_type *__sb) : _M_gcount(std::streamsize(0))         {
            this->init(__sb);
        }
        virtual ~basic_istream<_CharT, _Traits>()         {
            this->_M_gcount = std::streamsize(0);
        }
        class sentry;
        friend  class sentry;
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__istream_type &(*__pf)(std::basic_istream::__istream_type &))         {
            return __pf(*this);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__ios_type &(*__pf)(std::basic_istream::__ios_type &))         {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(bool &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(short &__n);
        std::basic_istream::__istream_type &operator>>(unsigned short &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(int &__n);
        std::basic_istream::__istream_type &operator>>(unsigned int &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(float &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(double &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(long double &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(void *&__p)         {
            return _M_extract(__p);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__streambuf_type *__sb);
        std::streamsize gcount() const         {
            return this->_M_gcount;
        }
        std::basic_istream::int_type get();
        std::basic_istream::__istream_type &get(std::basic_istream::char_type &__c);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n)         {
            return this->get(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb)         {
            return this->get(__sb, this->widen('\n'));
        }
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n)         {
            return this->getline(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &ignore(std::streamsize __n, std::basic_istream::int_type __delim);
        std::basic_istream::__istream_type &ignore(std::streamsize __n);
        std::basic_istream::__istream_type &ignore();
        std::basic_istream::int_type peek();
        std::basic_istream::__istream_type &read(std::basic_istream::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream::char_type *__s, std::streamsize __n);
        std::basic_istream::__istream_type &putback(std::basic_istream::char_type __c);
        std::basic_istream::__istream_type &unget();
        int sync();
        std::basic_istream::pos_type tellg();
        std::basic_istream::__istream_type &seekg(std::basic_istream::pos_type);
        std::basic_istream::__istream_type &seekg(std::basic_istream::off_type, ios_base::seekdir);
    protected:
        basic_istream<_CharT, _Traits>() : _M_gcount(std::streamsize(0))         {
            this->init(0);
        }
        basic_istream<_CharT, _Traits>(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits>(basic_istream<_CharT, _Traits> &&__rhs) : std::basic_istream::__ios_type(), _M_gcount(__rhs._M_gcount)         {
            __ios_type::move(__rhs);
            __rhs._M_gcount = 0;
        }
        basic_istream<_CharT, _Traits> &operator=(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits> &operator=(basic_istream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_istream<_CharT, _Traits> &__rhs)         {
            __ios_type::swap(__rhs);
            std::swap(this->_M_gcount, __rhs._M_gcount);
        }
        template <typename _ValueT> std::basic_istream::__istream_type &_M_extract(_ValueT &__v);
    };
    template <> basic_istream<char> &basic_istream<char>::getline(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::int_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::getline(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type __delim);
    class sentry {
        bool _M_ok;
    public:
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::__ctype_type __ctype_type;
        typedef typename _Traits::int_type __int_type;
        explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
        explicit operator bool() const         {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c);
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s);
    template<> basic_istream<char> &operator>><char, std::char_traits<char>>(basic_istream<char> &__in, char *__s);
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char *__s)     {
        return (__in >> reinterpret_cast<char *>(__s));
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char *__s)     {
        return (__in >> reinterpret_cast<char *>(__s));
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        explicit basic_iostream<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::basic_iostream::__istream_type(__sb), std::basic_iostream::__ostream_type(__sb)         {
        }
        virtual ~basic_iostream<_CharT, _Traits>()         {
        }
    protected:
        basic_iostream<_CharT, _Traits>() : std::basic_iostream::__istream_type(), std::basic_iostream::__ostream_type()         {
        }
        basic_iostream<_CharT, _Traits>(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &&__rhs) : std::basic_iostream::__istream_type(std::move(__rhs)), std::basic_iostream::__ostream_type(*this)         {
        }
        basic_iostream<_CharT, _Traits> &operator=(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits> &operator=(basic_iostream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_iostream<_CharT, _Traits> &__rhs)         {
            __istream_type::swap(__rhs);
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is);
    template <typename _Ch, typename _Up> basic_istream<_Ch, _Up> &__is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up> *);
    template<> basic_istream<char, std::char_traits<char>> &__is_convertible_to_basic_istream_test<char, std::char_traits<char>>(basic_istream<char, std::char_traits<char>> *);
    template<> basic_istream<wchar_t, std::char_traits<wchar_t>> &__is_convertible_to_basic_istream_test<wchar_t, std::char_traits<wchar_t>>(basic_istream<wchar_t, std::char_traits<wchar_t>> *);
    template <typename _Tp, typename = void> struct __is_convertible_to_basic_istream_impl {
        using __istream_type = void;
    };
template<> struct __is_convertible_to_basic_istream_impl<std::basic_istream<char> &, void> {
        using __istream_type = __do_is_convertible_to_basic_istream_impl<std::basic_istream<char> &>;
    };
template<> struct __is_convertible_to_basic_istream_impl<std::basic_istream<wchar_t> &, void> {
        using __istream_type = __do_is_convertible_to_basic_istream_impl<std::basic_istream<wchar_t> &>;
    };
    template <typename _Tp> using __do_is_convertible_to_basic_istream_impl = decltype(__is_convertible_to_basic_istream_test(declval<typename remove_reference<_Tp>::type *>()));
    template <typename _Tp> struct __is_convertible_to_basic_istream_impl<_Tp, __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>> {
        using __istream_type = __do_is_convertible_to_basic_istream_impl<_Tp>;
    };
    template <typename _Tp> struct __is_convertible_to_basic_istream : __is_convertible_to_basic_istream_impl<_Tp> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
        static constexpr bool value = type::value;
    };
template<> struct __is_convertible_to_basic_istream<std::basic_istream<char> &> : __is_convertible_to_basic_istream_impl<std::basic_istream<char> &> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_istream_impl<basic_istream<char> &>::__istream_type>>;
        static constexpr bool value;
    };
template<> struct __is_convertible_to_basic_istream<std::basic_istream<wchar_t> &> : __is_convertible_to_basic_istream_impl<std::basic_istream<wchar_t> &> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_istream_impl<basic_istream<wchar_t> &>::__istream_type>>;
        static constexpr bool value;
    };
    template <typename _Istream, typename _Tp, typename = void> struct __is_extractable : std::false_type {
    };
    template <typename _Istream, typename _Tp> struct __is_extractable<_Istream, _Tp, __void_t<decltype(declval<_Istream &>() >> declval<_Tp>())>> : std::true_type {
    };
    template <typename _Istream> using __rvalue_istream_type = typename __is_convertible_to_basic_istream<_Istream>::__istream_type;
    template <typename _Istream, typename _Tp> inline typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>, __is_convertible_to_basic_istream<_Istream>, __is_extractable<__rvalue_istream_type<_Istream>, _Tp &&>>::value, __rvalue_istream_type<_Istream>>::type operator>>(_Istream &&__is, _Tp &&__x)     {
        __rvalue_istream_type<_Istream> __ret_is = __is;
        __ret_is >> std::forward<_Tp>(__x);
        return __ret_is;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits> &__in, bool __noskip = false) : _M_ok(false)     {
        ios_base::iostate __err = ios_base::goodbit;
        if (__in.good())
            try {
                if (__in.tie())
                    __in.tie()->flush();
                if (!__noskip && bool(__in.flags() & ios_base::skipws)) {
                    const std::basic_istream::sentry::__int_type __eof = traits_type::eof();
                    std::basic_istream::sentry::__streambuf_type *__sb = __in.rdbuf();
                    std::basic_istream::sentry::__int_type __c = __sb->sgetc();
                    const std::basic_istream::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
                    while (!traits_type::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
                        __c = __sb->snextc();
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        if (__in.good() && __err == ios_base::goodbit)
            this->_M_ok = true;
        else {
            __err |= ios_base::failbit;
            __in.setstate(__err);
        }
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __v);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(short &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<short>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<short>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__max;
                } else
                    __n = short(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(int &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<int>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<int>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__max;
                } else
                    __n = int(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(std::basic_istream::__streambuf_type *__sbout)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb && __sbout) {
            try {
                bool __ineof;
                if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
                    __err |= ios_base::failbit;
                if (__ineof)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::failbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbout)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()     {
        const std::basic_istream::int_type __eof = traits_type::eof();
        std::basic_istream::int_type __c = __eof;
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                __c = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__c, __eof))
                    this->_M_gcount = 1;
                else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type &__c)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __cb = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__cb, traits_type::eof())) {
                    this->_M_gcount = 1;
                    __c = traits_type::to_char_type(__cb);
                } else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        ++this->_M_gcount;
                        __c = __sb->snextc();
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__this_sb = this->rdbuf();
                std::basic_istream::int_type __c = __this_sb->sgetc();
                std::basic_istream::char_type __c2 = traits_type::to_char_type(__c);
                while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                    {
                        ++this->_M_gcount;
                        __c = __this_sb->snextc();
                        __c2 = traits_type::to_char_type(__c);
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                        ++this->_M_gcount;
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else {
                    if (traits_type::eq_int_type(__c, __idelim)) {
                        __sb->sbumpc();
                        ++this->_M_gcount;
                    } else
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore()     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
                    __err |= ios_base::eofbit;
                else
                    this->_M_gcount = 1;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__large_ignore)
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n, std::basic_istream::int_type __delim)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__large_ignore)
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else if (traits_type::eq_int_type(__c, __delim)) {
                    if (this->_M_gcount < __gnu_cxx::__numeric_traits<streamsize>::__max)
                        ++this->_M_gcount;
                    __sb->sbumpc();
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()     {
        std::basic_istream::int_type __c = traits_type::eof();
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __c = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__c, traits_type::eof()))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(std::basic_istream::char_type *__s, std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                this->_M_gcount = this->rdbuf()->sgetn(__s, __n);
                if (this->_M_gcount != __n)
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_istream<_CharT, _Traits>::readsome(std::basic_istream::char_type *__s, std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::streamsize __num = this->rdbuf()->in_avail();
                if (__num > 0)
                    this->_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
                else if (__num == -1)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return this->_M_gcount;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(std::basic_istream::char_type __c)     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget()     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> int basic_istream<_CharT, _Traits>::sync()     {
        int __ret = -1;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (__sb) {
                    if (__sb->pubsync() == -1)
                        __err |= ios_base::badbit;
                    else
                        __ret = 0;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()     {
        std::basic_istream::pos_type __ret = std::basic_istream::pos_type(-1);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                if (!this->fail())
                    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::pos_type __pos)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::off_type __off, ios_base::seekdir __dir)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::int_type __int_type;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __int_type __cb = __in.rdbuf()->sbumpc();
                if (!_Traits::eq_int_type(__cb, _Traits::eof()))
                    __c = _Traits::to_char_type(__cb);
                else
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename _Traits::int_type int_type;
        typedef _CharT char_type;
        typedef ctype<_CharT> __ctype_type;
        std::streamsize __extracted = 0;
        ios_base::iostate __err = ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                std::streamsize __num = __in.width();
                if (__num <= 0)
                    __num = __gnu_cxx::__numeric_traits<streamsize>::__max;
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                int_type __c = __sb->sgetc();
                while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        *__s++ = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __sb->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                *__s = char_type();
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__in)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename __istream_type::int_type __int_type;
        typedef ctype<_CharT> __ctype_type;
        const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
        const __int_type __eof = _Traits::eof();
        __streambuf_type *__sb = __in.rdbuf();
        __int_type __c = __sb->sgetc();
        while (!_Traits::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
            __c = __sb->snextc();
        if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
        return __in;
    }
    template<> class basic_istream<char> : virtual public basic_ios<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
        typedef basic_ios<char, std::char_traits<char>> __ios_type;
        typedef basic_istream<char, std::char_traits<char>> __istream_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char>>> __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<char, std::char_traits<char>>::__streambuf_type *__sb);
        virtual ~basic_istream<char>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
            typedef basic_istream<char, std::char_traits<char>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, std::char_traits<char>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char>>::__istream_type &(*__pf)(std::basic_istream<char, std::char_traits<char>>::__istream_type &));
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char>>::__ios_type &(*__pf)(std::basic_istream<char, std::char_traits<char>>::__ios_type &));
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(bool &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(short &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(int &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(long long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(float &__f);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(double &__f);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(long double &__f);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(void *&__p);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char>>::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<char, std::char_traits<char>>::int_type get();
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::char_type &__c);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::__streambuf_type &__sb, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::__streambuf_type &__sb);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &getline(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &getline(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &ignore(std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::int_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &ignore();
        std::basic_istream<char, std::char_traits<char>>::int_type peek();
        std::basic_istream<char, std::char_traits<char>>::__istream_type &read(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &putback(std::basic_istream<char, std::char_traits<char>>::char_type __c);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &unget();
        int sync();
        std::basic_istream<char, std::char_traits<char>>::pos_type tellg();
        std::basic_istream<char, std::char_traits<char>>::__istream_type &seekg(std::basic_istream<char, std::char_traits<char>>::pos_type);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &seekg(std::basic_istream<char, std::char_traits<char>>::off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const std::basic_istream<char> &) = delete
        basic_istream(std::basic_istream<char> &&__rhs);
        std::basic_istream<char> &operator=(const std::basic_istream<char> &) = delete
        std::basic_istream<char> &operator=(std::basic_istream<char> &&__rhs);
        void swap(std::basic_istream<char> &__rhs);
        template <typename _ValueT> std::basic_istream<char, std::char_traits<char>>::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<char> : public basic_istream<char, std::char_traits<char>>, public basic_ostream<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, std::char_traits<char>> __istream_type;
        typedef basic_ostream<char, std::char_traits<char>> __ostream_type;
        explicit basic_iostream(basic_streambuf<char, std::char_traits<char>> *__sb);
        virtual ~basic_iostream<char>() throw();
    protected:
        basic_iostream();
        basic_iostream(const std::basic_iostream<char> &) = delete
        basic_iostream(std::basic_iostream<char> &&__rhs);
        std::basic_iostream<char> &operator=(const std::basic_iostream<char> &) = delete
        std::basic_iostream<char> &operator=(std::basic_iostream<char> &&__rhs);
        void swap(std::basic_iostream<char> &__rhs);
    };
    template<> class basic_istream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t>> __ios_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        virtual ~basic_istream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
            typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, std::char_traits<wchar_t>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &(*__pf)(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__ios_type &(*__pf)(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__ios_type &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(bool &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(short &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(int &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(long long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(float &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(double &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(long double &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(void *&__p);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type get();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type &__c);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type &__sb, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type &__sb);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &getline(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &getline(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &ignore(std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &ignore();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type peek();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &read(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &putback(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &unget();
        int sync();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::pos_type tellg();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &seekg(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::pos_type);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &seekg(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const std::basic_istream<wchar_t> &) = delete
        basic_istream(std::basic_istream<wchar_t> &&__rhs);
        std::basic_istream<wchar_t> &operator=(const std::basic_istream<wchar_t> &) = delete
        std::basic_istream<wchar_t> &operator=(std::basic_istream<wchar_t> &&__rhs);
        void swap(std::basic_istream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<wchar_t> : public basic_istream<wchar_t, std::char_traits<wchar_t>>, public basic_ostream<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t>> __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        virtual ~basic_iostream<wchar_t>() throw();
    protected:
        basic_iostream();
        basic_iostream(const std::basic_iostream<wchar_t> &) = delete
        basic_iostream(std::basic_iostream<wchar_t> &&__rhs);
        std::basic_iostream<wchar_t> &operator=(const std::basic_iostream<wchar_t> &) = delete
        std::basic_iostream<wchar_t> &operator=(std::basic_iostream<wchar_t> &&__rhs);
        void swap(std::basic_iostream<wchar_t> &__rhs);
    };
}
namespace std {
    extern std::istream cin;
    extern std::ostream cout;
    extern std::ostream cerr;
    extern std::ostream clog;
    extern std::wistream wcin;
    extern std::wostream wcout;
    extern std::wostream wcerr;
    extern std::wostream wclog;
    static ios_base::Init __ioinit;
}
namespace __gnu_cxx {
    template <typename _Tp> struct __aligned_membuf {
        struct _Tp2 {
            _Tp _M_t;
        };
        unsigned char _M_storage[sizeof(_Tp)] alignas(__alignof (_Tp2::_M_t));
        __aligned_membuf<_Tp>() = default
        __aligned_membuf<_Tp>(std::nullptr_t)         {
        }
        void *_M_addr() noexcept         {
            return static_cast<void *>(&this->_M_storage);
        }
        const void *_M_addr() const noexcept         {
            return static_cast<const void *>(&this->_M_storage);
        }
        _Tp *_M_ptr() noexcept         {
            return static_cast<_Tp *>(_M_addr());
        }
        const _Tp *_M_ptr() const noexcept         {
            return static_cast<const _Tp *>(_M_addr());
        }
    };
    template <typename _Tp> struct __aligned_buffer : std::aligned_storage<sizeof(_Tp), __alignof(_Tp)> {
        typename std::aligned_storage<sizeof(_Tp), __alignof(_Tp)>::type _M_storage;
        __aligned_buffer<_Tp>() = default
        __aligned_buffer<_Tp>(std::nullptr_t)         {
        }
        void *_M_addr() noexcept         {
            return static_cast<void *>(&this->_M_storage);
        }
        const void *_M_addr() const noexcept         {
            return static_cast<const void *>(&this->_M_storage);
        }
        _Tp *_M_ptr() noexcept         {
            return static_cast<_Tp *>(_M_addr());
        }
        const _Tp *_M_ptr() const noexcept         {
            return static_cast<const _Tp *>(_M_addr());
        }
    };
template<> struct __aligned_buffer<std::pair<const int, int>> : std::aligned_storage<sizeof(pair<const int, int>), __alignof(pair<const int, int>)> {
        typename std::aligned_storage<sizeof(pair<const int, int>), __alignof(pair<const int, int>)>::type _M_storage;
        __aligned_buffer() = default
        __aligned_buffer(std::nullptr_t);
        void *_M_addr() noexcept;
        const void *_M_addr() const noexcept;
        std::pair<const int, int> *_M_ptr() noexcept;
        const std::pair<const int, int> *_M_ptr() const noexcept;
    };
}
namespace std {
    namespace rel_ops {
        template <class _Tp> inline bool operator!=(const _Tp &__x, const _Tp &__y)         {
            return !(__x == __y);
        }
        template <class _Tp> inline bool operator>(const _Tp &__x, const _Tp &__y)         {
            return __y < __x;
        }
        template <class _Tp> inline bool operator<=(const _Tp &__x, const _Tp &__y)         {
            return !(__y < __x);
        }
        template <class _Tp> inline bool operator>=(const _Tp &__x, const _Tp &__y)         {
            return !(__x < __y);
        }
    }
}
namespace std {
    template <typename _Tp> struct tuple_size
template<> struct tuple_size<std::tuple<>> : public integral_constant<std::size_t, sizeof...(_Elements)> {
    };
    template <typename _Tp, typename _Up = typename remove_cv<_Tp>::type, typename = typename enable_if<is_same<_Tp, _Up>::value>::type, std::size_t = tuple_size<_Tp>::value> using __enable_if_has_tuple_size = _Tp;
    template <typename _Tp> struct tuple_size<const __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <std::size_t __i, typename _Tp> struct tuple_element
template<> struct tuple_element<1, std::pair<const int, int>> {
        typedef int type;
    };
    template <std::size_t __i, typename _Tp> using __tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, const _Tp> {
        typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, volatile _Tp> {
        typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, const volatile _Tp> {
        typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <std::size_t __i, typename _Tp> using tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <typename _T1, typename _T2> struct __is_tuple_like_impl<std::pair<_T1, _T2>> : std::true_type {
    };
    template <class _Tp1, class _Tp2> struct tuple_size<std::pair<_Tp1, _Tp2>> : public integral_constant<std::size_t, 2> {
    };
    template <class _Tp1, class _Tp2> struct tuple_element<0, std::pair<_Tp1, _Tp2>> {
        typedef _Tp1 type;
    };
    template <class _Tp1, class _Tp2> struct tuple_element<1, std::pair<_Tp1, _Tp2>> {
        typedef _Tp2 type;
    };
    template <std::size_t _Int> struct __pair_get;
    template<> struct __pair_get<0> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &__get(std::pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &&__move_get(std::pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<_Tp1>(__pair.first);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &__const_get(const std::pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &&__const_move_get(const std::pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<const _Tp1>(__pair.first);
        }
    };
    template<> struct __pair_get<1> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &__get(std::pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &&__move_get(std::pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<_Tp2>(__pair.second);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &__const_get(const std::pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &&__const_move_get(const std::pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<const _Tp2>(__pair.second);
        }
    };
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &get(std::pair<_Tp1, _Tp2> &__in) noexcept     {
        return __pair_get<_Int>::__get(__in);
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &&get(std::pair<_Tp1, _Tp2> &&__in) noexcept     {
        return __pair_get<_Int>::__move_get(std::move(__in));
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &get(const std::pair<_Tp1, _Tp2> &__in) noexcept     {
        return __pair_get<_Int>::__const_get(__in);
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &&get(const std::pair<_Tp1, _Tp2> &&__in) noexcept     {
        return __pair_get<_Int>::__const_move_get(std::move(__in));
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Tp, _Up> &__p) noexcept     {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Tp, _Up> &__p) noexcept     {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Tp, _Up> &&__p) noexcept     {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Tp, _Up> &&__p) noexcept     {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Up, _Tp> &__p) noexcept     {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Up, _Tp> &__p) noexcept     {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Up, _Tp> &&__p) noexcept     {
        return std::move(__p.second);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Up, _Tp> &&__p) noexcept     {
        return std::move(__p.second);
    }
    template <typename _Tp, typename _Up = _Tp> inline _Tp exchange(_Tp &__obj, _Up &&__new_val)     {
        return std::__exchange(__obj, std::forward<_Up>(__new_val));
    }
    template <std::size_t ..._Indexes> struct _Index_tuple {
    };
    template <std::size_t _Num> struct _Build_index_tuple {
        template <typename, std::size_t ..._Indices> using _IdxTuple = _Index_tuple<_Indices...>;
        using __type = __make_integer_seq<_IdxTuple, std::size_t, _Num>;
    };
    template <typename _Tp, _Tp ..._Idx> struct integer_sequence {
        typedef _Tp value_type;
        static constexpr std::size_t size() noexcept         {
            return sizeof...(_Idx);
        }
    };
    template <typename _Tp, _Tp _Num> using make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Num>;
    template <std::size_t ..._Idx> using index_sequence = integer_sequence<std::size_t, _Idx...>;
    template <std::size_t _Num> using make_index_sequence = make_integer_sequence<std::size_t, _Num>;
    template <typename ..._Types> using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
    struct in_place_t {
        explicit in_place_t() noexcept = default
    };
    constexpr std::in_place_t in_place{};
    template <typename _Tp> struct in_place_type_t {
        explicit in_place_type_t<_Tp>() = default
    };
    template <typename _Tp> constexpr in_place_type_t<_Tp> in_place_type{};
    template <std::size_t _Idx> struct in_place_index_t {
        explicit in_place_index_t<_Idx>() = default
    };
    template <std::size_t _Idx> constexpr in_place_index_t<_Idx> in_place_index{};
    template <typename> struct __is_in_place_type_impl : std::false_type {
    };
    template <typename _Tp> struct __is_in_place_type_impl<in_place_type_t<_Tp>> : std::true_type {
    };
    template <typename _Tp> struct __is_in_place_type : public __is_in_place_type_impl<_Tp> {
    };
    template <typename _Tp> constexpr add_const_t<_Tp> &as_const(_Tp &__t) noexcept     {
        return __t;
    }
    template <typename _Tp> void as_const(const _Tp &&) = delete
}
namespace std {
    template <typename _Tp, std::size_t _Nm> struct __array_traits {
        typedef _Tp _Type[_Nm];
        typedef __is_swappable<_Tp> _Is_swappable;
        typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
        static constexpr _Tp &_S_ref(const std::__array_traits::_Type &__t, std::size_t __n) noexcept         {
            return const_cast<_Tp &>(__t[__n]);
        }
        static constexpr _Tp *_S_ptr(const std::__array_traits::_Type &__t) noexcept         {
            return const_cast<_Tp *>(__t);
        }
    };
    template <typename _Tp> struct __array_traits<_Tp, 0> {
        struct _Type {
        };
        typedef std::true_type _Is_swappable;
        typedef std::true_type _Is_nothrow_swappable;
        static constexpr _Tp &_S_ref(const std::__array_traits<type-parameter-0-0, 0>::_Type &, std::size_t) noexcept         {
            return *static_cast<_Tp *>(nullptr);
        }
        static constexpr _Tp *_S_ptr(const std::__array_traits<type-parameter-0-0, 0>::_Type &) noexcept         {
            return nullptr;
        }
    };
    template <typename _Tp, std::size_t _Nm> struct array {
        typedef _Tp value_type;
        typedef std::array::value_type *pointer;
        typedef const std::array::value_type *const_pointer;
        typedef std::array::value_type &reference;
        typedef const std::array::value_type &const_reference;
        typedef std::array::value_type *iterator;
        typedef const std::array::value_type *const_iterator;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::__array_traits<_Tp, _Nm> _AT_Type;
        typename _AT_Type::_Type _M_elems;
        void fill(const std::array::value_type &__u)         {
            std::fill_n(begin(), this->size(), __u);
        }
        void swap(array<_Tp, _Nm> &__other) noexcept(_AT_Type::_Is_nothrow_swappable::valueswap(array<_Tp, _Nm> &__other) noexcept(_AT_Type::_Is_nothrow_swappable::value)         {
            std::swap_ranges(begin(), end(), __other.begin());
        }
        constexpr std::array::iterator begin() noexcept         {
            return std::array::iterator(data());
        }
        constexpr std::array::const_iterator begin() const noexcept         {
            return std::array::const_iterator(data());
        }
        constexpr std::array::iterator end() noexcept         {
            return std::array::iterator(data() + _Nm);
        }
        constexpr std::array::const_iterator end() const noexcept         {
            return std::array::const_iterator(data() + _Nm);
        }
        constexpr std::array::reverse_iterator rbegin() noexcept         {
            return std::array::reverse_iterator(end());
        }
        constexpr std::array::const_reverse_iterator rbegin() const noexcept         {
            return std::array::const_reverse_iterator(end());
        }
        constexpr std::array::reverse_iterator rend() noexcept         {
            return std::array::reverse_iterator(begin());
        }
        constexpr std::array::const_reverse_iterator rend() const noexcept         {
            return std::array::const_reverse_iterator(begin());
        }
        constexpr std::array::const_iterator cbegin() const noexcept         {
            return std::array::const_iterator(data());
        }
        constexpr std::array::const_iterator cend() const noexcept         {
            return std::array::const_iterator(data() + _Nm);
        }
        constexpr std::array::const_reverse_iterator crbegin() const noexcept         {
            return std::array::const_reverse_iterator(end());
        }
        constexpr std::array::const_reverse_iterator crend() const noexcept         {
            return std::array::const_reverse_iterator(begin());
        }
        constexpr std::array::size_type size() const noexcept         {
            return _Nm;
        }
        constexpr std::array::size_type max_size() const noexcept         {
            return _Nm;
        }
        constexpr bool empty() const noexcept [[nodiscard("")]]         {
            return this->size() == 0;
        }
        constexpr std::array::reference operator[](std::array::size_type __n) noexcept         {
            return _AT_Type::_S_ref(this->_M_elems, __n);
        }
        constexpr std::array::const_reference operator[](std::array::size_type __n) const noexcept         {
            return _AT_Type::_S_ref(this->_M_elems, __n);
        }
        constexpr std::array::reference at(std::array::size_type __n)         {
            if (__n >= _Nm)
                std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) >= _Nm (which is %zu)"), __n, _Nm);
            return _AT_Type::_S_ref(this->_M_elems, __n);
        }
        constexpr std::array::const_reference at(std::array::size_type __n) const         {
            return __n < _Nm ? _AT_Type::_S_ref(this->_M_elems, __n) : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) >= _Nm (which is %zu)"), __n, _Nm) , _AT_Type::_S_ref(this->_M_elems, 0));
        }
        constexpr std::array::reference front() noexcept         {
            return *begin();
        }
        constexpr std::array::const_reference front() const noexcept         {
            return _AT_Type::_S_ref(this->_M_elems, 0);
        }
        constexpr std::array::reference back() noexcept         {
            return _Nm ? *(end() - 1) : *end();
        }
        constexpr std::array::const_reference back() const noexcept         {
            return _Nm ? _AT_Type::_S_ref(this->_M_elems, _Nm - 1) : _AT_Type::_S_ref(this->_M_elems, 0);
        }
        constexpr std::array::pointer data() noexcept         {
            return _AT_Type::_S_ptr(this->_M_elems);
        }
        constexpr std::array::const_pointer data() const noexcept         {
            return _AT_Type::_S_ptr(this->_M_elems);
        }
    };
    template <typename _Tp, typename ..._Up> array(_Tp, _Up ...) -> array<enable_if_t<(is_same_v<_Tp, _Up> && ...), _Tp>, 1 + sizeof...(_Up)>;
    template <typename _Tp, std::size_t _Nm> inline bool operator==(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two)     {
        return std::equal(__one.begin(), __one.end(), __two.begin());
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator!=(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two)     {
        return !(__one == __two);
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator<(const array<_Tp, _Nm> &__a, const array<_Tp, _Nm> &__b)     {
        return std::lexicographical_compare(__a.begin(), __a.end(), __b.begin(), __b.end());
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator>(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two)     {
        return __two < __one;
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator<=(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two)     {
        return !(__one > __two);
    }
    template <typename _Tp, std::size_t _Nm> inline bool operator>=(const array<_Tp, _Nm> &__one, const array<_Tp, _Nm> &__two)     {
        return !(__one < __two);
    }
    template <typename _Tp, std::size_t _Nm> inline typename enable_if<std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type swap(array<_Tp, _Nm> &__one, array<_Tp, _Nm> &__two) noexcept(noexcept(__one.swap(__two))swap(array<_Tp, _Nm> &__one, array<_Tp, _Nm> &__two) noexcept(noexcept(__one.swap(__two)))     {
        __one.swap(__two);
    }
    template <typename _Tp, std::size_t _Nm> typename enable_if<!std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type swap(array<_Tp, _Nm> &, array<_Tp, _Nm> &) = delete
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr _Tp &get(array<_Tp, _Nm> &__arr) noexcept     {
        static_assert(_Int < _Nm, "array index is within bounds");
        return std::__array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
    }
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr _Tp &&get(array<_Tp, _Nm> &&__arr) noexcept     {
        static_assert(_Int < _Nm, "array index is within bounds");
        return std::move(std::get<_Int>(__arr));
    }
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr const _Tp &get(const array<_Tp, _Nm> &__arr) noexcept     {
        static_assert(_Int < _Nm, "array index is within bounds");
        return std::__array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
    }
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> constexpr const _Tp &&get(const array<_Tp, _Nm> &&__arr) noexcept     {
        static_assert(_Int < _Nm, "array index is within bounds");
        return std::move(std::get<_Int>(__arr));
    }
}
namespace std {
    template <typename _Tp> struct tuple_size
template<> struct tuple_size<std::tuple<>> : public integral_constant<std::size_t, sizeof...(_Elements)> {
    };
    template <typename _Tp, std::size_t _Nm> struct tuple_size<std::array<_Tp, _Nm>> : public integral_constant<std::size_t, _Nm> {
    };
    template <std::size_t _Int, typename _Tp> struct tuple_element
template<> struct tuple_element<1, std::pair<const int, int>> {
        typedef int type;
    };
    template <std::size_t _Int, typename _Tp, std::size_t _Nm> struct tuple_element<_Int, std::array<_Tp, _Nm>> {
        static_assert(_Int < _Nm, "index is out of bounds");
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Nm> struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : std::true_type {
    };
}
namespace std {
    struct __erased_type {
    };
    template <typename _Alloc, typename _Tp> using __is_erased_or_convertible = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, std::__erased_type>>;
    struct allocator_arg_t {
        explicit allocator_arg_t() noexcept = default
    };
    constexpr std::allocator_arg_t allocator_arg = std::allocator_arg_t();
    template <typename _Tp, typename _Alloc, typename = __void_t<>> struct __uses_allocator_helper : std::false_type {
    };
    template <typename _Tp, typename _Alloc> struct __uses_allocator_helper<_Tp, _Alloc, __void_t<typename _Tp::allocator_type>> : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type {
    };
    template <typename _Tp, typename _Alloc> struct uses_allocator : __uses_allocator_helper<_Tp, _Alloc>::type {
    };
    struct __uses_alloc_base {
    };
    struct __uses_alloc0 : std::__uses_alloc_base {
        struct _Sink {
            void operator=(const void *)             {
            }
        } _M_a;
    };
    template <typename _Alloc> struct __uses_alloc1 : std::__uses_alloc_base {
        const _Alloc *_M_a;
    };
    template <typename _Alloc> struct __uses_alloc2 : std::__uses_alloc_base {
        const _Alloc *_M_a;
    };
    template <bool, typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc;
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc<true, _Tp, _Alloc, _Args...> : conditional<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>::value, __uses_alloc1<_Alloc>, __uses_alloc2<_Alloc>>::type {
        static_assert(__or_<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>, is_constructible<_Tp, _Args..., const _Alloc &>>::value, "construction with an allocator must be possible if uses_allocator is true");
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __uses_alloc<false, _Tp, _Alloc, _Args...> : std::__uses_alloc0 {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> using __uses_alloc_t = __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;
    template <typename _Tp, typename _Alloc, typename ..._Args> inline __uses_alloc_t<_Tp, _Alloc, _Args...> __use_alloc(const _Alloc &__a)     {
        __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
        __ret._M_a = std::__addressof(__a);
        return __ret;
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __use_alloc(const _Alloc &&) = delete
    template <typename _Tp, typename _Alloc> constexpr bool uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;
    template <template <typename ...> class _Predicate, typename _Tp, typename _Alloc, typename ..._Args> struct __is_uses_allocator_predicate : conditional<uses_allocator<_Tp, _Alloc>::value, __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>, _Predicate<_Tp, _Args..., _Alloc>>, _Predicate<_Tp, _Args...>>::type {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __is_uses_allocator_constructible : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr bool __is_uses_allocator_constructible_v = __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;
    template <typename _Tp, typename _Alloc, typename ..._Args> struct __is_nothrow_uses_allocator_constructible : __is_uses_allocator_predicate<is_nothrow_constructible, _Tp, _Alloc, _Args...> {
    };
    template <typename _Tp, typename _Alloc, typename ..._Args> constexpr bool __is_nothrow_uses_allocator_constructible_v = __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;
    template <typename _Tp, typename ..._Args> void __uses_allocator_construct_impl(std::__uses_alloc0 __a, _Tp *__ptr, _Args &&...__args)     {
        ::new ((void *)__ptr) _Tp((std::forward<_Args>(__args)...));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp *__ptr, _Args &&...__args)     {
        ::new ((void *)__ptr) _Tp((allocator_arg, *__a._M_a, std::forward<_Args>(__args)...));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp *__ptr, _Args &&...__args)     {
        ::new ((void *)__ptr) _Tp((std::forward<_Args>(__args)..., *__a._M_a));
    }
    template <typename _Tp, typename _Alloc, typename ..._Args> void __uses_allocator_construct(const _Alloc &__a, _Tp *__ptr, _Args &&...__args)     {
        std::__uses_allocator_construct_impl(std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr, std::forward<_Args>(__args)...);
    }
}
namespace std {
    template <typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type> constexpr _Up &&__invfwd(typename remove_reference<_Tp>::type &__t) noexcept     {
        return static_cast<_Up &&>(__t);
    }
    template <typename _Res, typename _Fn, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_other, _Fn &&__f, _Args &&...__args)     {
        return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_memfun_ref, _MemFun &&__f, _Tp &&__t, _Args &&...__args)     {
        return (__invfwd<_Tp>(__t) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_memfun_deref, _MemFun &&__f, _Tp &&__t, _Args &&...__args)     {
        return ((*std::forward<_Tp>(__t)) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(std::__invoke_memobj_ref, _MemPtr &&__f, _Tp &&__t)     {
        return __invfwd<_Tp>(__t) .* __f;
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(std::__invoke_memobj_deref, _MemPtr &&__f, _Tp &&__t)     {
        return (*std::forward<_Tp>(__t)) .* __f;
    }
    template <typename _Callable, typename ..._Args> constexpr typename __invoke_result<_Callable, _Args...>::type __invoke(_Callable &&__fn, _Args &&...__args) noexcept(__is_nothrow_invocable<_Callable, _Args...>::value__invoke(_Callable &&__fn, _Args &&...__args) noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)     {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        return std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _Callable, typename ..._Args> constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res> __invoke_r(_Callable &&__fn, _Args &&...__args) noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>__invoke_r(_Callable &&__fn, _Args &&...__args) noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)     {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        if (is_void_v<_Res>)
            std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
        else
            return std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
}
namespace std {
    template <typename ..._Elements> class tuple;
    template <typename _Tp> struct __is_empty_non_tuple : is_empty<_Tp> {
    };
    template <typename _El0, typename ..._El> struct __is_empty_non_tuple<tuple<_El0, _El...>> : std::false_type {
    };
    template <typename _Tp> using __empty_not_final = typename conditional<__is_final(_Tp), false_type, __is_empty_non_tuple<_Tp>>::type;
    template <std::size_t _Idx, typename _Head, bool = __empty_not_final<_Head>::value> struct _Head_base;
    template <std::size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, true> : public _Head {
        constexpr _Head_base<_Idx, type-parameter-0-1, true>() : _Head()         {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, true>(const _Head &__h) : _Head(__h)         {
        }
        _Head_base<_Idx, type-parameter-0-1, true>(const _Head_base<_Idx, type-parameter-0-1, true> &) = default
        _Head_base<_Idx, type-parameter-0-1, true>(_Head_base<_Idx, type-parameter-0-1, true> &&) = default
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, true>(_UHead &&__h) : _Head(std::forward<_UHead>(__h))         {
        }
        _Head_base<_Idx, type-parameter-0-1, true>(std::allocator_arg_t, std::__uses_alloc0) : _Head()         {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, true>(std::allocator_arg_t, __uses_alloc1<_Alloc> __a) : _Head(allocator_arg, *__a._M_a)         {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, true>(std::allocator_arg_t, __uses_alloc2<_Alloc> __a) : _Head(*__a._M_a)         {
        }
        template <typename _UHead> _Head_base<_Idx, type-parameter-0-1, true>(std::__uses_alloc0, _UHead &&__uhead) : _Head(std::forward<_UHead>(__uhead))         {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, true>(__uses_alloc1<_Alloc> __a, _UHead &&__uhead) : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))         {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, true>(__uses_alloc2<_Alloc> __a, _UHead &&__uhead) : _Head(std::forward<_UHead>(__uhead), *__a._M_a)         {
        }
        static constexpr _Head &_M_head(_Head_base<_Idx, type-parameter-0-1, true> &__b) noexcept         {
            return __b;
        }
        static constexpr const _Head &_M_head(const _Head_base<_Idx, type-parameter-0-1, true> &__b) noexcept         {
            return __b;
        }
    };
    template <std::size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, false> {
        constexpr _Head_base<_Idx, type-parameter-0-1, false>() : _M_head_impl()         {
        }
        constexpr _Head_base<_Idx, type-parameter-0-1, false>(const _Head &__h) : _M_head_impl(__h)         {
        }
        _Head_base<_Idx, type-parameter-0-1, false>(const _Head_base<_Idx, type-parameter-0-1, false> &) = default
        _Head_base<_Idx, type-parameter-0-1, false>(_Head_base<_Idx, type-parameter-0-1, false> &&) = default
        template <typename _UHead> constexpr _Head_base<_Idx, type-parameter-0-1, false>(_UHead &&__h) : _M_head_impl(std::forward<_UHead>(__h))         {
        }
        _Head_base<_Idx, type-parameter-0-1, false>(std::allocator_arg_t, std::__uses_alloc0) : _M_head_impl()         {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, false>(std::allocator_arg_t, __uses_alloc1<_Alloc> __a) : _M_head_impl(allocator_arg, *__a._M_a)         {
        }
        template <typename _Alloc> _Head_base<_Idx, type-parameter-0-1, false>(std::allocator_arg_t, __uses_alloc2<_Alloc> __a) : _M_head_impl(*__a._M_a)         {
        }
        template <typename _UHead> _Head_base<_Idx, type-parameter-0-1, false>(std::__uses_alloc0, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead))         {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, false>(__uses_alloc1<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))         {
        }
        template <typename _Alloc, typename _UHead> _Head_base<_Idx, type-parameter-0-1, false>(__uses_alloc2<_Alloc> __a, _UHead &&__uhead) : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a)         {
        }
        static constexpr _Head &_M_head(_Head_base<_Idx, type-parameter-0-1, false> &__b) noexcept         {
            return __b._M_head_impl;
        }
        static constexpr const _Head &_M_head(const _Head_base<_Idx, type-parameter-0-1, false> &__b) noexcept         {
            return __b._M_head_impl;
        }
        _Head _M_head_impl;
    };
    template <std::size_t _Idx, typename ..._Elements> struct _Tuple_impl;
    template <std::size_t _Idx, typename _Head, typename ..._Tail> struct _Tuple_impl<_Idx, _Head, _Tail...> : public _Tuple_impl<_Idx + 1, _Tail...>, private _Head_base<_Idx, _Head> {
        friend template <std::size_t, typename ...> class _Tuple_impl;
        typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
        typedef _Head_base<_Idx, _Head> _Base;
        static constexpr _Head &_M_head(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept         {
            return _Base::_M_head(__t);
        }
        static constexpr const _Head &_M_head(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept         {
            return _Base::_M_head(__t);
        }
        static constexpr std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited &_M_tail(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept         {
            return __t;
        }
        static constexpr const std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited &_M_tail(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__t) noexcept         {
            return __t;
        }
        constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>() : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base()         {
        }
        constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Head &__head, const _Tail &...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tail...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__head)         {
        }
        template <typename _UHead, typename ..._UTail, typename = typename enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type> constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_UHead &&__head, _UTail &&...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(std::forward<_UTail>(__tail)...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(std::forward<_UHead>(__head))         {
        }
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &) = default
        _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &operator=(const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &) = delete
        constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &&__in) noexcept(__and_<is_nothrow_move_constructible<_Head>, is_nothrow_move_constructible<_Inherited>>::value_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &&__in) noexcept(__and_<is_nothrow_move_constructible<_Head>, is_nothrow_move_constructible<_Inherited>>::value) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(std::move(_M_tail(__in))), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(std::forward<_Head>(_M_head(__in)))         {
        }
        template <typename ..._UElements> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(const _Tuple_impl<_Idx, _UElements...> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))         {
        }
        template <typename _UHead, typename ..._UTails> constexpr _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__tag, __use_alloc<_Head>(__a))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Head &__head, const _Tail &...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, __tail...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)         {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTail, typename = typename enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&__head, _UTail &&...__tail) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, std::forward<_UTail>(__tail)...), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(__head))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, _M_tail(__in)), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, std::move(_M_tail(__in))), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), std::forward<_Head>(_M_head(__in)))         {
        }
        template <typename _Alloc, typename ..._UElements> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, _UElements...> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), _Tuple_impl<_Idx, _UElements...>::_M_head(__in))         {
        }
        template <typename _Alloc, typename _UHead, typename ..._UTails> _Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, _UHead, _UTails...> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Inherited(__tag, __a, std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))), std::_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))         {
        }
        template <typename ..._UElements> void _M_assign(const _Tuple_impl<_Idx, _UElements...> &__in)         {
            _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
            _M_tail(*this)._M_assign(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
        }
        template <typename _UHead, typename ..._UTails> void _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in)         {
            _M_head(*this) = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
            _M_tail(*this)._M_assign(std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
        }
    protected:
        void _M_swap(_Tuple_impl<_Idx, type-parameter-0-1, type-parameter-0-2...> &__in)         {
            using std::swap;
            swap(_M_head(*this), _M_head(__in));
            _Inherited::_M_swap(_M_tail(__in));
        }
    };
    template <std::size_t _Idx, typename _Head> struct _Tuple_impl<_Idx, _Head> : private _Head_base<_Idx, _Head> {
        friend template <std::size_t, typename ...> class _Tuple_impl;
        typedef _Head_base<_Idx, _Head> _Base;
        static constexpr _Head &_M_head(_Tuple_impl<_Idx, type-parameter-0-1> &__t) noexcept         {
            return _Base::_M_head(__t);
        }
        static constexpr const _Head &_M_head(const _Tuple_impl<_Idx, type-parameter-0-1> &__t) noexcept         {
            return _Base::_M_head(__t);
        }
        constexpr _Tuple_impl<_Idx, type-parameter-0-1>() : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base()         {
        }
        constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1>(const _Head &__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__head)         {
        }
        template <typename _UHead> constexpr explicit _Tuple_impl<_Idx, type-parameter-0-1>(_UHead &&__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(std::forward<_UHead>(__head))         {
        }
        _Tuple_impl<_Idx, type-parameter-0-1>(const _Tuple_impl<_Idx, type-parameter-0-1> &) = default
        _Tuple_impl<_Idx, type-parameter-0-1> &operator=(const _Tuple_impl<_Idx, type-parameter-0-1> &) = delete
        constexpr _Tuple_impl<_Idx, type-parameter-0-1>(_Tuple_impl<_Idx, type-parameter-0-1> &&__in) noexcept(is_nothrow_move_constructible<_Head>::value_Tuple_impl<_Idx, type-parameter-0-1>(_Tuple_impl<_Idx, type-parameter-0-1> &&__in) noexcept(is_nothrow_move_constructible<_Head>::value) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(std::forward<_Head>(_M_head(__in)))         {
        }
        template <typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(const _Tuple_impl<_Idx, _UHead> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))         {
        }
        template <typename _UHead> constexpr _Tuple_impl<_Idx, type-parameter-0-1>(_Tuple_impl<_Idx, _UHead> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__tag, __use_alloc<_Head>(__a))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _Head &__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)         {
        }
        template <typename _Alloc, typename _UHead> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&__head) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(__head))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, type-parameter-0-1> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))         {
        }
        template <typename _Alloc> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, type-parameter-0-1> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), std::forward<_Head>(_M_head(__in)))         {
        }
        template <typename _Alloc, typename _UHead> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _Tuple_impl<_Idx, _UHead> &__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _Head>(__a), _Tuple_impl<_Idx, _UHead>::_M_head(__in))         {
        }
        template <typename _Alloc, typename _UHead> _Tuple_impl<_Idx, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _Tuple_impl<_Idx, _UHead> &&__in) : std::_Tuple_impl<_Idx, type-parameter-0-1>::_Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))         {
        }
        template <typename _UHead> void _M_assign(const _Tuple_impl<_Idx, _UHead> &__in)         {
            _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
        }
        template <typename _UHead> void _M_assign(_Tuple_impl<_Idx, _UHead> &&__in)         {
            _M_head(*this) = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
        }
    protected:
        void _M_swap(_Tuple_impl<_Idx, type-parameter-0-1> &__in)         {
            using std::swap;
            swap(_M_head(*this), _M_head(__in));
        }
    };
    template <bool, typename ..._Types> struct _TupleConstraints {
        template <typename ..._UTypes> static constexpr bool __is_implicitly_constructible()         {
            return __and_<is_constructible<_Types, _UTypes>..., is_convertible<_UTypes, _Types>...>::value;
        }
        template <typename ..._UTypes> static constexpr bool __is_explicitly_constructible()         {
            return __and_<is_constructible<_Types, _UTypes>..., __not_<__and_<is_convertible<_UTypes, _Types>...>>>::value;
        }
        static constexpr bool __is_implicitly_default_constructible()         {
            return __and_<std::__is_implicitly_default_constructible<_Types>...>::value;
        }
        static constexpr bool __is_explicitly_default_constructible()         {
            return __and_<is_default_constructible<_Types>..., __not_<__and_<std::__is_implicitly_default_constructible<_Types>...>>>::value;
        }
    };
    template <typename ..._Types> struct _TupleConstraints<false, _Types...> {
        template <typename ..._UTypes> static constexpr bool __is_implicitly_constructible()         {
            return false;
        }
        template <typename ..._UTypes> static constexpr bool __is_explicitly_constructible()         {
            return false;
        }
    };
    template <typename ..._Elements> class tuple : public _Tuple_impl<0, _Elements...> {
        typedef _Tuple_impl<0, _Elements...> _Inherited;
        template <bool _Cond> using _TCC = _TupleConstraints<_Cond, _Elements...>;
        template <bool _Dummy> using _ImplicitDefaultCtor = __enable_if_t<_TCC<_Dummy>::__is_implicitly_default_constructible(), bool>;
        template <bool _Dummy> using _ExplicitDefaultCtor = __enable_if_t<_TCC<_Dummy>::__is_explicitly_default_constructible(), bool>;
        template <bool _Cond, typename ..._Args> using _ImplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_implicitly_constructible<_Args...>(), bool>;
        template <bool _Cond, typename ..._Args> using _ExplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_explicitly_constructible<_Args...>(), bool>;
        template <typename ..._UElements> static constexpr __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool> __assignable()         {
            return __and_<is_assignable<_Elements &, _UElements>...>::value;
        }
        template <typename ..._UElements> static constexpr bool __nothrow_assignable()         {
            return __and_<is_nothrow_assignable<_Elements &, _UElements>...>::value;
        }
        template <typename ..._UElements> static constexpr bool __nothrow_constructible()         {
            return __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
        }
        template <typename _Up> static constexpr bool __valid_args()         {
            return sizeof...(_Elements) == 1 && !is_same<tuple<_Elements...>, __remove_cvref_t<_Up>>::value;
        }
        template <typename, typename, typename ..._Tail> static constexpr bool __valid_args()         {
            return (sizeof...(_Tail) + 2) == sizeof...(_Elements);
        }
        template <typename _Tuple, typename = tuple<_Elements...>, typename = __remove_cvref_t<_Tuple>> struct _UseOtherCtor : std::false_type {
        };
        template <typename _Tuple, typename _Tp, typename _Up> struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>> : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>> {
        };
        template <typename _Tuple, typename _Tp> struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>> : std::true_type {
        };
        template <typename _Tuple> static constexpr bool __use_other_ctor()         {
            return _UseOtherCtor<_Tuple>::value;
        }
    public:
        template <typename _Dummy = void, _ImplicitDefaultCtor<is_void<_Dummy>::value> = true> constexpr tuple<_Elements...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::valuetuple<_Elements...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value) : std::tuple::_Inherited()         {
        }
        template <typename _Dummy = void, _ExplicitDefaultCtor<is_void<_Dummy>::value> = false> constexpr explicit tuple<_Elements...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::valuetuple<_Elements...>() noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value) : std::tuple::_Inherited()         {
        }
        template <bool _NotEmpty = (sizeof...(_Elements) >= 1), _ImplicitCtor<_NotEmpty, const _Elements &...> = true> constexpr tuple<_Elements...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()tuple<_Elements...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()) : std::tuple::_Inherited(__elements...)         {
        }
        template <bool _NotEmpty = (sizeof...(_Elements) >= 1), _ExplicitCtor<_NotEmpty, const _Elements &...> = false> constexpr explicit tuple<_Elements...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()tuple<_Elements...>(const _Elements &...__elements) noexcept(__nothrow_constructible<const _Elements &...>()) : std::tuple::_Inherited(__elements...)         {
        }
        template <typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<_Elements...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()tuple<_Elements...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(std::forward<_UElements>(__elements)...)         {
        }
        template <typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<_Elements...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()tuple<_Elements...>(_UElements &&...__elements) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(std::forward<_UElements>(__elements)...)         {
        }
        tuple<_Elements...>(const tuple<_Elements...> &) = default
        tuple<_Elements...>(tuple<_Elements...> &&) = default
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ImplicitCtor<_Valid, const _UElements &...> = true> constexpr tuple<_Elements...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()tuple<_Elements...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()) : std::tuple::_Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in))         {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ExplicitCtor<_Valid, const _UElements &...> = false> constexpr explicit tuple<_Elements...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()tuple<_Elements...>(const tuple<_UElements...> &__in) noexcept(__nothrow_constructible<const _UElements &...>()) : std::tuple::_Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in))         {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ImplicitCtor<_Valid, _UElements...> = true> constexpr tuple<_Elements...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()tuple<_Elements...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in))         {
        }
        template <typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ExplicitCtor<_Valid, _UElements...> = false> constexpr explicit tuple<_Elements...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()tuple<_Elements...>(tuple<_UElements...> &&__in) noexcept(__nothrow_constructible<_UElements...>()) : std::tuple::_Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in))         {
        }
        template <typename _Alloc, _ImplicitDefaultCtor<is_object<_Alloc>::value> = true> tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a) : std::tuple::_Inherited(__tag, __a)         {
        }
        template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1), _ImplicitCtor<_NotEmpty, const _Elements &...> = true> tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...__elements) : std::tuple::_Inherited(__tag, __a, __elements...)         {
        }
        template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1), _ExplicitCtor<_NotEmpty, const _Elements &...> = false> explicit tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...__elements) : std::tuple::_Inherited(__tag, __a, __elements...)         {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ImplicitCtor<_Valid, _UElements...> = true> tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...__elements) : std::tuple::_Inherited(__tag, __a, std::forward<_UElements>(__elements)...)         {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = __valid_args<_UElements...>(), _ExplicitCtor<_Valid, _UElements...> = false> explicit tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...__elements) : std::tuple::_Inherited(__tag, __a, std::forward<_UElements>(__elements)...)         {
        }
        template <typename _Alloc> tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_Elements...> &__in) : std::tuple::_Inherited(__tag, __a, static_cast<const std::tuple::_Inherited &>(__in))         {
        }
        template <typename _Alloc> tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_Elements...> &&__in) : std::tuple::_Inherited(__tag, __a, static_cast<std::tuple::_Inherited &&>(__in))         {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ImplicitCtor<_Valid, const _UElements &...> = true> tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_UElements...> &__in) : std::tuple::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _UElements...> &>(__in))         {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<const tuple<_UElements...> &>(), _ExplicitCtor<_Valid, const _UElements &...> = false> explicit tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_UElements...> &__in) : std::tuple::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _UElements...> &>(__in))         {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ImplicitCtor<_Valid, _UElements...> = true> tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_UElements...> &&__in) : std::tuple::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UElements...> &&>(__in))         {
        }
        template <typename _Alloc, typename ..._UElements, bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) && !__use_other_ctor<tuple<_UElements...> &&>(), _ExplicitCtor<_Valid, _UElements...> = false> explicit tuple<_Elements...>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_UElements...> &&__in) : std::tuple::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UElements...> &&>(__in))         {
        }
        tuple<_Elements...> &operator=(typename conditional<__assignable<const _Elements &...>(), const tuple<_Elements...> &, const __nonesuch &>::type __in) noexcept(__nothrow_assignable<const _Elements &...>()operator=(typename conditional<__assignable<const _Elements &...>(), const tuple<_Elements...> &, const __nonesuch &>::type __in) noexcept(__nothrow_assignable<const _Elements &...>())         {
            this->_M_assign(__in);
            return *this;
        }
        tuple<_Elements...> &operator=(typename conditional<__assignable<_Elements...>(), tuple<_Elements...> &&, __nonesuch &&>::type __in) noexcept(__nothrow_assignable<_Elements...>()operator=(typename conditional<__assignable<_Elements...>(), tuple<_Elements...> &&, __nonesuch &&>::type __in) noexcept(__nothrow_assignable<_Elements...>())         {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename ..._UElements> __enable_if_t<__assignable<const _UElements &...>(), tuple<_Elements...> &> operator=(const tuple<_UElements...> &__in) noexcept(__nothrow_assignable<const _UElements &...>()operator=(const tuple<_UElements...> &__in) noexcept(__nothrow_assignable<const _UElements &...>())         {
            this->_M_assign(__in);
            return *this;
        }
        template <typename ..._UElements> __enable_if_t<__assignable<_UElements...>(), tuple<_Elements...> &> operator=(tuple<_UElements...> &&__in) noexcept(__nothrow_assignable<_UElements...>()operator=(tuple<_UElements...> &&__in) noexcept(__nothrow_assignable<_UElements...>())         {
            this->_M_assign(std::move(__in));
            return *this;
        }
        void swap(tuple<_Elements...> &__in) noexcept(__and_<__is_nothrow_swappable<_Elements>...>::valueswap(tuple<_Elements...> &__in) noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)         {
            _Inherited::_M_swap(__in);
        }
    };
    template <typename ..._UTypes> tuple(_UTypes ...) -> tuple<_UTypes...>;
    template <typename _T1, typename _T2> tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
    template <typename _Alloc, typename ..._UTypes> tuple(std::allocator_arg_t, _Alloc, _UTypes ...) -> tuple<_UTypes...>;
    template <typename _Alloc, typename _T1, typename _T2> tuple(std::allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
    template <typename _Alloc, typename ..._UTypes> tuple(std::allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;
    template<> class tuple<> {
    public:
        void swap(std::tuple<> &) noexcept         {
        }
        tuple() noexcept = default
        template <typename _Alloc> tuple(std::allocator_arg_t, const _Alloc &) noexcept         {
        }
        template <typename _Alloc> tuple(std::allocator_arg_t, const _Alloc &, const std::tuple<> &) noexcept         {
        }
    };
    template <typename _T1, typename _T2> class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2> {
        typedef _Tuple_impl<0, _T1, _T2> _Inherited;
        template <bool _Dummy, typename _U1, typename _U2> using _ImplicitDefaultCtor = __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::__is_implicitly_default_constructible(), bool>;
        template <bool _Dummy, typename _U1, typename _U2> using _ExplicitDefaultCtor = __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::__is_explicitly_default_constructible(), bool>;
        template <bool _Dummy> using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;
        template <bool _Cond, typename _U1, typename _U2> using _ImplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(), bool>;
        template <bool _Cond, typename _U1, typename _U2> using _ExplicitCtor = __enable_if_t<_TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(), bool>;
        template <typename _U1, typename _U2> static constexpr bool __assignable()         {
            return __and_<is_assignable<_T1 &, _U1>, is_assignable<_T2 &, _U2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool __nothrow_assignable()         {
            return __and_<is_nothrow_assignable<_T1 &, _U1>, is_nothrow_assignable<_T2 &, _U2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool __nothrow_constructible()         {
            return __and_<is_nothrow_constructible<_T1, _U1>, is_nothrow_constructible<_T2, _U2>>::value;
        }
        static constexpr bool __nothrow_default_constructible()         {
            return __and_<is_nothrow_default_constructible<_T1>, is_nothrow_default_constructible<_T2>>::value;
        }
        template <typename _U1> static constexpr bool __is_alloc_arg()         {
            return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value;
        }
    public:
        template <bool _Dummy = true, _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited()         {
        }
        template <bool _Dummy = true, _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()tuple<type-parameter-0-0, type-parameter-0-1>() noexcept(__nothrow_default_constructible()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited()         {
        }
        template <bool _Dummy = true, _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__a1, __a2)         {
        }
        template <bool _Dummy = true, _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()tuple<type-parameter-0-0, type-parameter-0-1>(const _T1 &__a1, const _T2 &__a2) noexcept(__nothrow_constructible<const _T1 &, const _T2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__a1, __a2)         {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2))         {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()tuple<type-parameter-0-0, type-parameter-0-1>(_U1 &&__a1, _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2))         {
        }
        tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<type-parameter-0-0, type-parameter-0-1> &) = default
        tuple<type-parameter-0-0, type-parameter-0-1>(tuple<type-parameter-0-0, type-parameter-0-1> &&) = default
        template <typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in))         {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()tuple<type-parameter-0-0, type-parameter-0-1>(const tuple<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in))         {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in))         {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()tuple<type-parameter-0-0, type-parameter-0-1>(tuple<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in))         {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__in.first, __in.second)         {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()tuple<type-parameter-0-0, type-parameter-0-1>(const pair<_U1, _U2> &__in) noexcept(__nothrow_constructible<const _U1 &, const _U2 &>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__in.first, __in.second)         {
        }
        template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> constexpr tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__in.first), std::forward<_U2>(__in.second))         {
        }
        template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> constexpr explicit tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()tuple<type-parameter-0-0, type-parameter-0-1>(pair<_U1, _U2> &&__in) noexcept(__nothrow_constructible<_U1, _U2>()) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(std::forward<_U1>(__in.first), std::forward<_U2>(__in.second))         {
        }
        template <typename _Alloc, _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a)         {
        }
        template <typename _Alloc, bool _Dummy = true, _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1, const _T2 &__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __a1, __a2)         {
        }
        template <typename _Alloc, bool _Dummy = true, _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1, const _T2 &__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __a1, __a2)         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__a1), std::forward<_U2>(__a2))         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__a1), std::forward<_U2>(__a2))         {
        }
        template <typename _Alloc> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<type-parameter-0-0, type-parameter-0-1> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<const std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited &>(__in))         {
        }
        template <typename _Alloc> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<type-parameter-0-0, type-parameter-0-1> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited &&>(__in))         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in))         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const tuple<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in))         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in))         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, tuple<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in))         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, const _U1 &, const _U2 &> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const pair<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __in.first, __in.second)         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, const _U1 &, const _U2 &> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, const pair<_U1, _U2> &__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, __in.first, __in.second)         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true> tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, pair<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__in.first), std::forward<_U2>(__in.second))         {
        }
        template <typename _Alloc, typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false> explicit tuple<type-parameter-0-0, type-parameter-0-1>(std::allocator_arg_t __tag, const _Alloc &__a, pair<_U1, _U2> &&__in) : std::tuple<type-parameter-0-0, type-parameter-0-1>::_Inherited(__tag, __a, std::forward<_U1>(__in.first), std::forward<_U2>(__in.second))         {
        }
        tuple<type-parameter-0-0, type-parameter-0-1> &operator=(typename conditional<__assignable<const _T1 &, const _T2 &>(), const tuple<type-parameter-0-0, type-parameter-0-1> &, const __nonesuch &>::type __in) noexcept(__nothrow_assignable<const _T1 &, const _T2 &>()operator=(typename conditional<__assignable<const _T1 &, const _T2 &>(), const tuple<type-parameter-0-0, type-parameter-0-1> &, const __nonesuch &>::type __in) noexcept(__nothrow_assignable<const _T1 &, const _T2 &>())         {
            this->_M_assign(__in);
            return *this;
        }
        tuple<type-parameter-0-0, type-parameter-0-1> &operator=(typename conditional<__assignable<_T1, _T2>(), tuple<type-parameter-0-0, type-parameter-0-1> &&, __nonesuch &&>::type __in) noexcept(__nothrow_assignable<_T1, _T2>()operator=(typename conditional<__assignable<_T1, _T2>(), tuple<type-parameter-0-0, type-parameter-0-1> &&, __nonesuch &&>::type __in) noexcept(__nothrow_assignable<_T1, _T2>())         {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(const tuple<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>()operator=(const tuple<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>())         {
            this->_M_assign(__in);
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<_U1, _U2>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(tuple<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()operator=(tuple<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>())         {
            this->_M_assign(std::move(__in));
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(const pair<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>()operator=(const pair<_U1, _U2> &__in) noexcept(__nothrow_assignable<const _U1 &, const _U2 &>())         {
            this->_M_head(*this) = __in.first;
            this->_M_tail(*this)._M_head(*this) = __in.second;
            return *this;
        }
        template <typename _U1, typename _U2> __enable_if_t<__assignable<_U1, _U2>(), tuple<type-parameter-0-0, type-parameter-0-1> &> operator=(pair<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()operator=(pair<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>())         {
            this->_M_head(*this) = std::forward<_U1>(__in.first);
            this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
            return *this;
        }
        void swap(tuple<type-parameter-0-0, type-parameter-0-1> &__in) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::valueswap(tuple<type-parameter-0-0, type-parameter-0-1> &__in) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value)         {
            _Inherited::_M_swap(__in);
        }
    };
    template <typename ..._Elements> struct tuple_size<tuple<_Elements...>> : public integral_constant<std::size_t, sizeof...(_Elements)> {
    };
    template <typename _Tp> constexpr std::size_t tuple_size_v = tuple_size<_Tp>::value;
    template <std::size_t __i, typename _Head, typename ..._Tail> struct tuple_element<__i, tuple<_Head, _Tail...>> : tuple_element<__i - 1, tuple<_Tail...>> {
    };
    template <typename _Head, typename ..._Tail> struct tuple_element<0, tuple<_Head, _Tail...>> {
        typedef _Head type;
    };
    template <std::size_t __i> struct tuple_element<__i, tuple<>> {
        static_assert(__i < tuple_size<tuple<>>::value, "tuple index is in range");
    };
    template <std::size_t __i, typename _Head, typename ..._Tail> constexpr _Head &__get_helper(_Tuple_impl<__i, _Head, _Tail...> &__t) noexcept     {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <std::size_t __i, typename _Head, typename ..._Tail> constexpr const _Head &__get_helper(const _Tuple_impl<__i, _Head, _Tail...> &__t) noexcept     {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <std::size_t __i, typename ..._Elements> constexpr __tuple_element_t<__i, tuple<_Elements...>> &get(tuple<_Elements...> &__t) noexcept     {
        return std::__get_helper<__i>(__t);
    }
    template <std::size_t __i, typename ..._Elements> constexpr const __tuple_element_t<__i, tuple<_Elements...>> &get(const tuple<_Elements...> &__t) noexcept     {
        return std::__get_helper<__i>(__t);
    }
    template <std::size_t __i, typename ..._Elements> constexpr __tuple_element_t<__i, tuple<_Elements...>> &&get(tuple<_Elements...> &&__t) noexcept     {
        typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
        return std::forward<__element_type &&>(std::get<__i>(__t));
    }
    template <std::size_t __i, typename ..._Elements> constexpr const __tuple_element_t<__i, tuple<_Elements...>> &&get(const tuple<_Elements...> &&__t) noexcept     {
        typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
        return std::forward<const __element_type &&>(std::get<__i>(__t));
    }
    template <typename _Head, std::size_t __i, typename ..._Tail> constexpr _Head &__get_helper2(_Tuple_impl<__i, _Head, _Tail...> &__t) noexcept     {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <typename _Head, std::size_t __i, typename ..._Tail> constexpr const _Head &__get_helper2(const _Tuple_impl<__i, _Head, _Tail...> &__t) noexcept     {
        return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
    }
    template <typename _Tp, typename ..._Types> constexpr _Tp &get(tuple<_Types...> &__t) noexcept     {
        return std::__get_helper2<_Tp>(__t);
    }
    template <typename _Tp, typename ..._Types> constexpr _Tp &&get(tuple<_Types...> &&__t) noexcept     {
        return std::forward<_Tp &&>(std::__get_helper2<_Tp>(__t));
    }
    template <typename _Tp, typename ..._Types> constexpr const _Tp &get(const tuple<_Types...> &__t) noexcept     {
        return std::__get_helper2<_Tp>(__t);
    }
    template <typename _Tp, typename ..._Types> constexpr const _Tp &&get(const tuple<_Types...> &&__t) noexcept     {
        return std::forward<const _Tp &&>(std::__get_helper2<_Tp>(__t));
    }
    template <typename _Tp, typename _Up, std::size_t __i, std::size_t __size> struct __tuple_compare {
        static constexpr bool __eq(const _Tp &__t, const _Up &__u)         {
            return bool(std::get<__i>(__t) == std::get<__i>(__u)) && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
        }
        static constexpr bool __less(const _Tp &__t, const _Up &__u)         {
            return bool(std::get<__i>(__t) < std::get<__i>(__u)) || (!bool(std::get<__i>(__u) < std::get<__i>(__t)) && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
        }
    };
    template <typename _Tp, typename _Up, std::size_t __size> struct __tuple_compare<_Tp, _Up, __size, __size> {
        static constexpr bool __eq(const _Tp &, const _Up &)         {
            return true;
        }
        static constexpr bool __less(const _Tp &, const _Up &)         {
            return false;
        }
    };
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator==(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u)     {
        static_assert(sizeof...(_TElements) == sizeof...(_UElements), "tuple objects can only be compared if they have equal sizes.");
        using __compare = __tuple_compare<tuple<_TElements...>, tuple<_UElements...>, 0, sizeof...(_TElements)>;
        return __compare::__eq(__t, __u);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator<(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u)     {
        static_assert(sizeof...(_TElements) == sizeof...(_UElements), "tuple objects can only be compared if they have equal sizes.");
        using __compare = __tuple_compare<tuple<_TElements...>, tuple<_UElements...>, 0, sizeof...(_TElements)>;
        return __compare::__less(__t, __u);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator!=(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u)     {
        return !(__t == __u);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator>(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u)     {
        return __u < __t;
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator<=(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u)     {
        return !(__u < __t);
    }
    template <typename ..._TElements, typename ..._UElements> constexpr bool operator>=(const tuple<_TElements...> &__t, const tuple<_UElements...> &__u)     {
        return !(__t < __u);
    }
    template <typename ..._Elements> constexpr tuple<typename __decay_and_strip<_Elements>::__type...> make_tuple(_Elements &&...__args)     {
        typedef tuple<typename __decay_and_strip<_Elements>::__type...> __result_type;
        return __result_type(std::forward<_Elements>(__args)...);
    }
    template <typename ..._Elements> constexpr tuple<_Elements &&...> forward_as_tuple(_Elements &&...__args) noexcept     {
        return tuple<_Elements &&...>(std::forward<_Elements>(__args)...);
    }
    template <std::size_t, typename, typename, std::size_t> struct __make_tuple_impl;
    template <std::size_t _Idx, typename _Tuple, typename ..._Tp, std::size_t _Nm> struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm> : __make_tuple_impl<_Idx + 1, tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>, _Tuple, _Nm> {
    };
    template <std::size_t _Nm, typename _Tuple, typename ..._Tp> struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm> {
        typedef tuple<_Tp...> __type;
    };
    template <typename _Tuple> struct __do_make_tuple : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value> {
    };
    template <typename _Tuple> struct __make_tuple : public __do_make_tuple<__remove_cvref_t<_Tuple>> {
    };
    template <typename ...> struct __combine_tuples;
    template<> struct __combine_tuples<> {
        typedef tuple<> __type;
    };
    template <typename ..._Ts> struct __combine_tuples<tuple<_Ts...>> {
        typedef tuple<_Ts...> __type;
    };
    template <typename ..._T1s, typename ..._T2s, typename ..._Rem> struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...> {
        typedef typename __combine_tuples<tuple<_T1s..., _T2s...>, _Rem...>::__type __type;
    };
    template <typename ..._Tpls> struct __tuple_cat_result {
        typedef typename __combine_tuples<typename __make_tuple<_Tpls>::__type...>::__type __type;
    };
    template <typename ...> struct __make_1st_indices;
    template<> struct __make_1st_indices<> {
        typedef std::_Index_tuple<> __type;
    };
    template <typename _Tp, typename ..._Tpls> struct __make_1st_indices<_Tp, _Tpls...> {
        typedef typename std::_Build_index_tuple<std::tuple_size<typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };
    template <typename _Ret, typename _Indices, typename ..._Tpls> struct __tuple_concater;
    template <typename _Ret, std::size_t ..._Is, typename _Tp, typename ..._Tpls> struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...> {
        template <typename ..._Us> static constexpr _Ret _S_do(_Tp &&__tp, _Tpls &&...__tps, _Us &&...__us)         {
            typedef typename __make_1st_indices<_Tpls...>::__type __idx;
            typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
            return __next::_S_do(std::forward<_Tpls>(__tps)..., std::forward<_Us>(__us)..., std::get<_Is>(std::forward<_Tp>(__tp))...);
        }
    };
    template <typename _Ret> struct __tuple_concater<_Ret, std::_Index_tuple<>> {
        template <typename ..._Us> static constexpr _Ret _S_do(_Us &&...__us)         {
            return _Ret(std::forward<_Us>(__us)...);
        }
    };
    template <typename ..._Tpls, typename = typename enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type> constexpr auto tuple_cat(_Tpls &&...__tpls) -> typename __tuple_cat_result<_Tpls...>::__type     {
        typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
        typedef typename __make_1st_indices<_Tpls...>::__type __idx;
        typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
        return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }
    template <typename ..._Elements> constexpr tuple<_Elements &...> tie(_Elements &...__args) noexcept     {
        return tuple<_Elements &...>(__args...);
    }
    template <typename ..._Elements> inline typename enable_if<__and_<__is_swappable<_Elements>...>::value>::type swap(tuple<_Elements...> &__x, tuple<_Elements...> &__y) noexcept(noexcept(__x.swap(__y))swap(tuple<_Elements...> &__x, tuple<_Elements...> &__y) noexcept(noexcept(__x.swap(__y)))     {
        __x.swap(__y);
    }
    template <typename ..._Elements> typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type swap(tuple<_Elements...> &, tuple<_Elements...> &) = delete
    struct _Swallow_assign {
        template <class _Tp> constexpr const std::_Swallow_assign &operator=(const _Tp &) const         {
            return *this;
        }
    };
    constexpr std::_Swallow_assign ignore{};
    template <typename ..._Types, typename _Alloc> struct uses_allocator<tuple<_Types...>, _Alloc> : std::true_type {
    };
    template <class _T1, class _T2> template <typename ..._Args1, typename ..._Args2> inline pair<_T1, _T2>::pair<_T1, _T2>(std::piecewise_construct_t, tuple<_Args1...> __first, tuple<_Args2...> __second) : pair<_T1, _T2>(__first, __second, typename _Build_index_tuple<sizeof...(_Args1)>::__type(), typename _Build_index_tuple<sizeof...(_Args2)>::__type())     {
    }
    template <class _T1, class _T2> template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> inline pair<_T1, _T2>::pair<_T1, _T2>(tuple<_Args1...> &__tuple1, tuple<_Args2...> &__tuple2, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>) : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...), second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)     {
    }
    template <template <typename ...> class _Trait, typename _Tp, typename _Tuple> constexpr bool __unpack_std_tuple = false;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, _Up...>::value;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, _Up &...>::value;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, const _Up...>::value;
    constexpr bool __unpack_std_tuple = _Trait<_Tp, const _Up &...>::value;
    template <typename _Fn, typename _Tuple, std::size_t ..._Idx> constexpr decltype(auto) __apply_impl(_Fn &&__f, _Tuple &&__t, index_sequence<_Idx...>)     {
        return std::__invoke(std::forward<_Fn>(__f), std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }
    template <typename _Fn, typename _Tuple> constexpr decltype(auto) apply(_Fn &&__f, _Tuple &&__t) noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>apply(_Fn &&__f, _Tuple &&__t) noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>)     {
        using _Indices = make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
        return std::__apply_impl(std::forward<_Fn>(__f), std::forward<_Tuple>(__t), _Indices({}));
    }
    template <typename _Tp, typename _Tuple, std::size_t ..._Idx> constexpr _Tp __make_from_tuple_impl(_Tuple &&__t, index_sequence<_Idx...>)     {
        return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }
    template <typename _Tp, typename _Tuple> constexpr _Tp make_from_tuple(_Tuple &&__t) noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>make_from_tuple(_Tuple &&__t) noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>)     {
        return __make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>({}));
    }
}
namespace std {
    enum float_round_style {
        round_indeterminate = -1,
        round_toward_zero = 0,
        round_to_nearest = 1,
        round_toward_infinity = 2,
        round_toward_neg_infinity = 3
    };
    enum float_denorm_style {
        denorm_indeterminate = -1,
        denorm_absent = 0,
        denorm_present = 1
    };
    struct __numeric_limits_base {
        static constexpr bool is_specialized = false;
        static constexpr int digits = 0;
        static constexpr int digits10 = 0;
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = false;
        static constexpr bool is_exact = false;
        static constexpr int radix = 0;
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = false;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = false;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template <typename _Tp> struct numeric_limits : public std::__numeric_limits_base {
        static constexpr _Tp min() noexcept         {
            return _Tp();
        }
        static constexpr _Tp max() noexcept         {
            return _Tp();
        }
        static constexpr _Tp lowest() noexcept         {
            return _Tp();
        }
        static constexpr _Tp epsilon() noexcept         {
            return _Tp();
        }
        static constexpr _Tp round_error() noexcept         {
            return _Tp();
        }
        static constexpr _Tp infinity() noexcept         {
            return _Tp();
        }
        static constexpr _Tp quiet_NaN() noexcept         {
            return _Tp();
        }
        static constexpr _Tp signaling_NaN() noexcept         {
            return _Tp();
        }
        static constexpr _Tp denorm_min() noexcept         {
            return _Tp();
        }
    };
    template <typename _Tp> struct numeric_limits<const _Tp> : public numeric_limits<_Tp> {
    };
    template <typename _Tp> struct numeric_limits<volatile _Tp> : public numeric_limits<_Tp> {
    };
    template <typename _Tp> struct numeric_limits<const volatile _Tp> : public numeric_limits<_Tp> {
    };
    template<> struct numeric_limits<bool> {
        static constexpr bool is_specialized = true;
        static constexpr bool min() noexcept         {
            return false;
        }
        static constexpr bool max() noexcept         {
            return true;
        }
        static constexpr bool lowest() noexcept         {
            return min();
        }
        static constexpr int digits = 1;
        static constexpr int digits10 = 0;
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr bool epsilon() noexcept         {
            return false;
        }
        static constexpr bool round_error() noexcept         {
            return false;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr bool infinity() noexcept         {
            return false;
        }
        static constexpr bool quiet_NaN() noexcept         {
            return false;
        }
        static constexpr bool signaling_NaN() noexcept         {
            return false;
        }
        static constexpr bool denorm_min() noexcept         {
            return false;
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<char> {
        static constexpr bool is_specialized = true;
        static constexpr char min() noexcept         {
            return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0);
        }
        static constexpr char max() noexcept         {
            return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0);
        }
        static constexpr char lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
        static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = ((char)(-1) < 0);
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr char epsilon() noexcept         {
            return 0;
        }
        static constexpr char round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr char infinity() noexcept         {
            return char();
        }
        static constexpr char quiet_NaN() noexcept         {
            return char();
        }
        static constexpr char signaling_NaN() noexcept         {
            return char();
        }
        static constexpr char denorm_min() noexcept         {
            return static_cast<char>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = !is_signed;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<signed char> {
        static constexpr bool is_specialized = true;
        static constexpr signed char min() noexcept         {
            return -127 - 1;
        }
        static constexpr signed char max() noexcept         {
            return 127;
        }
        static constexpr signed char lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
        static constexpr int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr signed char epsilon() noexcept         {
            return 0;
        }
        static constexpr signed char round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr signed char infinity() noexcept         {
            return static_cast<signed char>(0);
        }
        static constexpr signed char quiet_NaN() noexcept         {
            return static_cast<signed char>(0);
        }
        static constexpr signed char signaling_NaN() noexcept         {
            return static_cast<signed char>(0);
        }
        static constexpr signed char denorm_min() noexcept         {
            return static_cast<signed char>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<unsigned char> {
        static constexpr bool is_specialized = true;
        static constexpr unsigned char min() noexcept         {
            return 0;
        }
        static constexpr unsigned char max() noexcept         {
            return 127 * 2U + 1;
        }
        static constexpr unsigned char lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
        static constexpr int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr unsigned char epsilon() noexcept         {
            return 0;
        }
        static constexpr unsigned char round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr unsigned char infinity() noexcept         {
            return static_cast<unsigned char>(0);
        }
        static constexpr unsigned char quiet_NaN() noexcept         {
            return static_cast<unsigned char>(0);
        }
        static constexpr unsigned char signaling_NaN() noexcept         {
            return static_cast<unsigned char>(0);
        }
        static constexpr unsigned char denorm_min() noexcept         {
            return static_cast<unsigned char>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = true;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<wchar_t> {
        static constexpr bool is_specialized = true;
        static constexpr wchar_t min() noexcept         {
            return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0);
        }
        static constexpr wchar_t max() noexcept         {
            return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0);
        }
        static constexpr wchar_t lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
        static constexpr int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = ((wchar_t)(-1) < 0);
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr wchar_t epsilon() noexcept         {
            return 0;
        }
        static constexpr wchar_t round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr wchar_t infinity() noexcept         {
            return wchar_t();
        }
        static constexpr wchar_t quiet_NaN() noexcept         {
            return wchar_t();
        }
        static constexpr wchar_t signaling_NaN() noexcept         {
            return wchar_t();
        }
        static constexpr wchar_t denorm_min() noexcept         {
            return wchar_t();
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = !is_signed;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<char16_t> {
        static constexpr bool is_specialized = true;
        static constexpr char16_t min() noexcept         {
            return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0);
        }
        static constexpr char16_t max() noexcept         {
            return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0);
        }
        static constexpr char16_t lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
        static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = ((char16_t)(-1) < 0);
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr char16_t epsilon() noexcept         {
            return 0;
        }
        static constexpr char16_t round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr char16_t infinity() noexcept         {
            return char16_t();
        }
        static constexpr char16_t quiet_NaN() noexcept         {
            return char16_t();
        }
        static constexpr char16_t signaling_NaN() noexcept         {
            return char16_t();
        }
        static constexpr char16_t denorm_min() noexcept         {
            return char16_t();
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = !is_signed;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<char32_t> {
        static constexpr bool is_specialized = true;
        static constexpr char32_t min() noexcept         {
            return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0);
        }
        static constexpr char32_t max() noexcept         {
            return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0);
        }
        static constexpr char32_t lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
        static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = ((char32_t)(-1) < 0);
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr char32_t epsilon() noexcept         {
            return 0;
        }
        static constexpr char32_t round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr char32_t infinity() noexcept         {
            return char32_t();
        }
        static constexpr char32_t quiet_NaN() noexcept         {
            return char32_t();
        }
        static constexpr char32_t signaling_NaN() noexcept         {
            return char32_t();
        }
        static constexpr char32_t denorm_min() noexcept         {
            return char32_t();
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = !is_signed;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<short> {
        static constexpr bool is_specialized = true;
        static constexpr short min() noexcept         {
            return -32767 - 1;
        }
        static constexpr short max() noexcept         {
            return 32767;
        }
        static constexpr short lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
        static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr short epsilon() noexcept         {
            return 0;
        }
        static constexpr short round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr short infinity() noexcept         {
            return short();
        }
        static constexpr short quiet_NaN() noexcept         {
            return short();
        }
        static constexpr short signaling_NaN() noexcept         {
            return short();
        }
        static constexpr short denorm_min() noexcept         {
            return short();
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<unsigned short> {
        static constexpr bool is_specialized = true;
        static constexpr unsigned short min() noexcept         {
            return 0;
        }
        static constexpr unsigned short max() noexcept         {
            return 32767 * 2U + 1;
        }
        static constexpr unsigned short lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
        static constexpr int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr unsigned short epsilon() noexcept         {
            return 0;
        }
        static constexpr unsigned short round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr unsigned short infinity() noexcept         {
            return static_cast<unsigned short>(0);
        }
        static constexpr unsigned short quiet_NaN() noexcept         {
            return static_cast<unsigned short>(0);
        }
        static constexpr unsigned short signaling_NaN() noexcept         {
            return static_cast<unsigned short>(0);
        }
        static constexpr unsigned short denorm_min() noexcept         {
            return static_cast<unsigned short>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = true;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<int> {
        static constexpr bool is_specialized = true;
        static constexpr int min() noexcept         {
            return -2147483647 - 1;
        }
        static constexpr int max() noexcept         {
            return 2147483647;
        }
        static constexpr int lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
        static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr int epsilon() noexcept         {
            return 0;
        }
        static constexpr int round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr int infinity() noexcept         {
            return static_cast<int>(0);
        }
        static constexpr int quiet_NaN() noexcept         {
            return static_cast<int>(0);
        }
        static constexpr int signaling_NaN() noexcept         {
            return static_cast<int>(0);
        }
        static constexpr int denorm_min() noexcept         {
            return static_cast<int>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<unsigned int> {
        static constexpr bool is_specialized = true;
        static constexpr unsigned int min() noexcept         {
            return 0;
        }
        static constexpr unsigned int max() noexcept         {
            return 2147483647 * 2U + 1;
        }
        static constexpr unsigned int lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
        static constexpr int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr unsigned int epsilon() noexcept         {
            return 0;
        }
        static constexpr unsigned int round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr unsigned int infinity() noexcept         {
            return static_cast<unsigned int>(0);
        }
        static constexpr unsigned int quiet_NaN() noexcept         {
            return static_cast<unsigned int>(0);
        }
        static constexpr unsigned int signaling_NaN() noexcept         {
            return static_cast<unsigned int>(0);
        }
        static constexpr unsigned int denorm_min() noexcept         {
            return static_cast<unsigned int>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = true;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<long> {
        static constexpr bool is_specialized = true;
        static constexpr long min() noexcept         {
            return -9223372036854775807L - 1;
        }
        static constexpr long max() noexcept         {
            return 9223372036854775807L;
        }
        static constexpr long lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
        static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr long epsilon() noexcept         {
            return 0;
        }
        static constexpr long round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr long infinity() noexcept         {
            return static_cast<long>(0);
        }
        static constexpr long quiet_NaN() noexcept         {
            return static_cast<long>(0);
        }
        static constexpr long signaling_NaN() noexcept         {
            return static_cast<long>(0);
        }
        static constexpr long denorm_min() noexcept         {
            return static_cast<long>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<unsigned long> {
        static constexpr bool is_specialized = true;
        static constexpr unsigned long min() noexcept         {
            return 0;
        }
        static constexpr unsigned long max() noexcept         {
            return 9223372036854775807L * 2UL + 1;
        }
        static constexpr unsigned long lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
        static constexpr int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr unsigned long epsilon() noexcept         {
            return 0;
        }
        static constexpr unsigned long round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr unsigned long infinity() noexcept         {
            return static_cast<unsigned long>(0);
        }
        static constexpr unsigned long quiet_NaN() noexcept         {
            return static_cast<unsigned long>(0);
        }
        static constexpr unsigned long signaling_NaN() noexcept         {
            return static_cast<unsigned long>(0);
        }
        static constexpr unsigned long denorm_min() noexcept         {
            return static_cast<unsigned long>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = true;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<long long> {
        static constexpr bool is_specialized = true;
        static constexpr long long min() noexcept         {
            return -9223372036854775807LL - 1;
        }
        static constexpr long long max() noexcept         {
            return 9223372036854775807LL;
        }
        static constexpr long long lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
        static constexpr int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr long long epsilon() noexcept         {
            return 0;
        }
        static constexpr long long round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr long long infinity() noexcept         {
            return static_cast<long long>(0);
        }
        static constexpr long long quiet_NaN() noexcept         {
            return static_cast<long long>(0);
        }
        static constexpr long long signaling_NaN() noexcept         {
            return static_cast<long long>(0);
        }
        static constexpr long long denorm_min() noexcept         {
            return static_cast<long long>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<unsigned long long> {
        static constexpr bool is_specialized = true;
        static constexpr unsigned long long min() noexcept         {
            return 0;
        }
        static constexpr unsigned long long max() noexcept         {
            return 9223372036854775807LL * 2ULL + 1;
        }
        static constexpr unsigned long long lowest() noexcept         {
            return min();
        }
        static constexpr int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
        static constexpr int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);
        static constexpr int max_digits10 = 0;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int radix = 2;
        static constexpr unsigned long long epsilon() noexcept         {
            return 0;
        }
        static constexpr unsigned long long round_error() noexcept         {
            return 0;
        }
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr std::float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr unsigned long long infinity() noexcept         {
            return static_cast<unsigned long long>(0);
        }
        static constexpr unsigned long long quiet_NaN() noexcept         {
            return static_cast<unsigned long long>(0);
        }
        static constexpr unsigned long long signaling_NaN() noexcept         {
            return static_cast<unsigned long long>(0);
        }
        static constexpr unsigned long long denorm_min() noexcept         {
            return static_cast<unsigned long long>(0);
        }
        static constexpr bool is_iec559 = false;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = true;
        static constexpr bool traps = true;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_toward_zero;
    };
    template<> struct numeric_limits<float> {
        static constexpr bool is_specialized = true;
        static constexpr float min() noexcept         {
            return 1.17549435E-38F;
        }
        static constexpr float max() noexcept         {
            return 3.40282347E+38F;
        }
        static constexpr float lowest() noexcept         {
            return -3.40282347E+38F;
        }
        static constexpr int digits = 24;
        static constexpr int digits10 = 6;
        static constexpr int max_digits10 = (2 + (24) * 643L / 2136);
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = false;
        static constexpr bool is_exact = false;
        static constexpr int radix = 2;
        static constexpr float epsilon() noexcept         {
            return 1.1920929E-7F;
        }
        static constexpr float round_error() noexcept         {
            return 0.5F;
        }
        static constexpr int min_exponent = (-125);
        static constexpr int min_exponent10 = (-37);
        static constexpr int max_exponent = 128;
        static constexpr int max_exponent10 = 38;
        static constexpr bool has_infinity = 1;
        static constexpr bool has_quiet_NaN = 1;
        static constexpr bool has_signaling_NaN = has_quiet_NaN;
        static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr float infinity() noexcept         {
            return __builtin_huge_valf();
        }
        static constexpr float quiet_NaN() noexcept         {
            return __builtin_nanf("");
        }
        static constexpr float signaling_NaN() noexcept         {
            return __builtin_nansf("");
        }
        static constexpr float denorm_min() noexcept         {
            return 1.40129846E-45F;
        }
        static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = false;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_to_nearest;
    };
    template<> struct numeric_limits<double> {
        static constexpr bool is_specialized = true;
        static constexpr double min() noexcept         {
            return 2.2250738585072014E-308;
        }
        static constexpr double max() noexcept         {
            return 1.7976931348623157E+308;
        }
        static constexpr double lowest() noexcept         {
            return -1.7976931348623157E+308;
        }
        static constexpr int digits = 53;
        static constexpr int digits10 = 15;
        static constexpr int max_digits10 = (2 + (53) * 643L / 2136);
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = false;
        static constexpr bool is_exact = false;
        static constexpr int radix = 2;
        static constexpr double epsilon() noexcept         {
            return 2.2204460492503131E-16;
        }
        static constexpr double round_error() noexcept         {
            return 0.5;
        }
        static constexpr int min_exponent = (-1021);
        static constexpr int min_exponent10 = (-307);
        static constexpr int max_exponent = 1024;
        static constexpr int max_exponent10 = 308;
        static constexpr bool has_infinity = 1;
        static constexpr bool has_quiet_NaN = 1;
        static constexpr bool has_signaling_NaN = has_quiet_NaN;
        static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr double infinity() noexcept         {
            return __builtin_huge_val();
        }
        static constexpr double quiet_NaN() noexcept         {
            return __builtin_nan("");
        }
        static constexpr double signaling_NaN() noexcept         {
            return __builtin_nans("");
        }
        static constexpr double denorm_min() noexcept         {
            return 4.9406564584124654E-324;
        }
        static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = false;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_to_nearest;
    };
    template<> struct numeric_limits<long double> {
        static constexpr bool is_specialized = true;
        static constexpr long double min() noexcept         {
            return 3.36210314311209350626E-4932L;
        }
        static constexpr long double max() noexcept         {
            return 1.18973149535723176502E+4932L;
        }
        static constexpr long double lowest() noexcept         {
            return -1.18973149535723176502E+4932L;
        }
        static constexpr int digits = 64;
        static constexpr int digits10 = 18;
        static constexpr int max_digits10 = (2 + (64) * 643L / 2136);
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = false;
        static constexpr bool is_exact = false;
        static constexpr int radix = 2;
        static constexpr long double epsilon() noexcept         {
            return 1.08420217248550443401E-19L;
        }
        static constexpr long double round_error() noexcept         {
            return 0.5L;
        }
        static constexpr int min_exponent = (-16381);
        static constexpr int min_exponent10 = (-4931);
        static constexpr int max_exponent = 16384;
        static constexpr int max_exponent10 = 4932;
        static constexpr bool has_infinity = 1;
        static constexpr bool has_quiet_NaN = 1;
        static constexpr bool has_signaling_NaN = has_quiet_NaN;
        static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr long double infinity() noexcept         {
            return __builtin_huge_vall();
        }
        static constexpr long double quiet_NaN() noexcept         {
            return __builtin_nanl("");
        }
        static constexpr long double signaling_NaN() noexcept         {
            return __builtin_nansl("");
        }
        static constexpr long double denorm_min() noexcept         {
            return 3.64519953188247460253E-4951L;
        }
        static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
        static constexpr bool is_bounded = true;
        static constexpr bool is_modulo = false;
        static constexpr bool traps = false;
        static constexpr bool tinyness_before = false;
        static constexpr std::float_round_style round_style = round_to_nearest;
    };
}
namespace std {
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> class _Hashtable
template<> class _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> : public __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>, public __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, public __detail::_Insert<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, public __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, public __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, private __detail::_Hashtable_alloc<__alloc_rebind<allocator<pair<const int, int>>, __detail::_Hash_node<pair<const int, int>, _Hashtable_traits<false, false, true>::__hash_cached::value>>> {
        static_assert(is_same<typename remove_cv<pair<const int, int>>::type, pair<const int, int>>::value, "unordered container must have a non-const, non-volatile value_type");
        static_assert(is_same<typename allocator<pair<const int, int>>::value_type, std::pair<const int, int>>{}, "unordered container must have the same value_type as its allocator");
        using __traits_type = std::__detail::_Hashtable_traits<false, false, true>;
        using __hash_cached = typename __traits_type::__hash_cached;
        using __node_type = __detail::_Hash_node<pair<const int, int>, __hash_cached::value>;
        using __node_alloc_type = __alloc_rebind<std::allocator<std::pair<const int, int>>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type>;
        using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;
        using __value_alloc_traits = typename __hashtable_alloc::__value_alloc_traits;
        using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;
        using __node_base = typename __hashtable_alloc::__node_base;
        using __bucket_type = typename __hashtable_alloc::__bucket_type;
    public:
        typedef int key_type;
        typedef std::pair<const int, int> value_type;
        typedef std::allocator<std::pair<const int, int>> allocator_type;
        typedef std::equal_to<int> key_equal;
        typedef typename __value_alloc_traits::pointer pointer;
        typedef typename __value_alloc_traits::const_pointer const_pointer;
        typedef std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &reference;
        typedef const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &const_reference;
    private:
        using __rehash_type = std::__detail::_Prime_rehash_policy;
        using __rehash_state = typename __rehash_type::_State;
        using __constant_iterators = typename __traits_type::__constant_iterators;
        using __unique_keys = typename __traits_type::__unique_keys;
        using __key_extract = typename std::conditional<__constant_iterators::value, __detail::_Identity, __detail::_Select1st>::type;
        using __hashtable_base = __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>;
        using __hash_code_base = typename __hashtable_base::__hash_code_base;
        using __hash_code = typename __hashtable_base::__hash_code;
        using __ireturn_type = typename __hashtable_base::__ireturn_type;
        using __map_base = __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>;
        using __rehash_base = __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>;
        using __eq_base = __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>;
        using __reuse_or_alloc_node_gen_t = __detail::_ReuseOrAllocNode<__node_alloc_type>;
        using __alloc_node_gen_t = __detail::_AllocNode<__node_alloc_type>;
        struct _Scoped_node;
        template <typename _Ht> static constexpr typename conditional<std::is_lvalue_reference<_Ht>::value, const value_type &, value_type &&>::type __fwd_value_for(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &__val) noexcept;
        template <typename _Cond> using __if_hash_cached = __or_<__not_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_cached>, _Cond>;
        template <typename _Cond> using __if_hash_not_cached = __or_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_cached, _Cond>;
        struct __hash_code_base_access : std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base {
            using __hash_code_base::_M_bucket_index;
        };
        static_assert(noexcept(declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &>()._M_bucket_index((const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *)nullptr, (std::size_t)0)), "Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept");
        static_assert(__if_hash_cached<is_default_constructible<_Mod_range_hashing>>::value, "Functor used to map hash code to bucket index must be default constructible");
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Map_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa> struct _Insert_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Constant_iteratorsa = _Traits::__constant_iterators::value> struct _Insert;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Equality;
    public:
        using size_type = typename __hashtable_base::size_type;
        using difference_type = typename __hashtable_base::difference_type;
        using iterator = typename __hashtable_base::iterator;
        using const_iterator = typename __hashtable_base::const_iterator;
        using local_iterator = typename __hashtable_base::local_iterator;
        using const_local_iterator = typename __hashtable_base::const_local_iterator;
        using node_type = _Node_handle<int, std::pair<const int, int>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_alloc_type>;
        using insert_return_type = _Node_insert_return<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type>;
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *_M_buckets;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_bucket_count;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base _M_before_begin;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_element_count;
        std::__detail::_Prime_rehash_policy _M_rehash_policy;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type _M_single_bucket;
        bool _M_uses_single_bucket(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *__bkts) const;
        bool _M_uses_single_bucket() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hashtable_alloc &_M_base_alloc();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *_M_allocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count);
        void _M_deallocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *__bkts, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count);
        void _M_deallocate_buckets();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *_M_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *_M_begin() const;
        template <typename _Ht> void _M_assign_elements(_Ht &&);
        template <typename _Ht, typename _NodeGenerator> void _M_assign(_Ht &&, const _NodeGenerator &);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&, std::true_type);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&, std::false_type);
        void _M_reset() noexcept;
        _Hashtable(const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__h, const std::equal_to<int> &__eq, const std::__detail::_Select1st &__exk, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
    public:
        _Hashtable() = default
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        template <typename _InputIterator> _Hashtable(_InputIterator __first, _InputIterator __last, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&) noexcept;
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        explicit _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        explicit _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        template <typename _InputIterator> _Hashtable(_InputIterator __f, _InputIterator __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        _Hashtable(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type> __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &operator=(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &operator=(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &operator=(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type> __l);
        ~_Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>() noexcept;
        void swap(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator begin() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator begin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator end() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator end() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator cbegin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator cend() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type size() const noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type get_allocator() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type max_size() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal key_eq() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type max_bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type bucket_size(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type bucket(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator cbegin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator cend(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        float load_factor() const noexcept;
        const std::__detail::_Prime_rehash_policy &__rehash_policy() const;
        void __rehash_policy(const std::__detail::_Prime_rehash_policy &__pol);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type count(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
        std::pair<iterator, iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k);
        std::pair<const_iterator, const_iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
    protected:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_bucket_index(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n) const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_bucket_index(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __c) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *_M_find_before_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *_M_find_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__key, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __c) const;
        void _M_insert_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *);
        void _M_remove_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__next_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __next_bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *_M_get_previous_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *__n);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert_unique_node(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __n_elt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert_multi_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__hint, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n);
        template <typename ..._Args> std::pair<iterator, bool> _M_emplace(std::true_type, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_emplace(std::false_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, std::true_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, std::false_type, _Args &&...__args);
        template <typename _Arg, typename _NodeGenerator> std::pair<iterator, bool> _M_insert(_Arg &&, const _NodeGenerator &, std::true_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, std::false_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, _Arg &&__arg, const _NodeGenerator &__node_gen, std::true_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, _Arg &&, const _NodeGenerator &, std::false_type);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_erase(std::true_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_erase(std::false_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *__prev_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n);
    public:
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__ireturn_type emplace(_Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator emplace_hint(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator __hint, _Args &&...__args);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator __it);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type erase(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator);
        void clear() noexcept;
        void rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::insert_return_type _M_reinsert_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type &&__nh);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_reinsert_node_multi(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator __hint, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type &&__nh);
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type _M_extract_node(std::size_t __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *__prev_n);
    public:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type extract(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator __pos);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type extract(const int &__k);
        template <typename _Compatible_Hashtable> void _M_merge_unique(_Compatible_Hashtable &__src) noexcept;
        template <typename _Compatible_Hashtable> void _M_merge_multi(_Compatible_Hashtable &__src) noexcept;
    private:
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count, std::true_type);
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count, std::false_type);
        void _M_rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__rehash_state &__state);
    }
template<> class _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> : public __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, false>>, public __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, public __detail::_Insert<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, public __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, public __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, private __detail::_Hashtable_alloc<__alloc_rebind<allocator<pair<const int, int>>, __detail::_Hash_node<pair<const int, int>, _Hashtable_traits<false, false, false>::__hash_cached::value>>> {
        static_assert(is_same<typename remove_cv<pair<const int, int>>::type, pair<const int, int>>::value, "unordered container must have a non-const, non-volatile value_type");
        static_assert(is_same<typename allocator<pair<const int, int>>::value_type, std::pair<const int, int>>{}, "unordered container must have the same value_type as its allocator");
        using __traits_type = std::__detail::_Hashtable_traits<false, false, false>;
        using __hash_cached = typename __traits_type::__hash_cached;
        using __node_type = __detail::_Hash_node<pair<const int, int>, __hash_cached::value>;
        using __node_alloc_type = __alloc_rebind<std::allocator<std::pair<const int, int>>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type>;
        using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;
        using __value_alloc_traits = typename __hashtable_alloc::__value_alloc_traits;
        using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;
        using __node_base = typename __hashtable_alloc::__node_base;
        using __bucket_type = typename __hashtable_alloc::__bucket_type;
    public:
        typedef int key_type;
        typedef std::pair<const int, int> value_type;
        typedef std::allocator<std::pair<const int, int>> allocator_type;
        typedef std::equal_to<int> key_equal;
        typedef typename __value_alloc_traits::pointer pointer;
        typedef typename __value_alloc_traits::const_pointer const_pointer;
        typedef std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &reference;
        typedef const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &const_reference;
    private:
        using __rehash_type = std::__detail::_Prime_rehash_policy;
        using __rehash_state = typename __rehash_type::_State;
        using __constant_iterators = typename __traits_type::__constant_iterators;
        using __unique_keys = typename __traits_type::__unique_keys;
        using __key_extract = typename std::conditional<__constant_iterators::value, __detail::_Identity, __detail::_Select1st>::type;
        using __hashtable_base = __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, false>>;
        using __hash_code_base = typename __hashtable_base::__hash_code_base;
        using __hash_code = typename __hashtable_base::__hash_code;
        using __ireturn_type = typename __hashtable_base::__ireturn_type;
        using __map_base = __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>;
        using __rehash_base = __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>;
        using __eq_base = __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>;
        using __reuse_or_alloc_node_gen_t = __detail::_ReuseOrAllocNode<__node_alloc_type>;
        using __alloc_node_gen_t = __detail::_AllocNode<__node_alloc_type>;
        struct _Scoped_node;
        template <typename _Ht> static constexpr typename conditional<std::is_lvalue_reference<_Ht>::value, const value_type &, value_type &&>::type __fwd_value_for(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &__val) noexcept;
        template <typename _Cond> using __if_hash_cached = __or_<__not_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_cached>, _Cond>;
        template <typename _Cond> using __if_hash_not_cached = __or_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_cached, _Cond>;
        struct __hash_code_base_access : std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base {
            using __hash_code_base::_M_bucket_index;
        };
        static_assert(noexcept(declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &>()._M_bucket_index((const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *)nullptr, (std::size_t)0)), "Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept");
        static_assert(__if_hash_cached<is_default_constructible<_Mod_range_hashing>>::value, "Functor used to map hash code to bucket index must be default constructible");
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Map_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa> struct _Insert_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Constant_iteratorsa = _Traits::__constant_iterators::value> struct _Insert;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Equality;
    public:
        using size_type = typename __hashtable_base::size_type;
        using difference_type = typename __hashtable_base::difference_type;
        using iterator = typename __hashtable_base::iterator;
        using const_iterator = typename __hashtable_base::const_iterator;
        using local_iterator = typename __hashtable_base::local_iterator;
        using const_local_iterator = typename __hashtable_base::const_local_iterator;
        using node_type = _Node_handle<int, std::pair<const int, int>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_alloc_type>;
        using insert_return_type = _Node_insert_return<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type>;
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *_M_buckets;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_bucket_count;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base _M_before_begin;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_element_count;
        std::__detail::_Prime_rehash_policy _M_rehash_policy;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type _M_single_bucket;
        bool _M_uses_single_bucket(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *__bkts) const;
        bool _M_uses_single_bucket() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hashtable_alloc &_M_base_alloc();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *_M_allocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count);
        void _M_deallocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *__bkts, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count);
        void _M_deallocate_buckets();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *_M_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *_M_begin() const;
        template <typename _Ht> void _M_assign_elements(_Ht &&);
        template <typename _Ht, typename _NodeGenerator> void _M_assign(_Ht &&, const _NodeGenerator &);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&, std::true_type);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&, std::false_type);
        void _M_reset() noexcept;
        _Hashtable(const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__h, const std::equal_to<int> &__eq, const std::__detail::_Select1st &__exk, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
    public:
        _Hashtable() = default
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        template <typename _InputIterator> _Hashtable(_InputIterator __first, _InputIterator __last, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&) noexcept;
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        explicit _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        explicit _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        template <typename _InputIterator> _Hashtable(_InputIterator __f, _InputIterator __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        _Hashtable(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type> __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &operator=(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &operator=(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &operator=(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type> __l);
        ~_Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>() noexcept;
        void swap(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator begin() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator begin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator end() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator end() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator cbegin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator cend() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type size() const noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type get_allocator() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type max_size() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal key_eq() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type max_bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type bucket_size(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type bucket(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator cbegin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator cend(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        float load_factor() const noexcept;
        const std::__detail::_Prime_rehash_policy &__rehash_policy() const;
        void __rehash_policy(const std::__detail::_Prime_rehash_policy &__pol);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type count(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
        std::pair<iterator, iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k);
        std::pair<const_iterator, const_iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
    protected:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_bucket_index(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n) const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_bucket_index(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __c) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *_M_find_before_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *_M_find_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__key, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __c) const;
        void _M_insert_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *);
        void _M_remove_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__next_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __next_bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *_M_get_previous_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *__n);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert_unique_node(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __n_elt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert_multi_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__hint, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n);
        template <typename ..._Args> std::pair<iterator, bool> _M_emplace(std::true_type, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_emplace(std::false_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, std::true_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, std::false_type, _Args &&...__args);
        template <typename _Arg, typename _NodeGenerator> std::pair<iterator, bool> _M_insert(_Arg &&, const _NodeGenerator &, std::true_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, std::false_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, _Arg &&__arg, const _NodeGenerator &__node_gen, std::true_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, _Arg &&, const _NodeGenerator &, std::false_type);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_erase(std::true_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_erase(std::false_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *__prev_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n);
    public:
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__ireturn_type emplace(_Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator emplace_hint(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator __hint, _Args &&...__args);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator __it);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type erase(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator);
        void clear() noexcept;
        void rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::insert_return_type _M_reinsert_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type &&__nh);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_reinsert_node_multi(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator __hint, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type &&__nh);
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type _M_extract_node(std::size_t __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *__prev_n);
    public:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type extract(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator __pos);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type extract(const int &__k);
        template <typename _Compatible_Hashtable> void _M_merge_unique(_Compatible_Hashtable &__src) noexcept;
        template <typename _Compatible_Hashtable> void _M_merge_multi(_Compatible_Hashtable &__src) noexcept;
    private:
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count, std::true_type);
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count, std::false_type);
        void _M_rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__rehash_state &__state);
    };
    namespace __detail {
        template <typename _Key, typename _Value, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _Traits> struct _Hashtable_base
template<> struct _Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>> : public _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, _Hashtable_traits<false, false, true>::__hash_cached::value>, private _Hashtable_ebo_helper<0, std::equal_to<int>> {
        public:
            typedef int key_type;
            typedef std::pair<const int, int> value_type;
            typedef std::equal_to<int> key_equal;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;
            using __traits_type = std::__detail::_Hashtable_traits<false, false, true>;
            using __hash_cached = typename __traits_type::__hash_cached;
            using __constant_iterators = typename __traits_type::__constant_iterators;
            using __unique_keys = typename __traits_type::__unique_keys;
            using __hash_code_base = _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, __hash_cached::value>;
            using __hash_code = typename __hash_code_base::__hash_code;
            using __node_type = typename __hash_code_base::__node_type;
            using iterator = __detail::_Node_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using const_iterator = __detail::_Node_const_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using local_iterator = __detail::_Local_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using const_local_iterator = __detail::_Local_const_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using __ireturn_type = typename std::conditional<__unique_keys::value, std::pair<iterator, bool>, iterator>::type;
        private:
            using _EqualEBO = _Hashtable_ebo_helper<0, std::equal_to<int>>;
            template <typename _NodeT> struct _Equal_hash_code;
        protected:
            _Hashtable_base() = default
            _Hashtable_base(const std::__detail::_Select1st &__ex, const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__hash, const std::equal_to<int> &__eq);
            bool _M_equals(const int &__k, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __c, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n) const;
            void _M_swap(std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>> &__x);
            const std::equal_to<int> &_M_eq() const;
        }
template<> struct _Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>> : public _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, _Hashtable_traits<false, false, false>::__hash_cached::value>, private _Hashtable_ebo_helper<0, std::equal_to<int>> {
        public:
            typedef int key_type;
            typedef std::pair<const int, int> value_type;
            typedef std::equal_to<int> key_equal;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;
            using __traits_type = std::__detail::_Hashtable_traits<false, false, false>;
            using __hash_cached = typename __traits_type::__hash_cached;
            using __constant_iterators = typename __traits_type::__constant_iterators;
            using __unique_keys = typename __traits_type::__unique_keys;
            using __hash_code_base = _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, __hash_cached::value>;
            using __hash_code = typename __hash_code_base::__hash_code;
            using __node_type = typename __hash_code_base::__node_type;
            using iterator = __detail::_Node_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using const_iterator = __detail::_Node_const_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using local_iterator = __detail::_Local_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using const_local_iterator = __detail::_Local_const_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using __ireturn_type = typename std::conditional<__unique_keys::value, std::pair<iterator, bool>, iterator>::type;
        private:
            using _EqualEBO = _Hashtable_ebo_helper<0, std::equal_to<int>>;
            template <typename _NodeT> struct _Equal_hash_code;
        protected:
            _Hashtable_base() = default
            _Hashtable_base(const std::__detail::_Select1st &__ex, const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__hash, const std::equal_to<int> &__eq);
            bool _M_equals(const int &__k, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __c, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n) const;
            void _M_swap(std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>> &__x);
            const std::equal_to<int> &_M_eq() const;
        };
        template <class _Iterator> inline typename std::iterator_traits<_Iterator>::difference_type __distance_fw(_Iterator __first, _Iterator __last, std::input_iterator_tag)         {
            return __first != __last ? 1 : 0;
        }
        template <class _Iterator> inline typename std::iterator_traits<_Iterator>::difference_type __distance_fw(_Iterator __first, _Iterator __last, std::forward_iterator_tag)         {
            return std::distance(__first, __last);
        }
        template <class _Iterator> inline typename std::iterator_traits<_Iterator>::difference_type __distance_fw(_Iterator __first, _Iterator __last)         {
            return __distance_fw(__first, __last, std::__iterator_category(__first));
        }
        struct _Identity {
            template <typename _Tp> _Tp &&operator()(_Tp &&__x) const             {
                return std::forward<_Tp>(__x);
            }
        };
        struct _Select1st {
            template <typename _Tp> auto operator()(_Tp &&__x) const -> decltype(std::get<0>(std::forward<_Tp>(__x)))             {
                return std::get<0>(std::forward<_Tp>(__x));
            }
        };
        template <typename _NodeAlloc> struct _Hashtable_alloc
template<> struct _Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> : private _Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> {
        private:
            using __ebo_node_alloc = _Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>;
        public:
            using __node_type = typename allocator<_Hash_node<pair<const int, int>, false>>::value_type;
            using __node_alloc_type = std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>;
            using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;
            using __value_alloc_traits = typename __node_alloc_traits::rebind_traits<typename __node_type::value_type>;
            using __node_base = __detail::_Hash_node_base;
            using __bucket_type = std::__detail::_Hashtable_alloc::__node_base *;
            using __bucket_alloc_type = __alloc_rebind<std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_alloc_type, std::__detail::_Hashtable_alloc::__bucket_type>;
            using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;
            _Hashtable_alloc() = default
            _Hashtable_alloc(const std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> &) = default
            _Hashtable_alloc(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> &&) = default
            template <typename _Alloc> _Hashtable_alloc(_Alloc &&__a);
            std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_alloc_type &_M_node_allocator();
            const std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_alloc_type &_M_node_allocator() const;
            template <typename ..._Args> std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *_M_allocate_node(_Args &&...__args);
            void _M_deallocate_node(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *__n);
            void _M_deallocate_node_ptr(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *__n);
            void _M_deallocate_nodes(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *__n);
            std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__bucket_type *_M_allocate_buckets(std::size_t __bkt_count);
            void _M_deallocate_buckets(std::__detail::_Hashtable_alloc::__bucket_type *, std::size_t __bkt_count);
        };
        template <typename _NodeAlloc> struct _ReuseOrAllocNode {
        private:
            using __node_alloc_type = _NodeAlloc;
            using __hashtable_alloc = _Hashtable_alloc<std::__detail::_ReuseOrAllocNode::__node_alloc_type>;
            using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;
            using __node_type = typename __hashtable_alloc::__node_type;
        public:
            _ReuseOrAllocNode<_NodeAlloc>(std::__detail::_ReuseOrAllocNode::__node_type *__nodes, std::__detail::_ReuseOrAllocNode::__hashtable_alloc &__h) : _M_nodes(__nodes), _M_h(__h)             {
            }
            _ReuseOrAllocNode<_NodeAlloc>(const _ReuseOrAllocNode<_NodeAlloc> &) = delete
            ~_ReuseOrAllocNode<_NodeAlloc>()             {
                this->_M_h._M_deallocate_nodes(this->_M_nodes);
            }
            template <typename _Arg> std::__detail::_ReuseOrAllocNode::__node_type *operator()(_Arg &&__arg) const             {
                if (this->_M_nodes) {
                    std::__detail::_ReuseOrAllocNode::__node_type *__node = this->_M_nodes;
                    this->_M_nodes = this->_M_nodes->_M_next();
                    __node->_M_nxt = nullptr;
                    auto &__a = this->_M_h._M_node_allocator();
                    __node_alloc_traits::destroy(__a, __node->_M_valptr());
                    try {
                        __node_alloc_traits::construct(__a, __node->_M_valptr(), std::forward<_Arg>(__arg));
                    } catch (...) {
                        this->_M_h._M_deallocate_node_ptr(__node);
                        throw;
                    }
                    return __node;
                }
                return this->_M_h._M_allocate_node(std::forward<_Arg>(__arg));
            }
        private:
            mutable std::__detail::_ReuseOrAllocNode::__node_type *_M_nodes;
            std::__detail::_ReuseOrAllocNode::__hashtable_alloc &_M_h;
        };
        template <typename _NodeAlloc> struct _AllocNode {
        private:
            using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
            using __node_type = typename __hashtable_alloc::__node_type;
        public:
            _AllocNode<_NodeAlloc>(std::__detail::_AllocNode::__hashtable_alloc &__h) : _M_h(__h)             {
            }
            template <typename _Arg> std::__detail::_AllocNode::__node_type *operator()(_Arg &&__arg) const             {
                return this->_M_h._M_allocate_node(std::forward<_Arg>(__arg));
            }
        private:
            std::__detail::_AllocNode::__hashtable_alloc &_M_h;
        };
        template <bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys> struct _Hashtable_traits {
            using __hash_cached = __bool_constant<_Cache_hash_code>;
            using __constant_iterators = __bool_constant<_Constant_iterators>;
            using __unique_keys = __bool_constant<_Unique_keys>;
        };
template<> struct _Hashtable_traits<false, false, true> {
            using __hash_cached = __bool_constant<false>;
            using __constant_iterators = __bool_constant<false>;
            using __unique_keys = __bool_constant<true>;
        };
template<> struct _Hashtable_traits<false, false, false> {
            using __hash_cached = __bool_constant<false>;
            using __constant_iterators = __bool_constant<false>;
            using __unique_keys = __bool_constant<false>;
        };
        struct _Hash_node_base {
            std::__detail::_Hash_node_base *_M_nxt;
            _Hash_node_base() noexcept : _M_nxt(/*implicit*/(std::__detail::_Hash_node_base *)0)             {
            }
            _Hash_node_base(std::__detail::_Hash_node_base *__next) noexcept : _M_nxt(__next)             {
            }
        };
        template <typename _Value> struct _Hash_node_value_base : std::__detail::_Hash_node_base {
            typedef _Value value_type;
            __gnu_cxx::__aligned_buffer<_Value> _M_storage;
            _Value *_M_valptr() noexcept             {
                return this->_M_storage._M_ptr();
            }
            const _Value *_M_valptr() const noexcept             {
                return this->_M_storage._M_ptr();
            }
            _Value &_M_v() noexcept             {
                return *_M_valptr();
            }
            const _Value &_M_v() const noexcept             {
                return *_M_valptr();
            }
        };
template<> struct _Hash_node_value_base<std::pair<const int, int>> : std::__detail::_Hash_node_base {
            typedef std::pair<const int, int> value_type;
            __gnu_cxx::__aligned_buffer<pair<const int, int>> _M_storage;
            std::pair<const int, int> *_M_valptr() noexcept;
            const std::pair<const int, int> *_M_valptr() const noexcept;
            std::pair<const int, int> &_M_v() noexcept;
            const std::pair<const int, int> &_M_v() const noexcept;
        };
        template <typename _Value, bool _Cache_hash_code> struct _Hash_node
template<> struct _Hash_node<std::pair<const int, int>, false> : _Hash_node_value_base<std::pair<const int, int>> {
            std::__detail::_Hash_node<std::pair<const int, int>, false> *_M_next() const noexcept;
        };
        template <typename _Value> struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value> {
            std::size_t _M_hash_code;
            _Hash_node<type-parameter-0-0, true> *_M_next() const noexcept             {
                return static_cast<_Hash_node<type-parameter-0-0, true> *>(this->_M_nxt);
            }
        };
        template <typename _Value> struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value> {
            _Hash_node<type-parameter-0-0, false> *_M_next() const noexcept             {
                return static_cast<_Hash_node<type-parameter-0-0, false> *>(this->_M_nxt);
            }
        };
        template <typename _Value, bool _Cache_hash_code> struct _Node_iterator_base {
            using __node_type = _Hash_node<_Value, _Cache_hash_code>;
            std::__detail::_Node_iterator_base::__node_type *_M_cur;
            _Node_iterator_base<_Value, _Cache_hash_code>(std::__detail::_Node_iterator_base::__node_type *__p) noexcept : _M_cur(__p)             {
            }
            void _M_incr() noexcept             {
                this->_M_cur = this->_M_cur->_M_next();
            }
        };
        template <typename _Value, bool _Cache_hash_code> inline bool operator==(const _Node_iterator_base<_Value, _Cache_hash_code> &__x, const _Node_iterator_base<_Value, _Cache_hash_code> &__y) noexcept         {
            return __x._M_cur == __y._M_cur;
        }
        template <typename _Value, bool _Cache_hash_code> inline bool operator!=(const _Node_iterator_base<_Value, _Cache_hash_code> &__x, const _Node_iterator_base<_Value, _Cache_hash_code> &__y) noexcept         {
            return __x._M_cur != __y._M_cur;
        }
        template <typename _Value, bool __constant_iterators, bool __cache> struct _Node_iterator : public _Node_iterator_base<_Value, __cache> {
        private:
            using __base_type = _Node_iterator_base<_Value, __cache>;
            using __node_type = typename __base_type::__node_type;
        public:
            typedef _Value value_type;
            typedef std::ptrdiff_t difference_type;
            typedef std::forward_iterator_tag iterator_category;
            using pointer = typename std::conditional<__constant_iterators, const _Value *, _Value *>::type;
            using reference = typename std::conditional<__constant_iterators, const _Value &, _Value &>::type;
            _Node_iterator<_Value, __constant_iterators, __cache>() noexcept : std::__detail::_Node_iterator::__base_type(0)             {
            }
            explicit _Node_iterator<_Value, __constant_iterators, __cache>(std::__detail::_Node_iterator::__node_type *__p) noexcept : std::__detail::_Node_iterator::__base_type(__p)             {
            }
            std::__detail::_Node_iterator::reference operator*() const noexcept             {
                return this->_M_cur->_M_v();
            }
            std::__detail::_Node_iterator::pointer operator->() const noexcept             {
                return this->_M_cur->_M_valptr();
            }
            _Node_iterator<_Value, __constant_iterators, __cache> &operator++() noexcept             {
                this->_M_incr();
                return *this;
            }
            _Node_iterator<_Value, __constant_iterators, __cache> operator++(int) noexcept             {
                _Node_iterator<_Value, __constant_iterators, __cache> __tmp(*this);
                this->_M_incr();
                return __tmp;
            }
        };
        template <typename _Value, bool __constant_iterators, bool __cache> struct _Node_const_iterator : public _Node_iterator_base<_Value, __cache> {
        private:
            using __base_type = _Node_iterator_base<_Value, __cache>;
            using __node_type = typename __base_type::__node_type;
        public:
            typedef _Value value_type;
            typedef std::ptrdiff_t difference_type;
            typedef std::forward_iterator_tag iterator_category;
            typedef const _Value *pointer;
            typedef const _Value &reference;
            _Node_const_iterator<_Value, __constant_iterators, __cache>() noexcept : std::__detail::_Node_const_iterator::__base_type(0)             {
            }
            explicit _Node_const_iterator<_Value, __constant_iterators, __cache>(std::__detail::_Node_const_iterator::__node_type *__p) noexcept : std::__detail::_Node_const_iterator::__base_type(__p)             {
            }
            _Node_const_iterator<_Value, __constant_iterators, __cache>(const _Node_iterator<_Value, __constant_iterators, __cache> &__x) noexcept : std::__detail::_Node_const_iterator::__base_type(__x._M_cur)             {
            }
            std::__detail::_Node_const_iterator::reference operator*() const noexcept             {
                return this->_M_cur->_M_v();
            }
            std::__detail::_Node_const_iterator::pointer operator->() const noexcept             {
                return this->_M_cur->_M_valptr();
            }
            _Node_const_iterator<_Value, __constant_iterators, __cache> &operator++() noexcept             {
                this->_M_incr();
                return *this;
            }
            _Node_const_iterator<_Value, __constant_iterators, __cache> operator++(int) noexcept             {
                _Node_const_iterator<_Value, __constant_iterators, __cache> __tmp(*this);
                this->_M_incr();
                return __tmp;
            }
        };
        struct _Mod_range_hashing {
            typedef std::size_t first_argument_type;
            typedef std::size_t second_argument_type;
            typedef std::size_t result_type;
            std::__detail::_Mod_range_hashing::result_type operator()(std::__detail::_Mod_range_hashing::first_argument_type __num, std::__detail::_Mod_range_hashing::second_argument_type __den) const noexcept             {
                return __num % __den;
            }
        };
        struct _Default_ranged_hash {
        };
        struct _Prime_rehash_policy {
            using __has_load_factor = std::true_type;
            _Prime_rehash_policy(float __z = 1.) noexcept : _M_max_load_factor(__z), _M_next_resize(0)             {
            }
            float max_load_factor() const noexcept             {
                return this->_M_max_load_factor;
            }
            std::size_t _M_next_bkt(std::size_t __n) const;
            std::size_t _M_bkt_for_elements(std::size_t __n) const             {
                return __builtin_ceill(__n / (long double)this->_M_max_load_factor);
            }
            std::pair<bool, std::size_t> _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt, std::size_t __n_ins) const;
            typedef std::size_t _State;
            std::__detail::_Prime_rehash_policy::_State _M_state() const             {
                return this->_M_next_resize;
            }
            void _M_reset() noexcept             {
                this->_M_next_resize = 0;
            }
            void _M_reset(std::__detail::_Prime_rehash_policy::_State __state)             {
                this->_M_next_resize = __state;
            }
            static const std::size_t _S_growth_factor = 2;
            float _M_max_load_factor;
            mutable std::size_t _M_next_resize;
        };
        struct _Mask_range_hashing {
            typedef std::size_t first_argument_type;
            typedef std::size_t second_argument_type;
            typedef std::size_t result_type;
            std::__detail::_Mask_range_hashing::result_type operator()(std::__detail::_Mask_range_hashing::first_argument_type __num, std::__detail::_Mask_range_hashing::second_argument_type __den) const noexcept             {
                return __num & (__den - 1);
            }
        };
        inline std::size_t __clp2(std::size_t __n) noexcept         {
            if (__n < 2)
                return __n;
            const unsigned int __lz = sizeof(std::size_t) > sizeof(long) ? __builtin_clzll(__n - 1ULL) : __builtin_clzl(__n - 1UL);
            return (std::size_t(1) << (numeric_limits<size_t>::digits - __lz - 1)) << 1;
        }
        struct _Power2_rehash_policy {
            using __has_load_factor = std::true_type;
            _Power2_rehash_policy(float __z = 1.) noexcept : _M_max_load_factor(__z), _M_next_resize(0)             {
            }
            float max_load_factor() const noexcept             {
                return this->_M_max_load_factor;
            }
            std::size_t _M_next_bkt(std::size_t __n) noexcept             {
                if (__n == 0)
                    return 1;
                const auto __max_width = std::min<std::size_t>(sizeof(std::size_t), 8);
                const auto __max_bkt = std::size_t(1) << (__max_width * 8 - 1);
                std::size_t __res = __clp2(__n);
                if (__res == 0)
                    __res = __max_bkt;
                else if (__res == 1)
                    __res = 2;
                if (__res == __max_bkt)
                    this->_M_next_resize = numeric_limits<size_t>::max();
                else
                    this->_M_next_resize = __builtin_floorl(__res * (long double)this->_M_max_load_factor);
                return __res;
            }
            std::size_t _M_bkt_for_elements(std::size_t __n) const noexcept             {
                return __builtin_ceill(__n / (long double)this->_M_max_load_factor);
            }
            std::pair<bool, std::size_t> _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt, std::size_t __n_ins) noexcept             {
                if (__n_elt + __n_ins > this->_M_next_resize) {
                    long double __min_bkts = std::max<std::size_t>(__n_elt + __n_ins, this->_M_next_resize ? 0 : 11) / (long double)this->_M_max_load_factor;
                    if (__min_bkts >= __n_bkt)
                        return {true, this->_M_next_bkt(std::max<std::size_t>(__builtin_floorl(__min_bkts) + 1, __n_bkt * _S_growth_factor))};
                    this->_M_next_resize = __builtin_floorl(__n_bkt * (long double)this->_M_max_load_factor);
                    return {false, 0};
                } else
                    return {false, 0};
            }
            typedef std::size_t _State;
            std::__detail::_Power2_rehash_policy::_State _M_state() const noexcept             {
                return this->_M_next_resize;
            }
            void _M_reset() noexcept             {
                this->_M_next_resize = 0;
            }
            void _M_reset(std::__detail::_Power2_rehash_policy::_State __state) noexcept             {
                this->_M_next_resize = __state;
            }
            static const std::size_t _S_growth_factor = 2;
            float _M_max_load_factor;
            std::size_t _M_next_resize;
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits, bool _Unique_keys = _Traits::__unique_keys::value> struct _Map_base {
        };
template<> struct _Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true> {
        private:
            using __hashtable_base = __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>;
            using __hashtable = _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>;
            using __hash_code = typename __hashtable_base::__hash_code;
            using __node_type = typename __hashtable_base::__node_type;
        public:
            using key_type = typename __hashtable_base::key_type;
            using iterator = typename __hashtable_base::iterator;
            using mapped_type = typename std::tuple_element<1, pair<const int, int>>::type;
            std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::mapped_type &operator[](const std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::key_type &__k);
            std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::mapped_type &operator[](std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::key_type &&__k);
            std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::mapped_type &at(const std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::key_type &__k);
            const std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::mapped_type &at(const std::__detail::_Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::key_type &__k) const;
        };
template<> struct _Map_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, false> {
            using mapped_type = typename std::tuple_element<1, pair<const int, int>>::type;
        };
        template <typename _Key, typename _Pair, typename _Alloc, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Map_base<_Key, _Pair, _Alloc, std::__detail::_Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false> {
            using mapped_type = typename std::tuple_element<1, _Pair>::type;
        };
        template <typename _Key, typename _Pair, typename _Alloc, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Map_base<_Key, _Pair, _Alloc, std::__detail::_Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> {
        private:
            using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits>;
            using __hashtable = _Hashtable<_Key, _Pair, _Alloc, std::__detail::_Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
            using __hash_code = typename __hashtable_base::__hash_code;
            using __node_type = typename __hashtable_base::__node_type;
        public:
            using key_type = typename __hashtable_base::key_type;
            using iterator = typename __hashtable_base::iterator;
            using mapped_type = typename std::tuple_element<1, _Pair>::type;
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &operator[](const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &__k);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &operator[](std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &&__k);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &at(const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &__k);
            const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &at(const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &__k) const;
        };
        template <typename _Key, typename _Pair, typename _Alloc, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::operator[](const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &__k) -> std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &         {
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *__h = static_cast<std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *>(this);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hash_code __code = __h->_M_hash_code(__k);
            std::size_t __bkt = __h->_M_bucket_index(__k, __code);
            if (std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__node_type *__node = __h->_M_find_node(__bkt, __k, __code))
                return __node->_M_v().second;
            typename __hashtable::_Scoped_node __node{__h, std::piecewise_construct, std::tuple<const key_type &>(__k), std::tuple<>()};
            auto __pos = __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);
            __node._M_node = nullptr;
            return __pos->second;
        }
        template <typename _Key, typename _Pair, typename _Alloc, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::operator[](std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &&__k) -> std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &         {
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *__h = static_cast<std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *>(this);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hash_code __code = __h->_M_hash_code(__k);
            std::size_t __bkt = __h->_M_bucket_index(__k, __code);
            if (std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__node_type *__node = __h->_M_find_node(__bkt, __k, __code))
                return __node->_M_v().second;
            typename __hashtable::_Scoped_node __node{__h, std::piecewise_construct, std::forward_as_tuple(std::move(__k)), std::tuple<>()};
            auto __pos = __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);
            __node._M_node = nullptr;
            return __pos->second;
        }
        template <typename _Key, typename _Pair, typename _Alloc, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::at(const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &__k) -> std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &         {
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *__h = static_cast<std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *>(this);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hash_code __code = __h->_M_hash_code(__k);
            std::size_t __bkt = __h->_M_bucket_index(__k, __code);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__node_type *__p = __h->_M_find_node(__bkt, __k, __code);
            if (!__p)
                __throw_out_of_range(("_Map_base::at"));
            return __p->_M_v().second;
        }
        template <typename _Key, typename _Pair, typename _Alloc, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::at(const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::key_type &__k) const -> const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::mapped_type &         {
            const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *__h = static_cast<const std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hashtable *>(this);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__hash_code __code = __h->_M_hash_code(__k);
            std::size_t __bkt = __h->_M_bucket_index(__k, __code);
            std::__detail::_Map_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, std::__detail::_Select1st, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, true>::__node_type *__p = __h->_M_find_node(__bkt, __k, __code);
            if (!__p)
                __throw_out_of_range(("_Map_base::at"));
            return __p->_M_v().second;
        }
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Insert_base {
        protected:
            using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
            using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>;
            using value_type = typename __hashtable_base::value_type;
            using iterator = typename __hashtable_base::iterator;
            using const_iterator = typename __hashtable_base::const_iterator;
            using size_type = typename __hashtable_base::size_type;
            using __unique_keys = typename __hashtable_base::__unique_keys;
            using __ireturn_type = typename __hashtable_base::__ireturn_type;
            using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
            using __node_alloc_type = __alloc_rebind<_Alloc, std::__detail::_Insert_base::__node_type>;
            using __node_gen_type = _AllocNode<std::__detail::_Insert_base::__node_alloc_type>;
            std::__detail::_Insert_base::__hashtable &_M_conjure_hashtable()             {
                return *(static_cast<std::__detail::_Insert_base::__hashtable *>(this));
            }
            template <typename _InputIterator, typename _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, std::true_type);
            template <typename _InputIterator, typename _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, std::false_type);
        public:
            std::__detail::_Insert_base::__ireturn_type insert(const std::__detail::_Insert_base::value_type &__v)             {
                std::__detail::_Insert_base::__hashtable &__h = this->_M_conjure_hashtable();
                std::__detail::_Insert_base::__node_gen_type __node_gen(__h);
                return __h._M_insert(__v, __node_gen, std::__detail::_Insert_base::__unique_keys());
            }
            std::__detail::_Insert_base::iterator insert(std::__detail::_Insert_base::const_iterator __hint, const std::__detail::_Insert_base::value_type &__v)             {
                std::__detail::_Insert_base::__hashtable &__h = this->_M_conjure_hashtable();
                std::__detail::_Insert_base::__node_gen_type __node_gen(__h);
                return __h._M_insert(__hint, __v, __node_gen, std::__detail::_Insert_base::__unique_keys());
            }
            void insert(initializer_list<std::__detail::_Insert_base::value_type> __l)             {
                this->insert(__l.begin(), __l.end());
            }
            template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last)             {
                std::__detail::_Insert_base::__hashtable &__h = this->_M_conjure_hashtable();
                std::__detail::_Insert_base::__node_gen_type __node_gen(__h);
                return _M_insert_range(__first, __last, __node_gen, std::__detail::_Insert_base::__unique_keys());
            }
        };
template<> struct _Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> {
        protected:
            using __hashtable = _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>;
            using __hashtable_base = _Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>>;
            using value_type = typename __hashtable_base::value_type;
            using iterator = typename __hashtable_base::iterator;
            using const_iterator = typename __hashtable_base::const_iterator;
            using size_type = typename __hashtable_base::size_type;
            using __unique_keys = typename __hashtable_base::__unique_keys;
            using __ireturn_type = typename __hashtable_base::__ireturn_type;
            using __node_type = _Hash_node<std::pair<const int, int>, _Hashtable_traits<false, false, true>::__hash_cached::value>;
            using __node_alloc_type = __alloc_rebind<std::allocator<std::pair<const int, int>>, std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type>;
            using __node_gen_type = _AllocNode<std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_alloc_type>;
            std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hashtable &_M_conjure_hashtable();
            template <typename _InputIterator, typename _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, std::true_type);
            template <typename _InputIterator, typename _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, std::false_type);
        public:
            std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__ireturn_type insert(const std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &__v);
            std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator insert(std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator __hint, const std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &__v);
            void insert(initializer_list<std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type> __l);
            template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last);
        };
template<> struct _Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> {
        protected:
            using __hashtable = _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>;
            using __hashtable_base = _Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>>;
            using value_type = typename __hashtable_base::value_type;
            using iterator = typename __hashtable_base::iterator;
            using const_iterator = typename __hashtable_base::const_iterator;
            using size_type = typename __hashtable_base::size_type;
            using __unique_keys = typename __hashtable_base::__unique_keys;
            using __ireturn_type = typename __hashtable_base::__ireturn_type;
            using __node_type = _Hash_node<std::pair<const int, int>, _Hashtable_traits<false, false, false>::__hash_cached::value>;
            using __node_alloc_type = __alloc_rebind<std::allocator<std::pair<const int, int>>, std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type>;
            using __node_gen_type = _AllocNode<std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_alloc_type>;
            std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hashtable &_M_conjure_hashtable();
            template <typename _InputIterator, typename _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, std::true_type);
            template <typename _InputIterator, typename _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, std::false_type);
        public:
            std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__ireturn_type insert(const std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &__v);
            std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator insert(std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator __hint, const std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &__v);
            void insert(initializer_list<std::__detail::_Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type> __l);
            template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last);
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename _InputIterator, typename _NodeGetter> void _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &__node_gen, std::true_type)         {
            std::__detail::_Insert_base::size_type __n_elt = __detail::__distance_fw(__first, __last);
            if (__n_elt == 0)
                return;
            std::__detail::_Insert_base::__hashtable &__h = this->_M_conjure_hashtable();
            for (; __first != __last; ++__first) {
                if (__h._M_insert(*__first, __node_gen, std::__detail::_Insert_base::__unique_keys(), __n_elt).second)
                    __n_elt = 1;
                else if (__n_elt != 1)
                    --__n_elt;
            }
        }
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename _InputIterator, typename _NodeGetter> void _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &__node_gen, std::false_type)         {
            using __rehash_type = typename __hashtable::__rehash_type;
            using __rehash_state = typename __hashtable::__rehash_state;
            using pair_type = std::pair<bool, std::size_t>;
            std::__detail::_Insert_base::size_type __n_elt = __detail::__distance_fw(__first, __last);
            if (__n_elt == 0)
                return;
            std::__detail::_Insert_base::__hashtable &__h = this->_M_conjure_hashtable();
            __rehash_type &__rehash = __h._M_rehash_policy;
            const __rehash_state &__saved_state = __rehash._M_state();
            pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count, __h._M_element_count, __n_elt);
            if (__do_rehash.first)
                __h._M_rehash(__do_rehash.second, __saved_state);
            for (; __first != __last; ++__first)
                __h._M_insert(*__first, __node_gen, std::__detail::_Insert_base::__unique_keys());
        }
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits, bool _Constant_iterators = _Traits::__constant_iterators::value> struct _Insert
template<> struct _Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, false> : public _Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> {
            using __base_type = _Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>;
            using value_type = typename __base_type::value_type;
            using iterator = typename __base_type::iterator;
            using const_iterator = typename __base_type::const_iterator;
            using __unique_keys = typename __base_type::__unique_keys;
            using __hashtable = typename __base_type::__hashtable;
            using __ireturn_type = typename __base_type::__ireturn_type;
            using __base_type::insert;
            template <typename _Pair> using __is_cons = std::is_constructible<value_type, _Pair &&>;
            template <typename _Pair> using _IFcons = std::enable_if<__is_cons<_Pair>::value>;
            template <typename _Pair> using _IFconsp = typename _IFcons<_Pair>::type;
            template <typename _Pair, typename = _IFconsp<_Pair>> std::__detail::_Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, false>::__ireturn_type insert(_Pair &&__v);
            template <typename _Pair, typename = _IFconsp<_Pair>> std::__detail::_Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, false>::iterator insert(std::__detail::_Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, false>::const_iterator __hint, _Pair &&__v);
        }
template<> struct _Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, false> : public _Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> {
            using __base_type = _Insert_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>;
            using value_type = typename __base_type::value_type;
            using iterator = typename __base_type::iterator;
            using const_iterator = typename __base_type::const_iterator;
            using __unique_keys = typename __base_type::__unique_keys;
            using __hashtable = typename __base_type::__hashtable;
            using __ireturn_type = typename __base_type::__ireturn_type;
            using __base_type::insert;
            template <typename _Pair> using __is_cons = std::is_constructible<value_type, _Pair &&>;
            template <typename _Pair> using _IFcons = std::enable_if<__is_cons<_Pair>::value>;
            template <typename _Pair> using _IFconsp = typename _IFcons<_Pair>::type;
            template <typename _Pair, typename = _IFconsp<_Pair>> std::__detail::_Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, false>::__ireturn_type insert(_Pair &&__v);
            template <typename _Pair, typename = _IFconsp<_Pair>> std::__detail::_Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, false>::iterator insert(std::__detail::_Insert<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, false>::const_iterator __hint, _Pair &&__v);
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> {
            using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
            using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>;
            using value_type = typename __base_type::value_type;
            using iterator = typename __base_type::iterator;
            using const_iterator = typename __base_type::const_iterator;
            using __unique_keys = typename __base_type::__unique_keys;
            using __ireturn_type = typename __hashtable_base::__ireturn_type;
            using __hashtable = typename __base_type::__hashtable;
            using __node_gen_type = typename __base_type::__node_gen_type;
            using __base_type::insert;
            std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__ireturn_type insert(std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::value_type &&__v)             {
                std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__hashtable &__h = this->_M_conjure_hashtable();
                std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__node_gen_type __node_gen(__h);
                return __h._M_insert(std::move(__v), __node_gen, std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__unique_keys());
            }
            std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::iterator insert(std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::const_iterator __hint, std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::value_type &&__v)             {
                std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__hashtable &__h = this->_M_conjure_hashtable();
                std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__node_gen_type __node_gen(__h);
                return __h._M_insert(__hint, std::move(__v), __node_gen, std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__unique_keys());
            }
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false> : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> {
            using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
            using value_type = typename __base_type::value_type;
            using iterator = typename __base_type::iterator;
            using const_iterator = typename __base_type::const_iterator;
            using __unique_keys = typename __base_type::__unique_keys;
            using __hashtable = typename __base_type::__hashtable;
            using __ireturn_type = typename __base_type::__ireturn_type;
            using __base_type::insert;
            template <typename _Pair> using __is_cons = std::is_constructible<value_type, _Pair &&>;
            template <typename _Pair> using _IFcons = std::enable_if<__is_cons<_Pair>::value>;
            template <typename _Pair> using _IFconsp = typename _IFcons<_Pair>::type;
            template <typename _Pair, typename = _IFconsp<_Pair>> std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__ireturn_type insert(_Pair &&__v)             {
                std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__hashtable &__h = this->_M_conjure_hashtable();
                return __h._M_emplace(std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__unique_keys(), std::forward<_Pair>(__v));
            }
            template <typename _Pair, typename = _IFconsp<_Pair>> std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::iterator insert(std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::const_iterator __hint, _Pair &&__v)             {
                std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__hashtable &__h = this->_M_conjure_hashtable();
                return __h._M_emplace(__hint, std::__detail::_Insert<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__unique_keys(), std::forward<_Pair>(__v));
            }
        };
        template <typename _Policy> using __has_load_factor = typename _Policy::__has_load_factor;
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits, typename = __detected_or_t<std::false_type, __has_load_factor, _RehashPolicy>> struct _Rehash_base
template<> struct _Rehash_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, std::integral_constant<bool, true>> {
            using __hashtable = _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>;
            float max_load_factor() const noexcept;
            void max_load_factor(float __z);
            void reserve(std::size_t __n);
        }
template<> struct _Rehash_base<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, std::integral_constant<bool, true>> {
            using __hashtable = _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>;
            float max_load_factor() const noexcept;
            void max_load_factor(float __z);
            void reserve(std::size_t __n);
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, std::false_type> {
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, std::true_type> {
            using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
            float max_load_factor() const noexcept             {
                const std::__detail::_Rehash_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, std::integral_constant<bool, true>>::__hashtable *__this = static_cast<const std::__detail::_Rehash_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, std::integral_constant<bool, true>>::__hashtable *>(this);
                return __this->__rehash_policy().max_load_factor();
            }
            void max_load_factor(float __z)             {
                std::__detail::_Rehash_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, std::integral_constant<bool, true>>::__hashtable *__this = static_cast<std::__detail::_Rehash_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, std::integral_constant<bool, true>>::__hashtable *>(this);
                __this->__rehash_policy(_RehashPolicy(__z));
            }
            void reserve(std::size_t __n)             {
                std::__detail::_Rehash_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, std::integral_constant<bool, true>>::__hashtable *__this = static_cast<std::__detail::_Rehash_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, std::integral_constant<bool, true>>::__hashtable *>(this);
                __this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));
            }
        };
        template <int _Nm, typename _Tp, bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)> struct _Hashtable_ebo_helper
template<> struct _Hashtable_ebo_helper<0, std::__detail::_Select1st, true> : private std::__detail::_Select1st {
            _Hashtable_ebo_helper() = default
            template <typename _OtherTp> _Hashtable_ebo_helper(_OtherTp &&__tp);
            const std::__detail::_Select1st &_M_cget() const;
            std::__detail::_Select1st &_M_get();
        }
template<> struct _Hashtable_ebo_helper<1, std::hash<int>, true> : private std::hash<int> {
            _Hashtable_ebo_helper() = default
            template <typename _OtherTp> _Hashtable_ebo_helper(_OtherTp &&__tp);
            const std::hash<int> &_M_cget() const;
            std::hash<int> &_M_get();
        }
template<> struct _Hashtable_ebo_helper<2, std::__detail::_Mod_range_hashing, true> : private std::__detail::_Mod_range_hashing {
            _Hashtable_ebo_helper() = default
            template <typename _OtherTp> _Hashtable_ebo_helper(_OtherTp &&__tp);
            const std::__detail::_Mod_range_hashing &_M_cget() const;
            std::__detail::_Mod_range_hashing &_M_get();
        }
template<> struct _Hashtable_ebo_helper<0, std::equal_to<int>, true> : private std::equal_to<int> {
            _Hashtable_ebo_helper() = default
            template <typename _OtherTp> _Hashtable_ebo_helper(_OtherTp &&__tp);
            const std::equal_to<int> &_M_cget() const;
            std::equal_to<int> &_M_get();
        }
template<> struct _Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, true> : private std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> {
            _Hashtable_ebo_helper() = default
            template <typename _OtherTp> _Hashtable_ebo_helper(_OtherTp &&__tp);
            template<> _Hashtable_ebo_helper<const std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, true> &>(const std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, true> &__tp);
            template<> _Hashtable_ebo_helper<std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, true>>(std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>, true> &&__tp);
            const std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &_M_cget() const;
            std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>> &_M_get();
        };
        template <int _Nm, typename _Tp> struct _Hashtable_ebo_helper<_Nm, _Tp, true> : private _Tp {
            _Hashtable_ebo_helper<_Nm, type-parameter-0-1, true>() = default
            template <typename _OtherTp> _Hashtable_ebo_helper<_Nm, type-parameter-0-1, true>(_OtherTp &&__tp) : _Tp(std::forward<_OtherTp>(__tp))             {
            }
            const _Tp &_M_cget() const             {
                return static_cast<const _Tp &>(*this);
            }
            _Tp &_M_get()             {
                return static_cast<_Tp &>(*this);
            }
        };
        template <int _Nm, typename _Tp> struct _Hashtable_ebo_helper<_Nm, _Tp, false> {
            _Hashtable_ebo_helper<_Nm, type-parameter-0-1, false>() = default
            template <typename _OtherTp> _Hashtable_ebo_helper<_Nm, type-parameter-0-1, false>(_OtherTp &&__tp) : _M_tp(std::forward<_OtherTp>(__tp))             {
            }
            const _Tp &_M_cget() const             {
                return this->_M_tp;
            }
            _Tp &_M_get()             {
                return this->_M_tp;
            }
        private:
            _Tp _M_tp;
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash, bool __cache_hash_code> struct _Local_iterator_base;
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash, bool __cache_hash_code> struct _Hash_code_base
template<> struct _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false> : private _Hashtable_ebo_helper<0, std::__detail::_Select1st>, private _Hashtable_ebo_helper<1, std::hash<int>>, private _Hashtable_ebo_helper<2, std::__detail::_Mod_range_hashing> {
        private:
            using __ebo_extract_key = _Hashtable_ebo_helper<0, std::__detail::_Select1st>;
            using __ebo_h1 = _Hashtable_ebo_helper<1, std::hash<int>>;
            using __ebo_h2 = _Hashtable_ebo_helper<2, std::__detail::_Mod_range_hashing>;
            friend  struct _Local_iterator_base<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>;
        public:
            typedef std::hash<int> hasher;
            std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::hasher hash_function() const;
        protected:
            typedef std::size_t __hash_code;
            typedef _Hash_node<std::pair<const int, int>, false> __node_type;
            _Hash_code_base() = default
            _Hash_code_base(const std::__detail::_Select1st &__ex, const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &);
            std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::__hash_code _M_hash_code(const int &__k) const;
            std::size_t _M_bucket_index(const int &, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code __c, std::size_t __bkt_count) const;
            std::size_t _M_bucket_index(const std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const std::hash<int> &>()(declval<const int &>())) && noexcept(declval<const std::__detail::_Mod_range_hashing &>()((std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code)0, (std::size_t)0))_M_bucket_index(const std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const std::hash<int> &>()(declval<const int &>())) && noexcept(declval<const std::__detail::_Mod_range_hashing &>()((std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code)0, (std::size_t)0)));
            void _M_store_code(std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::__node_type *, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code) const;
            void _M_copy_code(std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::__node_type *, const std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::__node_type *) const;
            void _M_swap(std::__detail::_Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false> &__x);
            const std::__detail::_Select1st &_M_extract() const;
            const std::hash<int> &_M_h1() const;
            const std::__detail::_Mod_range_hashing &_M_h2() const;
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash> struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> : private _Hashtable_ebo_helper<0, _ExtractKey>, private _Hashtable_ebo_helper<1, _Hash> {
        private:
            using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
            using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;
        protected:
            typedef void *__hash_code;
            typedef _Hash_node<_Value, false> __node_type;
            _Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>() = default
            _Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>(const _ExtractKey &__ex, const _H1 &, const _H2 &, const _Hash &__h) : std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__ebo_extract_key(__ex), std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__ebo_hash(__h)             {
            }
            std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__hash_code _M_hash_code(const _Key &__key) const             {
                return 0;
            }
            std::size_t _M_bucket_index(const _Key &__k, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__hash_code, std::size_t __bkt_count) const             {
                return this->_M_ranged_hash()(__k, __bkt_count);
            }
            std::size_t _M_bucket_index(const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const _Hash &>()(declval<const _Key &>(), (std::size_t)0))_M_bucket_index(const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const _Hash &>()(declval<const _Key &>(), (std::size_t)0)))             {
                return this->_M_ranged_hash()(this->_M_extract()(__p->_M_v()), __bkt_count);
            }
            void _M_store_code(std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__node_type *, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__hash_code) const             {
            }
            void _M_copy_code(std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__node_type *, const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__node_type *) const             {
            }
            void _M_swap(_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false> &__x)             {
                std::swap(__ebo_extract_key::_M_get(), __x.__ebo_extract_key::_M_get());
                std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get());
            }
            const _ExtractKey &_M_extract() const             {
                return __ebo_extract_key::_M_cget();
            }
            const _Hash &_M_ranged_hash() const             {
                return __ebo_hash::_M_cget();
            }
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash> struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2> struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, false> : private _Hashtable_ebo_helper<0, _ExtractKey>, private _Hashtable_ebo_helper<1, _H1>, private _Hashtable_ebo_helper<2, _H2> {
        private:
            using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
            using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
            using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;
            friend  struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false>;
        public:
            typedef _H1 hasher;
            std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::hasher hash_function() const             {
                return this->_M_h1();
            }
        protected:
            typedef std::size_t __hash_code;
            typedef _Hash_node<_Value, false> __node_type;
            _Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>() = default
            _Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>(const _ExtractKey &__ex, const _H1 &__h1, const _H2 &__h2, const std::__detail::_Default_ranged_hash &) : std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__ebo_extract_key(__ex), std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__ebo_h1(__h1), std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__ebo_h2(__h2)             {
            }
            std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code _M_hash_code(const _Key &__k) const             {
                static_assert(__is_invocable<const _H1 &, const _Key &>({}), "hash function must be invocable with an argument of key type");
                return this->_M_h1()(__k);
            }
            std::size_t _M_bucket_index(const _Key &, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code __c, std::size_t __bkt_count) const             {
                return this->_M_h2()(__c, __bkt_count);
            }
            std::size_t _M_bucket_index(const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const _H1 &>()(declval<const _Key &>())) && noexcept(declval<const _H2 &>()((std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code)0, (std::size_t)0))_M_bucket_index(const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const _H1 &>()(declval<const _Key &>())) && noexcept(declval<const _H2 &>()((std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code)0, (std::size_t)0)))             {
                return this->_M_h2()(this->_M_h1()(this->_M_extract()(__p->_M_v())), __bkt_count);
            }
            void _M_store_code(std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__node_type *, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__hash_code) const             {
            }
            void _M_copy_code(std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__node_type *, const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false>::__node_type *) const             {
            }
            void _M_swap(_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, false> &__x)             {
                std::swap(__ebo_extract_key::_M_get(), __x.__ebo_extract_key::_M_get());
                std::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());
                std::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());
            }
            const _ExtractKey &_M_extract() const             {
                return __ebo_extract_key::_M_cget();
            }
            const _H1 &_M_h1() const             {
                return __ebo_h1::_M_cget();
            }
            const _H2 &_M_h2() const             {
                return __ebo_h2::_M_cget();
            }
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2> struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, std::__detail::_Default_ranged_hash, true> : private _Hashtable_ebo_helper<0, _ExtractKey>, private _Hashtable_ebo_helper<1, _H1>, private _Hashtable_ebo_helper<2, _H2> {
        private:
            friend  struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true>;
            using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
            using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
            using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;
        public:
            typedef _H1 hasher;
            std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::hasher hash_function() const             {
                return this->_M_h1();
            }
        protected:
            typedef std::size_t __hash_code;
            typedef _Hash_node<_Value, true> __node_type;
            _Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>() = default
            _Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>(const _ExtractKey &__ex, const _H1 &__h1, const _H2 &__h2, const std::__detail::_Default_ranged_hash &) : std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__ebo_extract_key(__ex), std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__ebo_h1(__h1), std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__ebo_h2(__h2)             {
            }
            std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__hash_code _M_hash_code(const _Key &__k) const             {
                static_assert(__is_invocable<const _H1 &, const _Key &>({}), "hash function must be invocable with an argument of key type");
                return this->_M_h1()(__k);
            }
            std::size_t _M_bucket_index(const _Key &, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__hash_code __c, std::size_t __bkt_count) const             {
                return this->_M_h2()(__c, __bkt_count);
            }
            std::size_t _M_bucket_index(const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const _H2 &>()((std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__hash_code)0, (std::size_t)0))_M_bucket_index(const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__node_type *__p, std::size_t __bkt_count) const noexcept(noexcept(declval<const _H2 &>()((std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__hash_code)0, (std::size_t)0)))             {
                return this->_M_h2()(__p->_M_hash_code, __bkt_count);
            }
            void _M_store_code(std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__node_type *__n, std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__hash_code __c) const             {
                __n->_M_hash_code = __c;
            }
            void _M_copy_code(std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__node_type *__to, const std::__detail::_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true>::__node_type *__from) const             {
                __to->_M_hash_code = __from->_M_hash_code;
            }
            void _M_swap(_Hash_code_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, std::__detail::_Default_ranged_hash, true> &__x)             {
                std::swap(__ebo_extract_key::_M_get(), __x.__ebo_extract_key::_M_get());
                std::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());
                std::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());
            }
            const _ExtractKey &_M_extract() const             {
                return __ebo_extract_key::_M_cget();
            }
            const _H1 &_M_h1() const             {
                return __ebo_h1::_M_cget();
            }
            const _H2 &_M_h2() const             {
                return __ebo_h2::_M_cget();
            }
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash> struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true> : private _Hashtable_ebo_helper<0, _H2> {
        protected:
            using __base_type = _Hashtable_ebo_helper<0, _H2>;
            using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;
            _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, true>() = default
            _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, true>(const std::__detail::_Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, true>::__hash_code_base &__base, _Hash_node<_Value, true> *__p, std::size_t __bkt, std::size_t __bkt_count) : std::__detail::_Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, true>::__base_type(__base._M_h2()), _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)             {
            }
            void _M_incr()             {
                this->_M_cur = this->_M_cur->_M_next();
                if (this->_M_cur) {
                    std::size_t __bkt = __base_type::_M_get()(this->_M_cur->_M_hash_code, this->_M_bucket_count);
                    if (__bkt != this->_M_bucket)
                        this->_M_cur = nullptr;
                }
            }
            _Hash_node<_Value, true> *_M_cur;
            std::size_t _M_bucket;
            std::size_t _M_bucket_count;
        public:
            const void *_M_curr() const             {
                return this->_M_cur;
            }
            std::size_t _M_get_bucket() const             {
                return this->_M_bucket;
            }
        };
        template <typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value> struct _Hash_code_storage {
            __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
            _Tp *_M_h()             {
                return this->_M_storage._M_ptr();
            }
            const _Tp *_M_h() const             {
                return this->_M_storage._M_ptr();
            }
        };
        template <typename _Tp> struct _Hash_code_storage<_Tp, true> {
            static_assert(std::is_empty<_Tp>::value, "Type must be empty");
            _Tp *_M_h()             {
                return reinterpret_cast<_Tp *>(this);
            }
            const _Tp *_M_h() const             {
                return reinterpret_cast<const _Tp *>(this);
            }
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash> using __hash_code_for_local_iter = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>>;
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash> struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash> {
        protected:
            using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>;
            _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>() : _M_bucket_count(-1)             {
            }
            _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>(const std::__detail::_Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__hash_code_base &__base, _Hash_node<_Value, false> *__p, std::size_t __bkt, std::size_t __bkt_count) : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)             {
                this->_M_init(__base);
            }
            ~_Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>()             {
                if (this->_M_bucket_count != -1)
                    this->_M_destroy();
            }
            _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>(const _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false> &__iter) : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket), _M_bucket_count(__iter._M_bucket_count)             {
                if (this->_M_bucket_count != -1)
                    this->_M_init(*__iter._M_h());
            }
            _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false> &operator=(const _Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false> &__iter)             {
                if (this->_M_bucket_count != -1)
                    this->_M_destroy();
                this->_M_cur = __iter._M_cur;
                this->_M_bucket = __iter._M_bucket;
                this->_M_bucket_count = __iter._M_bucket_count;
                if (this->_M_bucket_count != -1)
                    this->_M_init(*__iter._M_h());
                return *this;
            }
            void _M_incr()             {
                this->_M_cur = this->_M_cur->_M_next();
                if (this->_M_cur) {
                    std::size_t __bkt = this->_M_h()->_M_bucket_index(this->_M_cur, this->_M_bucket_count);
                    if (__bkt != this->_M_bucket)
                        this->_M_cur = nullptr;
                }
            }
            _Hash_node<_Value, false> *_M_cur;
            std::size_t _M_bucket;
            std::size_t _M_bucket_count;
            void _M_init(const std::__detail::_Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__hash_code_base &__base)             {
                ::new (this->_M_h()) std::__detail::_Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__hash_code_base((__base));
            }
            void _M_destroy()             {
                this->_M_h()->~std::__detail::_Local_iterator_base<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, false>::__hash_code_base();
            }
        public:
            const void *_M_curr() const             {
                return this->_M_cur;
            }
            std::size_t _M_get_bucket() const             {
                return this->_M_bucket;
            }
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash, bool __cache> inline bool operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> &__x, const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> &__y)         {
            return __x._M_curr() == __y._M_curr();
        }
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash, bool __cache> inline bool operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> &__x, const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> &__y)         {
            return __x._M_curr() != __y._M_curr();
        }
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash, bool __constant_iterators, bool __cache> struct _Local_iterator : public _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> {
        private:
            using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>;
            using __hash_code_base = typename __base_type::__hash_code_base;
        public:
            typedef _Value value_type;
            typedef typename std::conditional<__constant_iterators, const _Value *, _Value *>::type pointer;
            typedef typename std::conditional<__constant_iterators, const _Value &, _Value &>::type reference;
            typedef std::ptrdiff_t difference_type;
            typedef std::forward_iterator_tag iterator_category;
            _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>() = default
            _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>(const std::__detail::_Local_iterator::__hash_code_base &__base, _Hash_node<_Value, __cache> *__n, std::size_t __bkt, std::size_t __bkt_count) : std::__detail::_Local_iterator::__base_type(__base, __n, __bkt, __bkt_count)             {
            }
            std::__detail::_Local_iterator::reference operator*() const             {
                return this->_M_cur->_M_v();
            }
            std::__detail::_Local_iterator::pointer operator->() const             {
                return this->_M_cur->_M_valptr();
            }
            _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> &operator++()             {
                this->_M_incr();
                return *this;
            }
            _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> operator++(int)             {
                _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> __tmp(*this);
                this->_M_incr();
                return __tmp;
            }
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _H1, typename _H2, typename _Hash, bool __constant_iterators, bool __cache> struct _Local_const_iterator : public _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> {
        private:
            using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>;
            using __hash_code_base = typename __base_type::__hash_code_base;
        public:
            typedef _Value value_type;
            typedef const _Value *pointer;
            typedef const _Value &reference;
            typedef std::ptrdiff_t difference_type;
            typedef std::forward_iterator_tag iterator_category;
            _Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>() = default
            _Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>(const std::__detail::_Local_const_iterator::__hash_code_base &__base, _Hash_node<_Value, __cache> *__n, std::size_t __bkt, std::size_t __bkt_count) : std::__detail::_Local_const_iterator::__base_type(__base, __n, __bkt, __bkt_count)             {
            }
            _Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>(const _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> &__x) : std::__detail::_Local_const_iterator::__base_type(__x)             {
            }
            std::__detail::_Local_const_iterator::reference operator*() const             {
                return this->_M_cur->_M_v();
            }
            std::__detail::_Local_const_iterator::pointer operator->() const             {
                return this->_M_cur->_M_valptr();
            }
            _Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> &operator++()             {
                this->_M_incr();
                return *this;
            }
            _Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> operator++(int)             {
                _Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> __tmp(*this);
                this->_M_incr();
                return __tmp;
            }
        };
        template <typename _Key, typename _Value, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _Traits> struct _Hashtable_base : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value>, private _Hashtable_ebo_helper<0, _Equal> {
        public:
            typedef _Key key_type;
            typedef _Value value_type;
            typedef _Equal key_equal;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;
            using __traits_type = _Traits;
            using __hash_cached = typename __traits_type::__hash_cached;
            using __constant_iterators = typename __traits_type::__constant_iterators;
            using __unique_keys = typename __traits_type::__unique_keys;
            using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __hash_cached::value>;
            using __hash_code = typename __hash_code_base::__hash_code;
            using __node_type = typename __hash_code_base::__node_type;
            using iterator = __detail::_Node_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using const_iterator = __detail::_Node_const_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using local_iterator = __detail::_Local_iterator<key_type, value_type, _ExtractKey, _H1, _H2, _Hash, __constant_iterators::value, __hash_cached::value>;
            using const_local_iterator = __detail::_Local_const_iterator<key_type, value_type, _ExtractKey, _H1, _H2, _Hash, __constant_iterators::value, __hash_cached::value>;
            using __ireturn_type = typename std::conditional<__unique_keys::value, std::pair<iterator, bool>, iterator>::type;
        private:
            using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
            template <typename _NodeT> struct _Equal_hash_code {
                static bool _S_equals(std::__detail::_Hashtable_base::__hash_code, const _NodeT &)                 {
                    return true;
                }
            };
            template <typename _Ptr2> struct _Equal_hash_code<_Hash_node<_Ptr2, true>> {
                static bool _S_equals(std::__detail::_Hashtable_base::__hash_code __c, const _Hash_node<_Ptr2, true> &__n)                 {
                    return __c == __n._M_hash_code;
                }
            };
        protected:
            _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>() = default
            _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>(const _ExtractKey &__ex, const _H1 &__h1, const _H2 &__h2, const _Hash &__hash, const _Equal &__eq) : std::__detail::_Hashtable_base::__hash_code_base(__ex, __h1, __h2, __hash), std::__detail::_Hashtable_base::_EqualEBO(__eq)             {
            }
            bool _M_equals(const _Key &__k, std::__detail::_Hashtable_base::__hash_code __c, std::__detail::_Hashtable_base::__node_type *__n) const             {
                static_assert(__is_invocable<const _Equal &, const _Key &, const _Key &>({}), "key equality predicate must be invocable with two arguments of key type");
                return _Equal_hash_code<__node_type>::_S_equals(__c, *__n) && this->_M_eq()(__k, this->_M_extract()(__n->_M_v()));
            }
            void _M_swap(_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> &__x)             {
                __hash_code_base::_M_swap(__x);
                std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
            }
            const _Equal &_M_eq() const             {
                return _EqualEBO::_M_cget();
            }
        };
template<> struct _Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>> : public _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, _Hashtable_traits<false, false, true>::__hash_cached::value>, private _Hashtable_ebo_helper<0, std::equal_to<int>> {
        public:
            typedef int key_type;
            typedef std::pair<const int, int> value_type;
            typedef std::equal_to<int> key_equal;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;
            using __traits_type = std::__detail::_Hashtable_traits<false, false, true>;
            using __hash_cached = typename __traits_type::__hash_cached;
            using __constant_iterators = typename __traits_type::__constant_iterators;
            using __unique_keys = typename __traits_type::__unique_keys;
            using __hash_code_base = _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, __hash_cached::value>;
            using __hash_code = typename __hash_code_base::__hash_code;
            using __node_type = typename __hash_code_base::__node_type;
            using iterator = __detail::_Node_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using const_iterator = __detail::_Node_const_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using local_iterator = __detail::_Local_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using const_local_iterator = __detail::_Local_const_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using __ireturn_type = typename std::conditional<__unique_keys::value, std::pair<iterator, bool>, iterator>::type;
        private:
            using _EqualEBO = _Hashtable_ebo_helper<0, std::equal_to<int>>;
            template <typename _NodeT> struct _Equal_hash_code;
        protected:
            _Hashtable_base() = default
            _Hashtable_base(const std::__detail::_Select1st &__ex, const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__hash, const std::equal_to<int> &__eq);
            bool _M_equals(const int &__k, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __c, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n) const;
            void _M_swap(std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, true>> &__x);
            const std::equal_to<int> &_M_eq() const;
        };
template<> struct _Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>> : public _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, _Hashtable_traits<false, false, false>::__hash_cached::value>, private _Hashtable_ebo_helper<0, std::equal_to<int>> {
        public:
            typedef int key_type;
            typedef std::pair<const int, int> value_type;
            typedef std::equal_to<int> key_equal;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;
            using __traits_type = std::__detail::_Hashtable_traits<false, false, false>;
            using __hash_cached = typename __traits_type::__hash_cached;
            using __constant_iterators = typename __traits_type::__constant_iterators;
            using __unique_keys = typename __traits_type::__unique_keys;
            using __hash_code_base = _Hash_code_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, __hash_cached::value>;
            using __hash_code = typename __hash_code_base::__hash_code;
            using __node_type = typename __hash_code_base::__node_type;
            using iterator = __detail::_Node_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using const_iterator = __detail::_Node_const_iterator<value_type, __constant_iterators::value, __hash_cached::value>;
            using local_iterator = __detail::_Local_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using const_local_iterator = __detail::_Local_const_iterator<key_type, value_type, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, __constant_iterators::value, __hash_cached::value>;
            using __ireturn_type = typename std::conditional<__unique_keys::value, std::pair<iterator, bool>, iterator>::type;
        private:
            using _EqualEBO = _Hashtable_ebo_helper<0, std::equal_to<int>>;
            template <typename _NodeT> struct _Equal_hash_code;
        protected:
            _Hashtable_base() = default
            _Hashtable_base(const std::__detail::_Select1st &__ex, const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__hash, const std::equal_to<int> &__eq);
            bool _M_equals(const int &__k, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __c, std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n) const;
            void _M_swap(std::__detail::_Hashtable_base<int, std::pair<const int, int>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<false, false, false>> &__x);
            const std::equal_to<int> &_M_eq() const;
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits, bool _Unique_keys = _Traits::__unique_keys::value> struct _Equality
template<> struct _Equality<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true> {
            using __hashtable = _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>;
            bool _M_equal(const std::__detail::_Equality<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::__hashtable &) const;
        }
template<> struct _Equality<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, false> {
            using __hashtable = _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>;
            bool _M_equal(const std::__detail::_Equality<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>, false>::__hashtable &) const;
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> {
            using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
            bool _M_equal(const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__hashtable &) const;
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> bool _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::_M_equal(const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__hashtable &__other) const         {
            using __node_base = typename __hashtable::__node_base;
            using __node_type = typename __hashtable::__node_type;
            const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__hashtable *__this = static_cast<const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, true>::__hashtable *>(this);
            if (__this->size() != __other.size())
                return false;
            for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx) {
                std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);
                __node_base *__prev_n = __other._M_buckets[__ybkt];
                if (!__prev_n)
                    return false;
                for (__node_type *__n = static_cast<__node_type *>(__prev_n->_M_nxt); ; __n = __n->_M_next()) {
                    if (__n->_M_v() == *__itx)
                        break;
                    if (!__n->_M_nxt || __other._M_bucket_index(__n->_M_next()) != __ybkt)
                        return false;
                }
            }
            return true;
        }
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false> {
            using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
            bool _M_equal(const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__hashtable &) const;
        };
        template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> bool _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::_M_equal(const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__hashtable &__other) const         {
            using __node_base = typename __hashtable::__node_base;
            using __node_type = typename __hashtable::__node_type;
            const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__hashtable *__this = static_cast<const std::__detail::_Equality<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, type-parameter-0-5, type-parameter-0-6, type-parameter-0-7, type-parameter-0-8, type-parameter-0-9, false>::__hashtable *>(this);
            if (__this->size() != __other.size())
                return false;
            for (auto __itx = __this->begin(); __itx != __this->end();) {
                std::size_t __x_count = 1;
                auto __itx_end = __itx;
                for (++__itx_end; __itx_end != __this->end() && __this->key_eq()(_ExtractKey()(*__itx), _ExtractKey()(*__itx_end)); ++__itx_end)
                    ++__x_count;
                std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);
                __node_base *__y_prev_n = __other._M_buckets[__ybkt];
                if (!__y_prev_n)
                    return false;
                __node_type *__y_n = static_cast<__node_type *>(__y_prev_n->_M_nxt);
                for (;; __y_n = __y_n->_M_next()) {
                    if (__this->key_eq()(_ExtractKey()(__y_n->_M_v()), _ExtractKey()(*__itx)))
                        break;
                    if (!__y_n->_M_nxt || __other._M_bucket_index(__y_n->_M_next()) != __ybkt)
                        return false;
                }
                typename __hashtable::const_iterator __ity(__y_n);
                for (auto __ity_end = __ity; __ity_end != __other.end(); ++__ity_end)
                    if (--__x_count == 0)
                        break;
                if (__x_count != 0)
                    return false;
                if (!std::is_permutation(__itx, __itx_end, __ity))
                    return false;
                __itx = __itx_end;
            }
            return true;
        }
        template <typename _NodeAlloc> struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc> {
        private:
            using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
        public:
            using __node_type = typename _NodeAlloc::value_type;
            using __node_alloc_type = _NodeAlloc;
            using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;
            using __value_alloc_traits = typename __node_alloc_traits::template rebind_traits<typename __node_type::value_type>;
            using __node_base = __detail::_Hash_node_base;
            using __bucket_type = std::__detail::_Hashtable_alloc::__node_base *;
            using __bucket_alloc_type = __alloc_rebind<std::__detail::_Hashtable_alloc::__node_alloc_type, std::__detail::_Hashtable_alloc::__bucket_type>;
            using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;
            _Hashtable_alloc<_NodeAlloc>() = default
            _Hashtable_alloc<_NodeAlloc>(const _Hashtable_alloc<_NodeAlloc> &) = default
            _Hashtable_alloc<_NodeAlloc>(_Hashtable_alloc<_NodeAlloc> &&) = default
            template <typename _Alloc> _Hashtable_alloc<_NodeAlloc>(_Alloc &&__a) : std::__detail::_Hashtable_alloc::__ebo_node_alloc(std::forward<_Alloc>(__a))             {
            }
            std::__detail::_Hashtable_alloc::__node_alloc_type &_M_node_allocator()             {
                return __ebo_node_alloc::_M_get();
            }
            const std::__detail::_Hashtable_alloc::__node_alloc_type &_M_node_allocator() const             {
                return __ebo_node_alloc::_M_cget();
            }
            template <typename ..._Args> std::__detail::_Hashtable_alloc::__node_type *_M_allocate_node(_Args &&...__args);
            void _M_deallocate_node(std::__detail::_Hashtable_alloc::__node_type *__n);
            void _M_deallocate_node_ptr(std::__detail::_Hashtable_alloc::__node_type *__n);
            void _M_deallocate_nodes(std::__detail::_Hashtable_alloc::__node_type *__n);
            std::__detail::_Hashtable_alloc::__bucket_type *_M_allocate_buckets(std::size_t __bkt_count);
            void _M_deallocate_buckets(std::__detail::_Hashtable_alloc::__bucket_type *, std::size_t __bkt_count);
        };
template<> struct _Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> : private _Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> {
        private:
            using __ebo_node_alloc = _Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>;
        public:
            using __node_type = typename allocator<_Hash_node<pair<const int, int>, false>>::value_type;
            using __node_alloc_type = std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>;
            using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;
            using __value_alloc_traits = typename __node_alloc_traits::rebind_traits<typename __node_type::value_type>;
            using __node_base = __detail::_Hash_node_base;
            using __bucket_type = std::__detail::_Hashtable_alloc::__node_base *;
            using __bucket_alloc_type = __alloc_rebind<std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_alloc_type, std::__detail::_Hashtable_alloc::__bucket_type>;
            using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;
            _Hashtable_alloc() = default
            _Hashtable_alloc(const std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> &) = default
            _Hashtable_alloc(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>> &&) = default
            template <typename _Alloc> _Hashtable_alloc(_Alloc &&__a);
            std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_alloc_type &_M_node_allocator();
            const std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_alloc_type &_M_node_allocator() const;
            template <typename ..._Args> std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *_M_allocate_node(_Args &&...__args);
            void _M_deallocate_node(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *__n);
            void _M_deallocate_node_ptr(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *__n);
            void _M_deallocate_nodes(std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__node_type *__n);
            std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int>, false>>>::__bucket_type *_M_allocate_buckets(std::size_t __bkt_count);
            void _M_deallocate_buckets(std::__detail::_Hashtable_alloc::__bucket_type *, std::size_t __bkt_count);
        };
        template <typename _NodeAlloc> template <typename ..._Args> auto _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args &&...__args) -> std::__detail::_Hashtable_alloc::__node_type *         {
            auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
            std::__detail::_Hashtable_alloc::__node_type *__n = std::__to_address(__nptr);
            try {
                ::new ((void *)__n) std::__detail::_Hashtable_alloc::__node_type;
                __node_alloc_traits::construct(_M_node_allocator(), __n->_M_valptr(), std::forward<_Args>(__args)...);
                return __n;
            } catch (...) {
                __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
                throw;
            }
        }
        template <typename _NodeAlloc> void _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(std::__detail::_Hashtable_alloc::__node_type *__n)         {
            __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
            this->_M_deallocate_node_ptr(__n);
        }
        template <typename _NodeAlloc> void _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(std::__detail::_Hashtable_alloc::__node_type *__n)         {
            typedef typename __node_alloc_traits::pointer _Ptr;
            auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
            __n->~std::__detail::_Hashtable_alloc::__node_type();
            __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
        }
        template <typename _NodeAlloc> void _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(std::__detail::_Hashtable_alloc::__node_type *__n)         {
            while (__n)
                {
                    std::__detail::_Hashtable_alloc::__node_type *__tmp = __n;
                    __n = __n->_M_next();
                    this->_M_deallocate_node(__tmp);
                }
        }
        template <typename _NodeAlloc> typename _Hashtable_alloc<_NodeAlloc>::__bucket_type *_Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)         {
            std::__detail::_Hashtable_alloc::__bucket_alloc_type __alloc(_M_node_allocator());
            auto __ptr = __bucket_alloc_traits::allocate(__alloc, __bkt_count);
            std::__detail::_Hashtable_alloc::__bucket_type *__p = std::__to_address(__ptr);
            __builtin_memset(__p, 0, __bkt_count * sizeof(std::__detail::_Hashtable_alloc::__bucket_type));
            return __p;
        }
        template <typename _NodeAlloc> void _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(std::__detail::_Hashtable_alloc::__bucket_type *__bkts, std::size_t __bkt_count)         {
            typedef typename __bucket_alloc_traits::pointer _Ptr;
            auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
            std::__detail::_Hashtable_alloc::__bucket_alloc_type __alloc(_M_node_allocator());
            __bucket_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
        }
    }
}
namespace std {
    struct _Enable_default_constructor_tag {
        explicit _Enable_default_constructor_tag() = default
    };
    template <bool _Switch, typename _Tag = void> struct _Enable_default_constructor {
        _Enable_default_constructor<_Switch, _Tag>() noexcept = default
        _Enable_default_constructor<_Switch, _Tag>(const _Enable_default_constructor<_Switch, _Tag> &) noexcept = default
        _Enable_default_constructor<_Switch, _Tag>(_Enable_default_constructor<_Switch, _Tag> &&) noexcept = default
        _Enable_default_constructor<_Switch, _Tag> &operator=(const _Enable_default_constructor<_Switch, _Tag> &) noexcept = default
        _Enable_default_constructor<_Switch, _Tag> &operator=(_Enable_default_constructor<_Switch, _Tag> &&) noexcept = default
        constexpr explicit _Enable_default_constructor<_Switch, _Tag>(std::_Enable_default_constructor_tag)         {
        }
    };
    template <bool _Switch, typename _Tag = void> struct _Enable_destructor {
    };
    template <bool _Copy, bool _CopyAssignment, bool _Move, bool _MoveAssignment, typename _Tag = void> struct _Enable_copy_move {
    };
    template <bool _Default, bool _Destructor, bool _Copy, bool _CopyAssignment, bool _Move, bool _MoveAssignment, typename _Tag = void> struct _Enable_special_members : private _Enable_default_constructor<_Default, _Tag>, private _Enable_destructor<_Destructor, _Tag>, private _Enable_copy_move<_Copy, _CopyAssignment, _Move, _MoveAssignment, _Tag> {
    };
    template <typename _Tag> struct _Enable_default_constructor<false, _Tag> {
        constexpr _Enable_default_constructor<false, type-parameter-0-0>() noexcept = delete
        _Enable_default_constructor<false, type-parameter-0-0>(const _Enable_default_constructor<false, type-parameter-0-0> &) noexcept = default
        _Enable_default_constructor<false, type-parameter-0-0>(_Enable_default_constructor<false, type-parameter-0-0> &&) noexcept = default
        _Enable_default_constructor<false, type-parameter-0-0> &operator=(const _Enable_default_constructor<false, type-parameter-0-0> &) noexcept = default
        _Enable_default_constructor<false, type-parameter-0-0> &operator=(_Enable_default_constructor<false, type-parameter-0-0> &&) noexcept = default
        constexpr explicit _Enable_default_constructor<false, type-parameter-0-0>(std::_Enable_default_constructor_tag)         {
        }
    };
    template <typename _Tag> struct _Enable_destructor<false, _Tag> {
        ~_Enable_destructor<false, type-parameter-0-0>() noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<false, true, true, true, _Tag> {
        _Enable_copy_move<false, true, true, true, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, true, true, true, type-parameter-0-0>(const _Enable_copy_move<false, true, true, true, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, true, true, true, type-parameter-0-0>(_Enable_copy_move<false, true, true, true, type-parameter-0-0> &&) noexcept = default
        _Enable_copy_move<false, true, true, true, type-parameter-0-0> &operator=(const _Enable_copy_move<false, true, true, true, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<false, true, true, true, type-parameter-0-0> &operator=(_Enable_copy_move<false, true, true, true, type-parameter-0-0> &&) noexcept = default
    };
    template <typename _Tag> struct _Enable_copy_move<true, false, true, true, _Tag> {
        _Enable_copy_move<true, false, true, true, type-parameter-0-0>() noexcept = default
        _Enable_copy_move<true, false, true, true, type-parameter-0-0>(const _Enable_copy_move<true, false, true, true, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<true, false, true, true, type-parameter-0-0>(_Enable_copy_move<true, false, true, true, type-parameter-0-0> &&) noexcept = default
        _Enable_copy_move<true, false, true, true, type-parameter-0-0> &operator=(const _Enable_copy_move<true, false, true, true, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<true, false, true, true, type-parameter-0-0> &operator=(_Enable_copy_move<true, false, true, true, type-parameter-0-0> &&) noexcept = default
    };
    template <typename _Tag> struct _Enable_copy_move<false, false, true, true, _Tag> {
        _Enable_copy_move<false, false, true, true, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, false, true, true, type-parameter-0-0>(const _Enable_copy_move<false, false, true, true, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, false, true, true, type-parameter-0-0>(_Enable_copy_move<false, false, true, true, type-parameter-0-0> &&) noexcept = default
        _Enable_copy_move<false, false, true, true, type-parameter-0-0> &operator=(const _Enable_copy_move<false, false, true, true, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, false, true, true, type-parameter-0-0> &operator=(_Enable_copy_move<false, false, true, true, type-parameter-0-0> &&) noexcept = default
    };
    template <typename _Tag> struct _Enable_copy_move<true, true, false, true, _Tag> {
        _Enable_copy_move<true, true, false, true, type-parameter-0-0>() noexcept = default
        _Enable_copy_move<true, true, false, true, type-parameter-0-0>(const _Enable_copy_move<true, true, false, true, type-parameter-0-0> &) noexcept = default
        constexpr _Enable_copy_move<true, true, false, true, type-parameter-0-0>(_Enable_copy_move<true, true, false, true, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<true, true, false, true, type-parameter-0-0> &operator=(const _Enable_copy_move<true, true, false, true, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<true, true, false, true, type-parameter-0-0> &operator=(_Enable_copy_move<true, true, false, true, type-parameter-0-0> &&) noexcept = default
    };
    template <typename _Tag> struct _Enable_copy_move<false, true, false, true, _Tag> {
        _Enable_copy_move<false, true, false, true, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, true, false, true, type-parameter-0-0>(const _Enable_copy_move<false, true, false, true, type-parameter-0-0> &) noexcept = delete
        constexpr _Enable_copy_move<false, true, false, true, type-parameter-0-0>(_Enable_copy_move<false, true, false, true, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<false, true, false, true, type-parameter-0-0> &operator=(const _Enable_copy_move<false, true, false, true, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<false, true, false, true, type-parameter-0-0> &operator=(_Enable_copy_move<false, true, false, true, type-parameter-0-0> &&) noexcept = default
    };
    template <typename _Tag> struct _Enable_copy_move<true, false, false, true, _Tag> {
        _Enable_copy_move<true, false, false, true, type-parameter-0-0>() noexcept = default
        _Enable_copy_move<true, false, false, true, type-parameter-0-0>(const _Enable_copy_move<true, false, false, true, type-parameter-0-0> &) noexcept = default
        constexpr _Enable_copy_move<true, false, false, true, type-parameter-0-0>(_Enable_copy_move<true, false, false, true, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<true, false, false, true, type-parameter-0-0> &operator=(const _Enable_copy_move<true, false, false, true, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<true, false, false, true, type-parameter-0-0> &operator=(_Enable_copy_move<true, false, false, true, type-parameter-0-0> &&) noexcept = default
    };
    template <typename _Tag> struct _Enable_copy_move<false, false, false, true, _Tag> {
        _Enable_copy_move<false, false, false, true, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, false, false, true, type-parameter-0-0>(const _Enable_copy_move<false, false, false, true, type-parameter-0-0> &) noexcept = delete
        constexpr _Enable_copy_move<false, false, false, true, type-parameter-0-0>(_Enable_copy_move<false, false, false, true, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<false, false, false, true, type-parameter-0-0> &operator=(const _Enable_copy_move<false, false, false, true, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, false, false, true, type-parameter-0-0> &operator=(_Enable_copy_move<false, false, false, true, type-parameter-0-0> &&) noexcept = default
    };
    template <typename _Tag> struct _Enable_copy_move<true, true, true, false, _Tag> {
        _Enable_copy_move<true, true, true, false, type-parameter-0-0>() noexcept = default
        _Enable_copy_move<true, true, true, false, type-parameter-0-0>(const _Enable_copy_move<true, true, true, false, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<true, true, true, false, type-parameter-0-0>(_Enable_copy_move<true, true, true, false, type-parameter-0-0> &&) noexcept = default
        _Enable_copy_move<true, true, true, false, type-parameter-0-0> &operator=(const _Enable_copy_move<true, true, true, false, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<true, true, true, false, type-parameter-0-0> &operator=(_Enable_copy_move<true, true, true, false, type-parameter-0-0> &&) noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<false, true, true, false, _Tag> {
        _Enable_copy_move<false, true, true, false, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, true, true, false, type-parameter-0-0>(const _Enable_copy_move<false, true, true, false, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, true, true, false, type-parameter-0-0>(_Enable_copy_move<false, true, true, false, type-parameter-0-0> &&) noexcept = default
        _Enable_copy_move<false, true, true, false, type-parameter-0-0> &operator=(const _Enable_copy_move<false, true, true, false, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<false, true, true, false, type-parameter-0-0> &operator=(_Enable_copy_move<false, true, true, false, type-parameter-0-0> &&) noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<true, false, true, false, _Tag> {
        _Enable_copy_move<true, false, true, false, type-parameter-0-0>() noexcept = default
        _Enable_copy_move<true, false, true, false, type-parameter-0-0>(const _Enable_copy_move<true, false, true, false, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<true, false, true, false, type-parameter-0-0>(_Enable_copy_move<true, false, true, false, type-parameter-0-0> &&) noexcept = default
        _Enable_copy_move<true, false, true, false, type-parameter-0-0> &operator=(const _Enable_copy_move<true, false, true, false, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<true, false, true, false, type-parameter-0-0> &operator=(_Enable_copy_move<true, false, true, false, type-parameter-0-0> &&) noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<false, false, true, false, _Tag> {
        _Enable_copy_move<false, false, true, false, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, false, true, false, type-parameter-0-0>(const _Enable_copy_move<false, false, true, false, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, false, true, false, type-parameter-0-0>(_Enable_copy_move<false, false, true, false, type-parameter-0-0> &&) noexcept = default
        _Enable_copy_move<false, false, true, false, type-parameter-0-0> &operator=(const _Enable_copy_move<false, false, true, false, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, false, true, false, type-parameter-0-0> &operator=(_Enable_copy_move<false, false, true, false, type-parameter-0-0> &&) noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<true, true, false, false, _Tag> {
        _Enable_copy_move<true, true, false, false, type-parameter-0-0>() noexcept = default
        _Enable_copy_move<true, true, false, false, type-parameter-0-0>(const _Enable_copy_move<true, true, false, false, type-parameter-0-0> &) noexcept = default
        constexpr _Enable_copy_move<true, true, false, false, type-parameter-0-0>(_Enable_copy_move<true, true, false, false, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<true, true, false, false, type-parameter-0-0> &operator=(const _Enable_copy_move<true, true, false, false, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<true, true, false, false, type-parameter-0-0> &operator=(_Enable_copy_move<true, true, false, false, type-parameter-0-0> &&) noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<false, true, false, false, _Tag> {
        _Enable_copy_move<false, true, false, false, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, true, false, false, type-parameter-0-0>(const _Enable_copy_move<false, true, false, false, type-parameter-0-0> &) noexcept = delete
        constexpr _Enable_copy_move<false, true, false, false, type-parameter-0-0>(_Enable_copy_move<false, true, false, false, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<false, true, false, false, type-parameter-0-0> &operator=(const _Enable_copy_move<false, true, false, false, type-parameter-0-0> &) noexcept = default
        _Enable_copy_move<false, true, false, false, type-parameter-0-0> &operator=(_Enable_copy_move<false, true, false, false, type-parameter-0-0> &&) noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<true, false, false, false, _Tag> {
        _Enable_copy_move<true, false, false, false, type-parameter-0-0>() noexcept = default
        _Enable_copy_move<true, false, false, false, type-parameter-0-0>(const _Enable_copy_move<true, false, false, false, type-parameter-0-0> &) noexcept = default
        constexpr _Enable_copy_move<true, false, false, false, type-parameter-0-0>(_Enable_copy_move<true, false, false, false, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<true, false, false, false, type-parameter-0-0> &operator=(const _Enable_copy_move<true, false, false, false, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<true, false, false, false, type-parameter-0-0> &operator=(_Enable_copy_move<true, false, false, false, type-parameter-0-0> &&) noexcept = delete
    };
    template <typename _Tag> struct _Enable_copy_move<false, false, false, false, _Tag> {
        _Enable_copy_move<false, false, false, false, type-parameter-0-0>() noexcept = default
        constexpr _Enable_copy_move<false, false, false, false, type-parameter-0-0>(const _Enable_copy_move<false, false, false, false, type-parameter-0-0> &) noexcept = delete
        constexpr _Enable_copy_move<false, false, false, false, type-parameter-0-0>(_Enable_copy_move<false, false, false, false, type-parameter-0-0> &&) noexcept = delete
        _Enable_copy_move<false, false, false, false, type-parameter-0-0> &operator=(const _Enable_copy_move<false, false, false, false, type-parameter-0-0> &) noexcept = delete
        _Enable_copy_move<false, false, false, false, type-parameter-0-0> &operator=(_Enable_copy_move<false, false, false, false, type-parameter-0-0> &&) noexcept = delete
    };
}
namespace std {
    template <typename _Tp> class optional;
    struct nullopt_t {
        enum class _Construct : int {
            _Token
        };
        constexpr explicit nullopt_t(std::nullopt_t::_Construct)         {
        }
    };
    constexpr std::nullopt_t nullopt{nullopt_t::_Construct::_Token};
    class bad_optional_access : public std::exception {
    public:
        bad_optional_access() : std::exception()         {
        }
        virtual const char *what() const noexcept override         {
            return "bad optional access";
        }
        virtual ~bad_optional_access() noexcept = default    };
    void __throw_bad_optional_access();
    inline void __throw_bad_optional_access()     {
        (throw (std::bad_optional_access()));
    }
    template <typename _Tp> struct _Optional_payload_base {
        using _Stored_type = remove_const_t<_Tp>;
        _Optional_payload_base<_Tp>() = default
        ~_Optional_payload_base<_Tp>() = default
        template <typename ..._Args> constexpr _Optional_payload_base<_Tp>(std::in_place_t __tag, _Args &&...__args) : _M_payload(__tag, std::forward<_Args>(__args)...), _M_engaged(true)         {
        }
        template <typename _Up, typename ..._Args> constexpr _Optional_payload_base<_Tp>(std::initializer_list<_Up> __il, _Args &&...__args) : _M_payload(__il, std::forward<_Args>(__args)...), _M_engaged(true)         {
        }
        constexpr _Optional_payload_base<_Tp>(bool __engaged, const _Optional_payload_base<_Tp> &__other)         {
            if (__other._M_engaged)
                this->_M_construct(__other._M_get());
        }
        constexpr _Optional_payload_base<_Tp>(bool __engaged, _Optional_payload_base<_Tp> &&__other)         {
            if (__other._M_engaged)
                this->_M_construct(std::move(__other._M_get()));
        }
        _Optional_payload_base<_Tp>(const _Optional_payload_base<_Tp> &) = default
        _Optional_payload_base<_Tp>(_Optional_payload_base<_Tp> &&) = default
        _Optional_payload_base<_Tp> &operator=(const _Optional_payload_base<_Tp> &) = default
        _Optional_payload_base<_Tp> &operator=(_Optional_payload_base<_Tp> &&) = default
        constexpr void _M_copy_assign(const _Optional_payload_base<_Tp> &__other)         {
            if (this->_M_engaged && __other._M_engaged)
                this->_M_get() = __other._M_get();
            else {
                if (__other._M_engaged)
                    this->_M_construct(__other._M_get());
                else
                    this->_M_reset();
            }
        }
        constexpr void _M_move_assign(_Optional_payload_base<_Tp> &&__other) noexcept(__and_v<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>_M_move_assign(_Optional_payload_base<_Tp> &&__other) noexcept(__and_v<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>)         {
            if (this->_M_engaged && __other._M_engaged)
                this->_M_get() = std::move(__other._M_get());
            else {
                if (__other._M_engaged)
                    this->_M_construct(std::move(__other._M_get()));
                else
                    this->_M_reset();
            }
        }
        struct _Empty_byte {
        };
        template <typename _Up, bool = is_trivially_destructible_v<_Up>> union _Storage {
            constexpr _Storage<_Up, >() noexcept : _M_empty()             {
            }
            template <typename ..._Args> constexpr _Storage<_Up, >(std::in_place_t, _Args &&...__args) : _M_value(std::forward<_Args>(__args)...)             {
            }
            template <typename _Vp, typename ..._Args> constexpr _Storage<_Up, >(std::initializer_list<_Vp> __il, _Args &&...__args) : _M_value(__il, std::forward<_Args>(__args)...)             {
            }
            std::_Optional_payload_base::_Empty_byte _M_empty;
            _Up _M_value;
        };
        template <typename _Up> union _Storage<_Up, false> {
            constexpr _Storage<type-parameter-1-0, false>() noexcept : _M_empty()             {
            }
            template <typename ..._Args> constexpr _Storage<type-parameter-1-0, false>(std::in_place_t, _Args &&...__args) : _M_value(std::forward<_Args>(__args)...)             {
            }
            template <typename _Vp, typename ..._Args> constexpr _Storage<type-parameter-1-0, false>(std::initializer_list<_Vp> __il, _Args &&...__args) : _M_value(__il, std::forward<_Args>(__args)...)             {
            }
            ~_Storage<type-parameter-1-0, false>()             {
            }
            std::_Optional_payload_base::_Empty_byte _M_empty;
            _Up _M_value;
        };
        _Storage<std::_Optional_payload_base::_Stored_type> _M_payload;
        bool _M_engaged = false;
        template <typename ..._Args> void _M_construct(_Args &&...__args) noexcept(is_nothrow_constructible_v<std::_Optional_payload_base::_Stored_type, _Args...>_M_construct(_Args &&...__args) noexcept(is_nothrow_constructible_v<std::_Optional_payload_base::_Stored_type, _Args...>)         {
            ::new ((void *)std::__addressof(this->_M_payload)) std::_Optional_payload_base::_Stored_type((std::forward<_Args>(__args)...));
            this->_M_engaged = true;
        }
        constexpr void _M_destroy() noexcept         {
            this->_M_engaged = false;
            this->_M_payload._M_value.~std::_Optional_payload_base::_Stored_type();
        }
        constexpr _Tp &_M_get() noexcept         {
            return this->_M_payload._M_value;
        }
        constexpr const _Tp &_M_get() const noexcept         {
            return this->_M_payload._M_value;
        }
        constexpr void _M_reset() noexcept         {
            if (this->_M_engaged)
                this->_M_destroy();
        }
    };
    template <typename _Tp, bool = is_trivially_destructible_v<_Tp>, bool = is_trivially_copy_assignable_v<_Tp> && is_trivially_copy_constructible_v<_Tp>, bool = is_trivially_move_assignable_v<_Tp> && is_trivially_move_constructible_v<_Tp>> struct _Optional_payload;
    template <typename _Tp> struct _Optional_payload<_Tp, true, true, true> : _Optional_payload_base<_Tp> {
        using _Optional_payload_base<_Tp>::_Optional_payload_base<type-parameter-0-0>;
        _Optional_payload<type-parameter-0-0, true, true, true>() = default
    };
    template <typename _Tp> struct _Optional_payload<_Tp, true, false, true> : _Optional_payload_base<_Tp> {
        using _Optional_payload_base<_Tp>::_Optional_payload_base<type-parameter-0-0>;
        _Optional_payload<type-parameter-0-0, true, false, true>() = default
        ~_Optional_payload<type-parameter-0-0, true, false, true>() = default
        _Optional_payload<type-parameter-0-0, true, false, true>(const _Optional_payload<type-parameter-0-0, true, false, true> &) = default
        _Optional_payload<type-parameter-0-0, true, false, true>(_Optional_payload<type-parameter-0-0, true, false, true> &&) = default
        _Optional_payload<type-parameter-0-0, true, false, true> &operator=(_Optional_payload<type-parameter-0-0, true, false, true> &&) = default
        constexpr _Optional_payload<type-parameter-0-0, true, false, true> &operator=(const _Optional_payload<type-parameter-0-0, true, false, true> &__other)         {
            this->_M_copy_assign(__other);
            return *this;
        }
    };
    template <typename _Tp> struct _Optional_payload<_Tp, true, true, false> : _Optional_payload_base<_Tp> {
        using _Optional_payload_base<_Tp>::_Optional_payload_base<type-parameter-0-0>;
        _Optional_payload<type-parameter-0-0, true, true, false>() = default
        ~_Optional_payload<type-parameter-0-0, true, true, false>() = default
        _Optional_payload<type-parameter-0-0, true, true, false>(const _Optional_payload<type-parameter-0-0, true, true, false> &) = default
        _Optional_payload<type-parameter-0-0, true, true, false>(_Optional_payload<type-parameter-0-0, true, true, false> &&) = default
        _Optional_payload<type-parameter-0-0, true, true, false> &operator=(const _Optional_payload<type-parameter-0-0, true, true, false> &) = default
        constexpr _Optional_payload<type-parameter-0-0, true, true, false> &operator=(_Optional_payload<type-parameter-0-0, true, true, false> &&__other) noexcept(__and_v<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>operator=(_Optional_payload<type-parameter-0-0, true, true, false> &&__other) noexcept(__and_v<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>)         {
            this->_M_move_assign(std::move(__other));
            return *this;
        }
    };
    template <typename _Tp> struct _Optional_payload<_Tp, true, false, false> : _Optional_payload_base<_Tp> {
        using _Optional_payload_base<_Tp>::_Optional_payload_base<type-parameter-0-0>;
        _Optional_payload<type-parameter-0-0, true, false, false>() = default
        ~_Optional_payload<type-parameter-0-0, true, false, false>() = default
        _Optional_payload<type-parameter-0-0, true, false, false>(const _Optional_payload<type-parameter-0-0, true, false, false> &) = default
        _Optional_payload<type-parameter-0-0, true, false, false>(_Optional_payload<type-parameter-0-0, true, false, false> &&) = default
        constexpr _Optional_payload<type-parameter-0-0, true, false, false> &operator=(const _Optional_payload<type-parameter-0-0, true, false, false> &__other)         {
            this->_M_copy_assign(__other);
            return *this;
        }
        constexpr _Optional_payload<type-parameter-0-0, true, false, false> &operator=(_Optional_payload<type-parameter-0-0, true, false, false> &&__other) noexcept(__and_v<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>operator=(_Optional_payload<type-parameter-0-0, true, false, false> &&__other) noexcept(__and_v<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>)         {
            this->_M_move_assign(std::move(__other));
            return *this;
        }
    };
    template <typename _Tp, bool _Copy, bool _Move> struct _Optional_payload<_Tp, false, _Copy, _Move> : _Optional_payload<_Tp, true, false, false> {
        using _Optional_payload<_Tp, true, false, false>::_Optional_payload<type-parameter-0-0, true, false, false>;
        _Optional_payload<type-parameter-0-0, false, _Copy, _Move>() = default
        _Optional_payload<type-parameter-0-0, false, _Copy, _Move>(const _Optional_payload<type-parameter-0-0, false, _Copy, _Move> &) = default
        _Optional_payload<type-parameter-0-0, false, _Copy, _Move>(_Optional_payload<type-parameter-0-0, false, _Copy, _Move> &&) = default
        _Optional_payload<type-parameter-0-0, false, _Copy, _Move> &operator=(const _Optional_payload<type-parameter-0-0, false, _Copy, _Move> &) = default
        _Optional_payload<type-parameter-0-0, false, _Copy, _Move> &operator=(_Optional_payload<type-parameter-0-0, false, _Copy, _Move> &&) = default
        ~_Optional_payload<type-parameter-0-0, false, _Copy, _Move>()         {
            this->_M_reset();
        }
    };
    template <typename _Tp, typename _Dp> class _Optional_base_impl {
    protected:
        using _Stored_type = remove_const_t<_Tp>;
        template <typename ..._Args> void _M_construct(_Args &&...__args) noexcept(is_nothrow_constructible_v<std::_Optional_base_impl::_Stored_type, _Args...>_M_construct(_Args &&...__args) noexcept(is_nothrow_constructible_v<std::_Optional_base_impl::_Stored_type, _Args...>)         {
            ::new (std::__addressof(static_cast<_Dp *>(this)->_M_payload._M_payload)) std::_Optional_base_impl::_Stored_type((std::forward<_Args>(__args)...));
            static_cast<_Dp *>(this)->_M_payload._M_engaged = true;
        }
        void _M_destruct() noexcept         {
            static_cast<_Dp *>(this)->_M_payload._M_destroy();
        }
        constexpr void _M_reset() noexcept         {
            static_cast<_Dp *>(this)->_M_payload._M_reset();
        }
        constexpr bool _M_is_engaged() const noexcept         {
            return static_cast<const _Dp *>(this)->_M_payload._M_engaged;
        }
        constexpr _Tp &_M_get() noexcept         {
            ;
            return static_cast<_Dp *>(this)->_M_payload._M_get();
        }
        constexpr const _Tp &_M_get() const noexcept         {
            ;
            return static_cast<const _Dp *>(this)->_M_payload._M_get();
        }
    };
    template <typename _Tp, bool = is_trivially_copy_constructible_v<_Tp>, bool = is_trivially_move_constructible_v<_Tp>> struct _Optional_base : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {
        _Optional_base<_Tp, , >() = default
        template <typename ..._Args, enable_if_t<is_constructible_v<_Tp, _Args &&...>, bool> = false> constexpr explicit _Optional_base<_Tp, , >(std::in_place_t, _Args &&...__args) : _M_payload(in_place, std::forward<_Args>(__args)...)         {
        }
        template <typename _Up, typename ..._Args, enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args &&...>, bool> = false> constexpr explicit _Optional_base<_Tp, , >(std::in_place_t, initializer_list<_Up> __il, _Args &&...__args) : _M_payload(in_place, __il, std::forward<_Args>(__args)...)         {
        }
        constexpr _Optional_base<_Tp, , >(const _Optional_base<_Tp, , > &__other) : _M_payload(__other._M_payload._M_engaged, __other._M_payload)         {
        }
        constexpr _Optional_base<_Tp, , >(_Optional_base<_Tp, , > &&__other) noexcept(is_nothrow_move_constructible_v<_Tp>_Optional_base<_Tp, , >(_Optional_base<_Tp, , > &&__other) noexcept(is_nothrow_move_constructible_v<_Tp>) : _M_payload(__other._M_payload._M_engaged, std::move(__other._M_payload))         {
        }
        _Optional_base<_Tp, , > &operator=(const _Optional_base<_Tp, , > &) = default
        _Optional_base<_Tp, , > &operator=(_Optional_base<_Tp, , > &&) = default
        _Optional_payload<_Tp> _M_payload;
    };
    template <typename _Tp> struct _Optional_base<_Tp, false, true> : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {
        _Optional_base<type-parameter-0-0, false, true>() = default
        template <typename ..._Args, enable_if_t<is_constructible_v<_Tp, _Args &&...>, bool> = false> constexpr explicit _Optional_base<type-parameter-0-0, false, true>(std::in_place_t, _Args &&...__args) : _M_payload(in_place, std::forward<_Args>(__args)...)         {
        }
        template <typename _Up, typename ..._Args, enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args &&...>, bool> = false> constexpr explicit _Optional_base<type-parameter-0-0, false, true>(std::in_place_t, initializer_list<_Up> __il, _Args &&...__args) : _M_payload(in_place, __il, std::forward<_Args>(__args)...)         {
        }
        constexpr _Optional_base<type-parameter-0-0, false, true>(const _Optional_base<type-parameter-0-0, false, true> &__other) : _M_payload(__other._M_payload._M_engaged, __other._M_payload)         {
        }
        _Optional_base<type-parameter-0-0, false, true>(_Optional_base<type-parameter-0-0, false, true> &&__other) = default
        _Optional_base<type-parameter-0-0, false, true> &operator=(const _Optional_base<type-parameter-0-0, false, true> &) = default
        _Optional_base<type-parameter-0-0, false, true> &operator=(_Optional_base<type-parameter-0-0, false, true> &&) = default
        _Optional_payload<_Tp> _M_payload;
    };
    template <typename _Tp> struct _Optional_base<_Tp, true, false> : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {
        _Optional_base<type-parameter-0-0, true, false>() = default
        template <typename ..._Args, enable_if_t<is_constructible_v<_Tp, _Args &&...>, bool> = false> constexpr explicit _Optional_base<type-parameter-0-0, true, false>(std::in_place_t, _Args &&...__args) : _M_payload(in_place, std::forward<_Args>(__args)...)         {
        }
        template <typename _Up, typename ..._Args, enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args &&...>, bool> = false> constexpr explicit _Optional_base<type-parameter-0-0, true, false>(std::in_place_t, initializer_list<_Up> __il, _Args &&...__args) : _M_payload(in_place, __il, std::forward<_Args>(__args)...)         {
        }
        _Optional_base<type-parameter-0-0, true, false>(const _Optional_base<type-parameter-0-0, true, false> &__other) = default
        constexpr _Optional_base<type-parameter-0-0, true, false>(_Optional_base<type-parameter-0-0, true, false> &&__other) noexcept(is_nothrow_move_constructible_v<_Tp>_Optional_base<type-parameter-0-0, true, false>(_Optional_base<type-parameter-0-0, true, false> &&__other) noexcept(is_nothrow_move_constructible_v<_Tp>) : _M_payload(__other._M_payload._M_engaged, std::move(__other._M_payload))         {
        }
        _Optional_base<type-parameter-0-0, true, false> &operator=(const _Optional_base<type-parameter-0-0, true, false> &) = default
        _Optional_base<type-parameter-0-0, true, false> &operator=(_Optional_base<type-parameter-0-0, true, false> &&) = default
        _Optional_payload<_Tp> _M_payload;
    };
    template <typename _Tp> struct _Optional_base<_Tp, true, true> : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {
        _Optional_base<type-parameter-0-0, true, true>() = default
        template <typename ..._Args, enable_if_t<is_constructible_v<_Tp, _Args &&...>, bool> = false> constexpr explicit _Optional_base<type-parameter-0-0, true, true>(std::in_place_t, _Args &&...__args) : _M_payload(in_place, std::forward<_Args>(__args)...)         {
        }
        template <typename _Up, typename ..._Args, enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args &&...>, bool> = false> constexpr explicit _Optional_base<type-parameter-0-0, true, true>(std::in_place_t, initializer_list<_Up> __il, _Args &&...__args) : _M_payload(in_place, __il, std::forward<_Args>(__args)...)         {
        }
        _Optional_base<type-parameter-0-0, true, true>(const _Optional_base<type-parameter-0-0, true, true> &__other) = default
        _Optional_base<type-parameter-0-0, true, true>(_Optional_base<type-parameter-0-0, true, true> &&__other) = default
        _Optional_base<type-parameter-0-0, true, true> &operator=(const _Optional_base<type-parameter-0-0, true, true> &) = default
        _Optional_base<type-parameter-0-0, true, true> &operator=(_Optional_base<type-parameter-0-0, true, true> &&) = default
        _Optional_payload<_Tp> _M_payload;
    };
    template <typename _Tp> class optional;
    template <typename _Tp, typename _Up> using __converts_from_optional = __or_<is_constructible<_Tp, const optional<_Up> &>, is_constructible<_Tp, optional<_Up> &>, is_constructible<_Tp, const optional<_Up> &&>, is_constructible<_Tp, optional<_Up> &&>, is_convertible<const optional<_Up> &, _Tp>, is_convertible<optional<_Up> &, _Tp>, is_convertible<const optional<_Up> &&, _Tp>, is_convertible<optional<_Up> &&, _Tp>>;
    template <typename _Tp, typename _Up> using __assigns_from_optional = __or_<is_assignable<_Tp &, const optional<_Up> &>, is_assignable<_Tp &, optional<_Up> &>, is_assignable<_Tp &, const optional<_Up> &&>, is_assignable<_Tp &, optional<_Up> &&>>;
    template <typename _Tp> class optional : private _Optional_base<_Tp>, private _Enable_copy_move<is_copy_constructible_v<_Tp>, __and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>, is_move_constructible_v<_Tp>, __and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>, optional<_Tp>> {
        static_assert(!is_same_v<remove_cv_t<_Tp>, std::nullopt_t>);
        static_assert(!is_same_v<remove_cv_t<_Tp>, std::in_place_t>);
        static_assert(!is_reference_v<_Tp>);
    private:
        using _Base = _Optional_base<_Tp>;
        template <typename _Up> using __not_self = __not_<is_same<optional<_Tp>, __remove_cvref_t<_Up>>>;
        template <typename _Up> using __not_tag = __not_<is_same<std::in_place_t, __remove_cvref_t<_Up>>>;
        template <typename ..._Cond> using _Requires = enable_if_t<__and_v<_Cond...>, bool>;
    public:
        using value_type = _Tp;
        optional<_Tp>() = default
        constexpr optional<_Tp>(std::nullopt_t) noexcept         {
        }
        template <typename _Up = _Tp, _Requires<__not_self<_Up>, __not_tag<_Up>, is_constructible<_Tp, _Up &&>, is_convertible<_Up &&, _Tp>> = true> constexpr optional<_Tp>(_Up &&__t) : std::optional::_Base(std::in_place, std::forward<_Up>(__t))         {
        }
        template <typename _Up = _Tp, _Requires<__not_self<_Up>, __not_tag<_Up>, is_constructible<_Tp, _Up &&>, __not_<is_convertible<_Up &&, _Tp>>> = false> constexpr explicit optional<_Tp>(_Up &&__t) : std::optional::_Base(std::in_place, std::forward<_Up>(__t))         {
        }
        template <typename _Up, _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, const _Up &>, is_convertible<const _Up &, _Tp>, __not_<__converts_from_optional<_Tp, _Up>>> = true> constexpr optional<_Tp>(const optional<_Up> &__t)         {
            if (__t)
                emplace(*__t);
        }
        template <typename _Up, _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, const _Up &>, __not_<is_convertible<const _Up &, _Tp>>, __not_<__converts_from_optional<_Tp, _Up>>> = false> constexpr explicit optional<_Tp>(const optional<_Up> &__t)         {
            if (__t)
                emplace(*__t);
        }
        template <typename _Up, _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, _Up &&>, is_convertible<_Up &&, _Tp>, __not_<__converts_from_optional<_Tp, _Up>>> = true> constexpr optional<_Tp>(optional<_Up> &&__t)         {
            if (__t)
                emplace(std::move(*__t));
        }
        template <typename _Up, _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, _Up &&>, __not_<is_convertible<_Up &&, _Tp>>, __not_<__converts_from_optional<_Tp, _Up>>> = false> constexpr explicit optional<_Tp>(optional<_Up> &&__t)         {
            if (__t)
                emplace(std::move(*__t));
        }
        template <typename ..._Args, _Requires<is_constructible<_Tp, _Args &&...>> = false> constexpr explicit optional<_Tp>(std::in_place_t, _Args &&...__args) : std::optional::_Base(std::in_place, std::forward<_Args>(__args)...)         {
        }
        template <typename _Up, typename ..._Args, _Requires<is_constructible<_Tp, initializer_list<_Up> &, _Args &&...>> = false> constexpr explicit optional<_Tp>(std::in_place_t, initializer_list<_Up> __il, _Args &&...__args) : std::optional::_Base(std::in_place, __il, std::forward<_Args>(__args)...)         {
        }
        optional<_Tp> &operator=(std::nullopt_t) noexcept         {
            this->_M_reset();
            return *this;
        }
        template <typename _Up = _Tp> enable_if_t<__and_v<__not_self<_Up>, __not_<__and_<is_scalar<_Tp>, is_same<_Tp, decay_t<_Up>>>>, is_constructible<_Tp, _Up>, is_assignable<_Tp &, _Up>>, optional<_Tp> &> operator=(_Up &&__u)         {
            if (this->_M_is_engaged())
                this->_M_get() = std::forward<_Up>(__u);
            else
                this->_M_construct(std::forward<_Up>(__u));
            return *this;
        }
        template <typename _Up> enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, const _Up &>, is_assignable<_Tp &, _Up>, __not_<__converts_from_optional<_Tp, _Up>>, __not_<__assigns_from_optional<_Tp, _Up>>>, optional<_Tp> &> operator=(const optional<_Up> &__u)         {
            if (__u) {
                if (this->_M_is_engaged())
                    this->_M_get() = *__u;
                else
                    this->_M_construct(*__u);
            } else {
                this->_M_reset();
            }
            return *this;
        }
        template <typename _Up> enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, _Up>, is_assignable<_Tp &, _Up>, __not_<__converts_from_optional<_Tp, _Up>>, __not_<__assigns_from_optional<_Tp, _Up>>>, optional<_Tp> &> operator=(optional<_Up> &&__u)         {
            if (__u) {
                if (this->_M_is_engaged())
                    this->_M_get() = std::move(*__u);
                else
                    this->_M_construct(std::move(*__u));
            } else {
                this->_M_reset();
            }
            return *this;
        }
        template <typename ..._Args> enable_if_t<is_constructible_v<_Tp, _Args &&...>, _Tp &> emplace(_Args &&...__args)         {
            this->_M_reset();
            this->_M_construct(std::forward<_Args>(__args)...);
            return this->_M_get();
        }
        template <typename _Up, typename ..._Args> enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args &&...>, _Tp &> emplace(initializer_list<_Up> __il, _Args &&...__args)         {
            this->_M_reset();
            this->_M_construct(__il, std::forward<_Args>(__args)...);
            return this->_M_get();
        }
        void swap(optional<_Tp> &__other) noexcept(is_nothrow_move_constructible_v<_Tp> && is_nothrow_swappable_v<_Tp>swap(optional<_Tp> &__other) noexcept(is_nothrow_move_constructible_v<_Tp> && is_nothrow_swappable_v<_Tp>)         {
            using std::swap;
            if (this->_M_is_engaged() && __other._M_is_engaged())
                swap(this->_M_get(), __other._M_get());
            else if (this->_M_is_engaged()) {
                __other._M_construct(std::move(this->_M_get()));
                this->_M_destruct();
            } else if (__other._M_is_engaged()) {
                this->_M_construct(std::move(__other._M_get()));
                __other._M_destruct();
            }
        }
        constexpr const _Tp *operator->() const         {
            return std::__addressof(this->_M_get());
        }
        constexpr _Tp *operator->()         {
            return std::__addressof(this->_M_get());
        }
        constexpr const _Tp &operator*() const &         {
            return this->_M_get();
        }
        constexpr _Tp &operator*() &         {
            return this->_M_get();
        }
        constexpr _Tp &&operator*() &&         {
            return std::move(this->_M_get());
        }
        constexpr const _Tp &&operator*() const &&         {
            return std::move(this->_M_get());
        }
        constexpr explicit operator bool() const noexcept         {
            return this->_M_is_engaged();
        }
        constexpr bool has_value() const noexcept         {
            return this->_M_is_engaged();
        }
        constexpr const _Tp &value() const &         {
            return this->_M_is_engaged() ? this->_M_get() : (__throw_bad_optional_access() , this->_M_get());
        }
        constexpr _Tp &value() &         {
            return this->_M_is_engaged() ? this->_M_get() : (__throw_bad_optional_access() , this->_M_get());
        }
        constexpr _Tp &&value() &&         {
            return this->_M_is_engaged() ? std::move(this->_M_get()) : (__throw_bad_optional_access() , std::move(this->_M_get()));
        }
        constexpr const _Tp &&value() const &&         {
            return this->_M_is_engaged() ? std::move(this->_M_get()) : (__throw_bad_optional_access() , std::move(this->_M_get()));
        }
        template <typename _Up> constexpr _Tp value_or(_Up &&__u) const &         {
            static_assert(is_copy_constructible_v<_Tp>);
            static_assert(is_convertible_v<_Up &&, _Tp>);
            return this->_M_is_engaged() ? this->_M_get() : static_cast<_Tp>(std::forward<_Up>(__u));
        }
        template <typename _Up> constexpr _Tp value_or(_Up &&__u) &&         {
            static_assert(is_move_constructible_v<_Tp>);
            static_assert(is_convertible_v<_Up &&, _Tp>);
            return this->_M_is_engaged() ? std::move(this->_M_get()) : static_cast<_Tp>(std::forward<_Up>(__u));
        }
        void reset() noexcept         {
            this->_M_reset();
        }
    };
    template <typename _Tp> using __optional_relop_t = enable_if_t<is_convertible<_Tp, bool>::value, bool>;
    template <typename _Tp, typename _Up> constexpr auto operator==(const optional<_Tp> &__lhs, const optional<_Up> &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Up>())>     {
        return static_cast<bool>(__lhs) == static_cast<bool>(__rhs) && (!__lhs || *__lhs == *__rhs);
    }
    template <typename _Tp, typename _Up> constexpr auto operator!=(const optional<_Tp> &__lhs, const optional<_Up> &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Up>())>     {
        return static_cast<bool>(__lhs) != static_cast<bool>(__rhs) || (static_cast<bool>(__lhs) && *__lhs != *__rhs);
    }
    template <typename _Tp, typename _Up> constexpr auto operator<(const optional<_Tp> &__lhs, const optional<_Up> &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Up>())>     {
        return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);
    }
    template <typename _Tp, typename _Up> constexpr auto operator>(const optional<_Tp> &__lhs, const optional<_Up> &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Up>())>     {
        return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);
    }
    template <typename _Tp, typename _Up> constexpr auto operator<=(const optional<_Tp> &__lhs, const optional<_Up> &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Up>())>     {
        return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);
    }
    template <typename _Tp, typename _Up> constexpr auto operator>=(const optional<_Tp> &__lhs, const optional<_Up> &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Up>())>     {
        return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);
    }
    template <typename _Tp> constexpr bool operator==(const optional<_Tp> &__lhs, std::nullopt_t) noexcept     {
        return !__lhs;
    }
    template <typename _Tp> constexpr bool operator==(std::nullopt_t, const optional<_Tp> &__rhs) noexcept     {
        return !__rhs;
    }
    template <typename _Tp> constexpr bool operator!=(const optional<_Tp> &__lhs, std::nullopt_t) noexcept     {
        return static_cast<bool>(__lhs);
    }
    template <typename _Tp> constexpr bool operator!=(std::nullopt_t, const optional<_Tp> &__rhs) noexcept     {
        return static_cast<bool>(__rhs);
    }
    template <typename _Tp> constexpr bool operator<(const optional<_Tp> &, std::nullopt_t) noexcept     {
        return false;
    }
    template <typename _Tp> constexpr bool operator<(std::nullopt_t, const optional<_Tp> &__rhs) noexcept     {
        return static_cast<bool>(__rhs);
    }
    template <typename _Tp> constexpr bool operator>(const optional<_Tp> &__lhs, std::nullopt_t) noexcept     {
        return static_cast<bool>(__lhs);
    }
    template <typename _Tp> constexpr bool operator>(std::nullopt_t, const optional<_Tp> &) noexcept     {
        return false;
    }
    template <typename _Tp> constexpr bool operator<=(const optional<_Tp> &__lhs, std::nullopt_t) noexcept     {
        return !__lhs;
    }
    template <typename _Tp> constexpr bool operator<=(std::nullopt_t, const optional<_Tp> &) noexcept     {
        return true;
    }
    template <typename _Tp> constexpr bool operator>=(const optional<_Tp> &, std::nullopt_t) noexcept     {
        return true;
    }
    template <typename _Tp> constexpr bool operator>=(std::nullopt_t, const optional<_Tp> &__rhs) noexcept     {
        return !__rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator==(const optional<_Tp> &__lhs, const _Up &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Up>())>     {
        return __lhs && *__lhs == __rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator==(const _Up &__lhs, const optional<_Tp> &__rhs) -> __optional_relop_t<decltype(declval<_Up>() == declval<_Tp>())>     {
        return __rhs && __lhs == *__rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator!=(const optional<_Tp> &__lhs, const _Up &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Up>())>     {
        return !__lhs || *__lhs != __rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator!=(const _Up &__lhs, const optional<_Tp> &__rhs) -> __optional_relop_t<decltype(declval<_Up>() != declval<_Tp>())>     {
        return !__rhs || __lhs != *__rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator<(const optional<_Tp> &__lhs, const _Up &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Up>())>     {
        return !__lhs || *__lhs < __rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator<(const _Up &__lhs, const optional<_Tp> &__rhs) -> __optional_relop_t<decltype(declval<_Up>() < declval<_Tp>())>     {
        return __rhs && __lhs < *__rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator>(const optional<_Tp> &__lhs, const _Up &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Up>())>     {
        return __lhs && *__lhs > __rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator>(const _Up &__lhs, const optional<_Tp> &__rhs) -> __optional_relop_t<decltype(declval<_Up>() > declval<_Tp>())>     {
        return !__rhs || __lhs > *__rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator<=(const optional<_Tp> &__lhs, const _Up &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Up>())>     {
        return !__lhs || *__lhs <= __rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator<=(const _Up &__lhs, const optional<_Tp> &__rhs) -> __optional_relop_t<decltype(declval<_Up>() <= declval<_Tp>())>     {
        return __rhs && __lhs <= *__rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator>=(const optional<_Tp> &__lhs, const _Up &__rhs) -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Up>())>     {
        return __lhs && *__lhs >= __rhs;
    }
    template <typename _Tp, typename _Up> constexpr auto operator>=(const _Up &__lhs, const optional<_Tp> &__rhs) -> __optional_relop_t<decltype(declval<_Up>() >= declval<_Tp>())>     {
        return !__rhs || __lhs >= *__rhs;
    }
    template <typename _Tp> inline enable_if_t<is_move_constructible_v<_Tp> && is_swappable_v<_Tp>> swap(optional<_Tp> &__lhs, optional<_Tp> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))swap(optional<_Tp> &__lhs, optional<_Tp> &__rhs) noexcept(noexcept(__lhs.swap(__rhs)))     {
        __lhs.swap(__rhs);
    }
    template <typename _Tp> enable_if_t<!(is_move_constructible_v<_Tp> && is_swappable_v<_Tp>)> swap(optional<_Tp> &, optional<_Tp> &) = delete
    template <typename _Tp> constexpr optional<decay_t<_Tp>> make_optional(_Tp &&__t)     {
        return optional<decay_t<_Tp>>({std::forward<_Tp>(__t)});
    }
    template <typename _Tp, typename ..._Args> constexpr optional<_Tp> make_optional(_Args &&...__args)     {
        return optional<_Tp>({in_place, std::forward<_Args>(__args)...});
    }
    template <typename _Tp, typename _Up, typename ..._Args> constexpr optional<_Tp> make_optional(initializer_list<_Up> __il, _Args &&...__args)     {
        return optional<_Tp>({in_place, __il, std::forward<_Args>(__args)...});
    }
    template <typename _Tp, typename _Up = remove_const_t<_Tp>, bool = __poison_hash<_Up>::__enable_hash_call> struct __optional_hash_call_base {
        std::size_t operator()(const optional<_Tp> &__t) const noexcept(noexcept(hash<_Up>({})(*__t))operator()(const optional<_Tp> &__t) const noexcept(noexcept(hash<_Up>({})(*__t)))         {
            constexpr std::size_t __magic_disengaged_hash = static_cast<std::size_t>(-3333);
            return __t ? hash<_Up>({})(*__t) : __magic_disengaged_hash;
        }
    };
    template <typename _Tp, typename _Up> struct __optional_hash_call_base<_Tp, _Up, false> {
    };
    template <typename _Tp> struct hash<optional<_Tp>> : private __poison_hash<remove_const_t<_Tp>>, public __optional_hash_call_base<_Tp> {
        using result_type [[deprecated("")]] = std::size_t;
        using argument_type [[deprecated("")]] = optional<_Tp>;
    };
    template <typename _Tp> struct __is_fast_hash<hash<optional<_Tp>>> : __is_fast_hash<hash<_Tp>> {
    };
    template <typename _Tp> optional(_Tp) -> optional<_Tp>;
}
namespace std {
    template <typename _Val, typename _NodeAlloc> class _Node_handle_common {
        using _AllocTraits = allocator_traits<_NodeAlloc>;
    public:
        using allocator_type = __alloc_rebind<_NodeAlloc, _Val>;
        std::_Node_handle_common::allocator_type get_allocator() const noexcept         {
            ;
            return std::_Node_handle_common::allocator_type(*this->_M_alloc);
        }
        explicit operator bool() const noexcept         {
            return this->_M_ptr != nullptr;
        }
        bool empty() const noexcept [[nodiscard("")]]         {
            return this->_M_ptr == nullptr;
        }
    protected:
        constexpr _Node_handle_common<_Val, _NodeAlloc>() noexcept : _M_ptr(), _M_alloc()         {
        }
        ~_Node_handle_common<_Val, _NodeAlloc>()         {
            this->_M_destroy();
        }
        _Node_handle_common<_Val, _NodeAlloc>(_Node_handle_common<_Val, _NodeAlloc> &&__nh) noexcept : _M_ptr(__nh._M_ptr), _M_alloc(std::move(__nh._M_alloc))         {
            __nh._M_ptr = nullptr;
            __nh._M_alloc = nullopt;
        }
        _Node_handle_common<_Val, _NodeAlloc> &operator=(_Node_handle_common<_Val, _NodeAlloc> &&__nh) noexcept         {
            this->_M_destroy();
            this->_M_ptr = __nh._M_ptr;
            if (is_move_assignable_v<_NodeAlloc>) {
                if (_AllocTraits::propagate_on_container_move_assignment::value || !this->_M_alloc)
                    this->_M_alloc = std::move(__nh._M_alloc);
                else {
                    ;
                }
            } else {
                ;
            }
            __nh._M_ptr = nullptr;
            __nh._M_alloc = nullopt;
            return *this;
        }
        _Node_handle_common<_Val, _NodeAlloc>(typename _AllocTraits::pointer __ptr, const _NodeAlloc &__alloc) : _M_ptr(__ptr), _M_alloc(__alloc)         {
        }
        void _M_swap(_Node_handle_common<_Val, _NodeAlloc> &__nh) noexcept         {
            using std::swap;
            swap(this->_M_ptr, __nh._M_ptr);
            if (_AllocTraits::propagate_on_container_swap::value || !this->_M_alloc || !__nh._M_alloc)
                this->_M_alloc.swap(__nh._M_alloc);
            else {
                ;
            }
        }
    private:
        void _M_destroy() noexcept         {
            if (this->_M_ptr != nullptr) {
                std::_Node_handle_common::allocator_type __alloc(*this->_M_alloc);
                allocator_traits<allocator_type>::destroy(__alloc, this->_M_ptr->_M_valptr());
                _AllocTraits::deallocate(*this->_M_alloc, this->_M_ptr, 1);
            }
        }
    protected:
        typename _AllocTraits::pointer _M_ptr;
    private:
        optional<_NodeAlloc> _M_alloc;
        friend template <typename _Key2, typename _Value2, typename _KeyOfValue, typename _Compare, typename _ValueAlloc> class _Rb_tree;
    };
    template <typename _Key, typename _Value, typename _NodeAlloc> class _Node_handle : public _Node_handle_common<_Value, _NodeAlloc> {
    public:
        _Node_handle<_Key, _Value, _NodeAlloc>() noexcept = default
        ~_Node_handle<_Key, _Value, _NodeAlloc>() = default
        _Node_handle<_Key, _Value, _NodeAlloc>(_Node_handle<_Key, _Value, _NodeAlloc> &&) noexcept = default
        _Node_handle<_Key, _Value, _NodeAlloc> &operator=(_Node_handle<_Key, _Value, _NodeAlloc> &&) noexcept = default
        using key_type = _Key;
        using mapped_type = typename _Value::second_type;
        std::_Node_handle::key_type &key() const noexcept         {
            ;
            return *this->_M_pkey;
        }
        std::_Node_handle::mapped_type &mapped() const noexcept         {
            ;
            return *this->_M_pmapped;
        }
        void swap(_Node_handle<_Key, _Value, _NodeAlloc> &__nh) noexcept         {
            this->_M_swap(__nh);
            using std::swap;
            swap(this->_M_pkey, __nh._M_pkey);
            swap(this->_M_pmapped, __nh._M_pmapped);
        }
        friend void swap(_Node_handle<_Key, _Value, _NodeAlloc> &__x, _Node_handle<_Key, _Value, _NodeAlloc> &__y) noexcept(noexcept(__x.swap(__y))swap(_Node_handle<_Key, _Value, _NodeAlloc> &__x, _Node_handle<_Key, _Value, _NodeAlloc> &__y) noexcept(noexcept(__x.swap(__y)))         {
            __x.swap(__y);
        }
;
    private:
        using _AllocTraits = allocator_traits<_NodeAlloc>;
        _Node_handle<_Key, _Value, _NodeAlloc>(typename _AllocTraits::pointer __ptr, const _NodeAlloc &__alloc) : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc)         {
            if (__ptr) {
                auto &__key = const_cast<_Key &>(__ptr->_M_valptr()->first);
                this->_M_pkey = _S_pointer_to(__key);
                this->_M_pmapped = _S_pointer_to(__ptr->_M_valptr()->second);
            } else {
                this->_M_pkey = nullptr;
                this->_M_pmapped = nullptr;
            }
        }
        template <typename _Tp> using __pointer = __ptr_rebind<typename _AllocTraits::pointer, remove_reference_t<_Tp>>;
        __pointer<_Key> _M_pkey = nullptr;
        __pointer<typename _Value::second_type> _M_pmapped = nullptr;
        template <typename _Tp> __pointer<_Tp> _S_pointer_to(_Tp &__obj)         {
            return pointer_traits<__pointer<_Tp>>::pointer_to(__obj);
        }
        const std::_Node_handle::key_type &_M_key() const noexcept         {
            return this->key();
        }
        friend template <typename _Key2, typename _Value2, typename _KeyOfValue, typename _Compare, typename _ValueAlloc> class _Rb_tree;
        friend template <typename _Key2, typename _Value2, typename _ValueAlloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> class _Hashtable;
    };
    template <typename _Value, typename _NodeAlloc> class _Node_handle<_Value, _Value, _NodeAlloc> : public _Node_handle_common<_Value, _NodeAlloc> {
    public:
        _Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1>() noexcept = default
        ~_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1>() = default
        _Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1>(_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &&) noexcept = default
        _Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &operator=(_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &&) noexcept = default
        using value_type = _Value;
        std::_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1>::value_type &value() const noexcept         {
            ;
            return *this->_M_ptr->_M_valptr();
        }
        void swap(_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &__nh) noexcept         {
            this->_M_swap(__nh);
        }
        friend void swap(_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &__x, _Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &__y) noexcept(noexcept(__x.swap(__y))swap(_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &__x, _Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1> &__y) noexcept(noexcept(__x.swap(__y)))         {
            __x.swap(__y);
        }
;
    private:
        using _AllocTraits = allocator_traits<_NodeAlloc>;
        _Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1>(typename _AllocTraits::pointer __ptr, const _NodeAlloc &__alloc) : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc)         {
        }
        const std::_Node_handle<type-parameter-0-0, type-parameter-0-0, type-parameter-0-1>::value_type &_M_key() const noexcept         {
            return this->value();
        }
        friend template <typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc> class _Rb_tree;
        friend template <typename _Key2, typename _Value2, typename _ValueAlloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> class _Hashtable;
    };
    template <typename _Iterator, typename _NodeHandle> struct _Node_insert_return {
        _Iterator position = _Iterator();
        bool inserted = false;
        _NodeHandle node;
    };
}
namespace std {
    template <typename _Tp, typename _Hash> using __cache_default = __not_<__and_<__is_fast_hash<_Hash>, __is_nothrow_invocable<const _Hash &, const _Tp &>>>;
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> class _Hashtable : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>, public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>, public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>, public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>, public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>, private __detail::_Hashtable_alloc<__alloc_rebind<_Alloc, __detail::_Hash_node<_Value, _Traits::__hash_cached::value>>> {
        static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value, "unordered container must have a non-const, non-volatile value_type");
        static_assert(is_same<typename _Alloc::value_type, _Value>({}), "unordered container must have the same value_type as its allocator");
        using __traits_type = _Traits;
        using __hash_cached = typename __traits_type::__hash_cached;
        using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
        using __node_alloc_type = __alloc_rebind<_Alloc, std::_Hashtable::__node_type>;
        using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;
        using __value_alloc_traits = typename __hashtable_alloc::__value_alloc_traits;
        using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;
        using __node_base = typename __hashtable_alloc::__node_base;
        using __bucket_type = typename __hashtable_alloc::__bucket_type;
    public:
        typedef _Key key_type;
        typedef _Value value_type;
        typedef _Alloc allocator_type;
        typedef _Equal key_equal;
        typedef typename __value_alloc_traits::pointer pointer;
        typedef typename __value_alloc_traits::const_pointer const_pointer;
        typedef std::_Hashtable::value_type &reference;
        typedef const std::_Hashtable::value_type &const_reference;
    private:
        using __rehash_type = _RehashPolicy;
        using __rehash_state = typename __rehash_type::_State;
        using __constant_iterators = typename __traits_type::__constant_iterators;
        using __unique_keys = typename __traits_type::__unique_keys;
        using __key_extract = typename std::conditional<__constant_iterators::value, __detail::_Identity, __detail::_Select1st>::type;
        using __hashtable_base = __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>;
        using __hash_code_base = typename __hashtable_base::__hash_code_base;
        using __hash_code = typename __hashtable_base::__hash_code;
        using __ireturn_type = typename __hashtable_base::__ireturn_type;
        using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
        using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
        using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>;
        using __reuse_or_alloc_node_gen_t = __detail::_ReuseOrAllocNode<__node_alloc_type>;
        using __alloc_node_gen_t = __detail::_AllocNode<__node_alloc_type>;
        struct _Scoped_node {
            _Scoped_node(std::_Hashtable::__node_type *__n, std::_Hashtable::__hashtable_alloc *__h) : _M_h(__h), _M_node(__n)             {
            }
            template <typename ..._Args> _Scoped_node(std::_Hashtable::__hashtable_alloc *__h, _Args &&...__args) : _M_h(__h), _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))             {
            }
            ~_Scoped_node()             {
                if (this->_M_node)
                    this->_M_h->_M_deallocate_node(this->_M_node);
            }
            _Scoped_node(const std::_Hashtable::_Scoped_node &) = delete
            std::_Hashtable::_Scoped_node &operator=(const std::_Hashtable::_Scoped_node &) = delete
            std::_Hashtable::__hashtable_alloc *_M_h;
            std::_Hashtable::__node_type *_M_node;
        };
        template <typename _Ht> static constexpr typename conditional<std::is_lvalue_reference<_Ht>::value, const value_type &, value_type &&>::type __fwd_value_for(std::_Hashtable::value_type &__val) noexcept         {
            return std::move(__val);
        }
        template <typename _Cond> using __if_hash_cached = __or_<__not_<std::_Hashtable::__hash_cached>, _Cond>;
        template <typename _Cond> using __if_hash_not_cached = __or_<std::_Hashtable::__hash_cached, _Cond>;
        struct __hash_code_base_access : std::_Hashtable::__hash_code_base {
            using __hash_code_base::_M_bucket_index;
        };
        static_assert(noexcept(declval<const std::_Hashtable::__hash_code_base_access &>()._M_bucket_index((const std::_Hashtable::__node_type *)nullptr, (std::size_t)0)), "Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept");
        static_assert(__if_hash_cached<is_default_constructible<_H2>>::value, "Functor used to map hash code to bucket index must be default constructible");
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa> struct _Map_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa> struct _Insert_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Constant_iteratorsa> struct _Insert;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa> struct _Equality;
    public:
        using size_type = typename __hashtable_base::size_type;
        using difference_type = typename __hashtable_base::difference_type;
        using iterator = typename __hashtable_base::iterator;
        using const_iterator = typename __hashtable_base::const_iterator;
        using local_iterator = typename __hashtable_base::local_iterator;
        using const_local_iterator = typename __hashtable_base::const_local_iterator;
        using node_type = _Node_handle<_Key, _Value, std::_Hashtable::__node_alloc_type>;
        using insert_return_type = _Node_insert_return<std::_Hashtable::iterator, std::_Hashtable::node_type>;
    private:
        std::_Hashtable::__bucket_type *_M_buckets = & this->_M_single_bucket;
        std::_Hashtable::size_type _M_bucket_count = 1;
        std::_Hashtable::__node_base _M_before_begin;
        std::_Hashtable::size_type _M_element_count = 0;
        _RehashPolicy _M_rehash_policy;
        std::_Hashtable::__bucket_type _M_single_bucket = nullptr;
        bool _M_uses_single_bucket(std::_Hashtable::__bucket_type *__bkts) const         {
            return __builtin_expect(__bkts == & this->_M_single_bucket, false);
        }
        bool _M_uses_single_bucket() const         {
            return _M_uses_single_bucket(this->_M_buckets);
        }
        std::_Hashtable::__hashtable_alloc &_M_base_alloc()         {
            return *this;
        }
        std::_Hashtable::__bucket_type *_M_allocate_buckets(std::_Hashtable::size_type __bkt_count)         {
            if (__builtin_expect(__bkt_count == 1, false)) {
                this->_M_single_bucket = nullptr;
                return & this->_M_single_bucket;
            }
            return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
        }
        void _M_deallocate_buckets(std::_Hashtable::__bucket_type *__bkts, std::_Hashtable::size_type __bkt_count)         {
            if (_M_uses_single_bucket(__bkts))
                return;
            __hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
        }
        void _M_deallocate_buckets()         {
            _M_deallocate_buckets(this->_M_buckets, this->_M_bucket_count);
        }
        std::_Hashtable::__node_type *_M_bucket_begin(std::_Hashtable::size_type __bkt) const;
        std::_Hashtable::__node_type *_M_begin() const         {
            return static_cast<std::_Hashtable::__node_type *>(this->_M_before_begin._M_nxt);
        }
        template <typename _Ht> void _M_assign_elements(_Ht &&);
        template <typename _Ht, typename _NodeGenerator> void _M_assign(_Ht &&, const _NodeGenerator &);
        void _M_move_assign(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&, std::true_type);
        void _M_move_assign(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&, std::false_type);
        void _M_reset() noexcept;
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(const _H1 &__h1, const _H2 &__h2, const _Hash &__h, const _Equal &__eq, const _ExtractKey &__exk, const std::_Hashtable::allocator_type &__a) : std::_Hashtable::__hashtable_base(__exk, __h1, __h2, __h, __eq), std::_Hashtable::__hashtable_alloc(std::_Hashtable::__node_alloc_type(__a))         {
        }
    public:
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>() = default
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(std::_Hashtable::size_type __bkt_count_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const std::_Hashtable::allocator_type &);
        template <typename _InputIterator> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(_InputIterator __first, _InputIterator __last, std::_Hashtable::size_type __bkt_count_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const std::_Hashtable::allocator_type &);
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &);
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&) noexcept;
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &, const std::_Hashtable::allocator_type &);
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&, const std::_Hashtable::allocator_type &);
        explicit _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(const std::_Hashtable::allocator_type &__a) : std::_Hashtable::__hashtable_alloc(std::_Hashtable::__node_alloc_type(__a))         {
        }
        explicit _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(std::_Hashtable::size_type __bkt_count_hint, const _H1 &__hf = _H1(), const std::_Hashtable::key_equal &__eql = std::_Hashtable::key_equal(), const std::_Hashtable::allocator_type &__a = std::_Hashtable::allocator_type()) : _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(__bkt_count_hint, __hf, _H2(), _Hash(), __eql, std::_Hashtable::__key_extract(), __a)         {
        }
        template <typename _InputIterator> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(_InputIterator __f, _InputIterator __l, std::_Hashtable::size_type __bkt_count_hint = 0, const _H1 &__hf = _H1(), const std::_Hashtable::key_equal &__eql = std::_Hashtable::key_equal(), const std::_Hashtable::allocator_type &__a = std::_Hashtable::allocator_type()) : _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(__f, __l, __bkt_count_hint, __hf, _H2(), _Hash(), __eql, std::_Hashtable::__key_extract(), __a)         {
        }
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(initializer_list<std::_Hashtable::value_type> __l, std::_Hashtable::size_type __bkt_count_hint = 0, const _H1 &__hf = _H1(), const std::_Hashtable::key_equal &__eql = std::_Hashtable::key_equal(), const std::_Hashtable::allocator_type &__a = std::_Hashtable::allocator_type()) : _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(__l.begin(), __l.end(), __bkt_count_hint, __hf, _H2(), _Hash(), __eql, std::_Hashtable::__key_extract(), __a)         {
        }
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &operator=(const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &__ht);
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &operator=(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&__ht) noexcept(__node_alloc_traits::_S_nothrow_move() && is_nothrow_move_assignable<_H1>::value && is_nothrow_move_assignable<_Equal>::valueoperator=(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&__ht) noexcept(__node_alloc_traits::_S_nothrow_move() && is_nothrow_move_assignable<_H1>::value && is_nothrow_move_assignable<_Equal>::value)         {
            constexpr bool __move_storage = __node_alloc_traits::_S_propagate_on_move_assign() || __node_alloc_traits::_S_always_equal();
            _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
            return *this;
        }
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &operator=(initializer_list<std::_Hashtable::value_type> __l)         {
            std::_Hashtable::__reuse_or_alloc_node_gen_t __roan(this->_M_begin(), *this);
            this->_M_before_begin._M_nxt = nullptr;
            this->clear();
            this->_M_insert_range(__l.begin(), __l.end(), __roan, std::_Hashtable::__unique_keys());
            return *this;
        }
        ~_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>() noexcept;
        void swap(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &) noexcept(__and_<__is_nothrow_swappable<_H1>, __is_nothrow_swappable<_Equal>>::valueswap(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &) noexcept(__and_<__is_nothrow_swappable<_H1>, __is_nothrow_swappable<_Equal>>::value);
        std::_Hashtable::iterator begin() noexcept         {
            return std::_Hashtable::iterator(this->_M_begin());
        }
        std::_Hashtable::const_iterator begin() const noexcept         {
            return std::_Hashtable::const_iterator(this->_M_begin());
        }
        std::_Hashtable::iterator end() noexcept         {
            return std::_Hashtable::iterator(nullptr);
        }
        std::_Hashtable::const_iterator end() const noexcept         {
            return std::_Hashtable::const_iterator(nullptr);
        }
        std::_Hashtable::const_iterator cbegin() const noexcept         {
            return std::_Hashtable::const_iterator(this->_M_begin());
        }
        std::_Hashtable::const_iterator cend() const noexcept         {
            return std::_Hashtable::const_iterator(nullptr);
        }
        std::_Hashtable::size_type size() const noexcept         {
            return this->_M_element_count;
        }
        bool empty() const noexcept [[nodiscard("")]]         {
            return this->size() == 0;
        }
        std::_Hashtable::allocator_type get_allocator() const noexcept         {
            return std::_Hashtable::allocator_type(this->_M_node_allocator());
        }
        std::_Hashtable::size_type max_size() const noexcept         {
            return __node_alloc_traits::max_size(this->_M_node_allocator());
        }
        std::_Hashtable::key_equal key_eq() const         {
            return this->_M_eq();
        }
        std::_Hashtable::size_type bucket_count() const noexcept         {
            return this->_M_bucket_count;
        }
        std::_Hashtable::size_type max_bucket_count() const noexcept         {
            return this->max_size();
        }
        std::_Hashtable::size_type bucket_size(std::_Hashtable::size_type __bkt) const         {
            return std::distance(begin(__bkt), end(__bkt));
        }
        std::_Hashtable::size_type bucket(const std::_Hashtable::key_type &__k) const         {
            return _M_bucket_index(__k, this->_M_hash_code(__k));
        }
        std::_Hashtable::local_iterator begin(std::_Hashtable::size_type __bkt)         {
            return std::_Hashtable::local_iterator(*this, this->_M_bucket_begin(__bkt), __bkt, this->_M_bucket_count);
        }
        std::_Hashtable::local_iterator end(std::_Hashtable::size_type __bkt)         {
            return std::_Hashtable::local_iterator(*this, nullptr, __bkt, this->_M_bucket_count);
        }
        std::_Hashtable::const_local_iterator begin(std::_Hashtable::size_type __bkt) const         {
            return std::_Hashtable::const_local_iterator(*this, this->_M_bucket_begin(__bkt), __bkt, this->_M_bucket_count);
        }
        std::_Hashtable::const_local_iterator end(std::_Hashtable::size_type __bkt) const         {
            return std::_Hashtable::const_local_iterator(*this, nullptr, __bkt, this->_M_bucket_count);
        }
        std::_Hashtable::const_local_iterator cbegin(std::_Hashtable::size_type __bkt) const         {
            return std::_Hashtable::const_local_iterator(*this, this->_M_bucket_begin(__bkt), __bkt, this->_M_bucket_count);
        }
        std::_Hashtable::const_local_iterator cend(std::_Hashtable::size_type __bkt) const         {
            return std::_Hashtable::const_local_iterator(*this, nullptr, __bkt, this->_M_bucket_count);
        }
        float load_factor() const noexcept         {
            return static_cast<float>(this->size()) / static_cast<float>(this->bucket_count());
        }
        const _RehashPolicy &__rehash_policy() const         {
            return this->_M_rehash_policy;
        }
        void __rehash_policy(const _RehashPolicy &__pol)         {
            this->_M_rehash_policy = __pol;
        }
        std::_Hashtable::iterator find(const std::_Hashtable::key_type &__k);
        std::_Hashtable::const_iterator find(const std::_Hashtable::key_type &__k) const;
        std::_Hashtable::size_type count(const std::_Hashtable::key_type &__k) const;
        std::pair<iterator, iterator> equal_range(const std::_Hashtable::key_type &__k);
        std::pair<const_iterator, const_iterator> equal_range(const std::_Hashtable::key_type &__k) const;
    protected:
        std::_Hashtable::size_type _M_bucket_index(std::_Hashtable::__node_type *__n) const noexcept         {
            return __hash_code_base::_M_bucket_index(__n, this->_M_bucket_count);
        }
        std::_Hashtable::size_type _M_bucket_index(const std::_Hashtable::key_type &__k, std::_Hashtable::__hash_code __c) const         {
            return __hash_code_base::_M_bucket_index(__k, __c, this->_M_bucket_count);
        }
        std::_Hashtable::__node_base *_M_find_before_node(std::_Hashtable::size_type, const std::_Hashtable::key_type &, std::_Hashtable::__hash_code) const;
        std::_Hashtable::__node_type *_M_find_node(std::_Hashtable::size_type __bkt, const std::_Hashtable::key_type &__key, std::_Hashtable::__hash_code __c) const         {
            std::_Hashtable::__node_base *__before_n = this->_M_find_before_node(__bkt, __key, __c);
            if (__before_n)
                return static_cast<std::_Hashtable::__node_type *>(__before_n->_M_nxt);
            return nullptr;
        }
        void _M_insert_bucket_begin(std::_Hashtable::size_type, std::_Hashtable::__node_type *);
        void _M_remove_bucket_begin(std::_Hashtable::size_type __bkt, std::_Hashtable::__node_type *__next_n, std::_Hashtable::size_type __next_bkt);
        std::_Hashtable::__node_base *_M_get_previous_node(std::_Hashtable::size_type __bkt, std::_Hashtable::__node_base *__n);
        std::_Hashtable::iterator _M_insert_unique_node(const std::_Hashtable::key_type &__k, std::_Hashtable::size_type __bkt, std::_Hashtable::__hash_code __code, std::_Hashtable::__node_type *__n, std::_Hashtable::size_type __n_elt = 1);
        std::_Hashtable::iterator _M_insert_multi_node(std::_Hashtable::__node_type *__hint, const std::_Hashtable::key_type &__k, std::_Hashtable::__hash_code __code, std::_Hashtable::__node_type *__n);
        template <typename ..._Args> std::pair<iterator, bool> _M_emplace(std::true_type, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable::iterator _M_emplace(std::false_type __uk, _Args &&...__args)         {
            return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...);
        }
        template <typename ..._Args> std::_Hashtable::iterator _M_emplace(std::_Hashtable::const_iterator, std::true_type __uk, _Args &&...__args)         {
            return _M_emplace(__uk, std::forward<_Args>(__args)...).first;
        }
        template <typename ..._Args> std::_Hashtable::iterator _M_emplace(std::_Hashtable::const_iterator, std::false_type, _Args &&...__args);
        template <typename _Arg, typename _NodeGenerator> std::pair<iterator, bool> _M_insert(_Arg &&, const _NodeGenerator &, std::true_type, std::_Hashtable::size_type = 1);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable::iterator _M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, std::false_type __uk)         {
            return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen, __uk);
        }
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable::iterator _M_insert(std::_Hashtable::const_iterator, _Arg &&__arg, const _NodeGenerator &__node_gen, std::true_type __uk)         {
            return _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
        }
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable::iterator _M_insert(std::_Hashtable::const_iterator, _Arg &&, const _NodeGenerator &, std::false_type);
        std::_Hashtable::size_type _M_erase(std::true_type, const std::_Hashtable::key_type &);
        std::_Hashtable::size_type _M_erase(std::false_type, const std::_Hashtable::key_type &);
        std::_Hashtable::iterator _M_erase(std::_Hashtable::size_type __bkt, std::_Hashtable::__node_base *__prev_n, std::_Hashtable::__node_type *__n);
    public:
        template <typename ..._Args> std::_Hashtable::__ireturn_type emplace(_Args &&...__args)         {
            return _M_emplace(std::_Hashtable::__unique_keys(), std::forward<_Args>(__args)...);
        }
        template <typename ..._Args> std::_Hashtable::iterator emplace_hint(std::_Hashtable::const_iterator __hint, _Args &&...__args)         {
            return _M_emplace(__hint, std::_Hashtable::__unique_keys(), std::forward<_Args>(__args)...);
        }
        std::_Hashtable::iterator erase(std::_Hashtable::const_iterator);
        std::_Hashtable::iterator erase(std::_Hashtable::iterator __it)         {
            return erase(std::_Hashtable::const_iterator(__it));
        }
        std::_Hashtable::size_type erase(const std::_Hashtable::key_type &__k)         {
            return _M_erase(std::_Hashtable::__unique_keys(), __k);
        }
        std::_Hashtable::iterator erase(std::_Hashtable::const_iterator, std::_Hashtable::const_iterator);
        void clear() noexcept;
        void rehash(std::_Hashtable::size_type __bkt_count);
        std::_Hashtable::insert_return_type _M_reinsert_node(std::_Hashtable::node_type &&__nh)         {
            std::_Hashtable::insert_return_type __ret;
            if (__nh.empty())
                __ret.position = end();
            else {
                ;
                const std::_Hashtable::key_type &__k = __nh._M_key();
                std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
                std::_Hashtable::size_type __bkt = _M_bucket_index(__k, __code);
                if (std::_Hashtable::__node_type *__n = this->_M_find_node(__bkt, __k, __code)) {
                    __ret.node = std::move(__nh);
                    __ret.position = std::_Hashtable::iterator(__n);
                    __ret.inserted = false;
                } else {
                    __ret.position = this->_M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr);
                    __nh._M_ptr = nullptr;
                    __ret.inserted = true;
                }
            }
            return __ret;
        }
        std::_Hashtable::iterator _M_reinsert_node_multi(std::_Hashtable::const_iterator __hint, std::_Hashtable::node_type &&__nh)         {
            if (__nh.empty())
                return end();
            ;
            const std::_Hashtable::key_type &__k = __nh._M_key();
            auto __code = this->_M_hash_code(__k);
            auto __ret = this->_M_insert_multi_node(__hint._M_cur, __k, __code, __nh._M_ptr);
            __nh._M_ptr = nullptr;
            return __ret;
        }
    private:
        std::_Hashtable::node_type _M_extract_node(std::size_t __bkt, std::_Hashtable::__node_base *__prev_n)         {
            std::_Hashtable::__node_type *__n = static_cast<std::_Hashtable::__node_type *>(__prev_n->_M_nxt);
            if (__prev_n == this->_M_buckets[__bkt])
                this->_M_remove_bucket_begin(__bkt, __n->_M_next(), __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
            else if (__n->_M_nxt) {
                std::_Hashtable::size_type __next_bkt = _M_bucket_index(__n->_M_next());
                if (__next_bkt != __bkt)
                    this->_M_buckets[__next_bkt] = __prev_n;
            }
            __prev_n->_M_nxt = __n->_M_nxt;
            __n->_M_nxt = nullptr;
            --this->_M_element_count;
            return {__n, this->_M_node_allocator()};
        }
    public:
        std::_Hashtable::node_type extract(std::_Hashtable::const_iterator __pos)         {
            std::size_t __bkt = _M_bucket_index(__pos._M_cur);
            return this->_M_extract_node(__bkt, this->_M_get_previous_node(__bkt, __pos._M_cur));
        }
        std::_Hashtable::node_type extract(const _Key &__k)         {
            std::_Hashtable::node_type __nh;
            std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
            std::size_t __bkt = _M_bucket_index(__k, __code);
            if (std::_Hashtable::__node_base *__prev_node = this->_M_find_before_node(__bkt, __k, __code))
                __nh = this->_M_extract_node(__bkt, __prev_node);
            return __nh;
        }
        template <typename _Compatible_Hashtable> void _M_merge_unique(_Compatible_Hashtable &__src) noexcept         {
            static_assert(is_same_v<typename _Compatible_Hashtable::node_type, std::_Hashtable::node_type>, "Node types are compatible");
            ;
            auto __n_elt = __src.size();
            for (auto __i = __src.begin(), auto __end = __src.end(); __i != __end;) {
                auto __pos = __i++;
                const std::_Hashtable::key_type &__k = this->_M_extract()(*__pos);
                std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
                std::_Hashtable::size_type __bkt = _M_bucket_index(__k, __code);
                if (this->_M_find_node(__bkt, __k, __code) == nullptr) {
                    auto __nh = __src.extract(__pos);
                    this->_M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr, __n_elt);
                    __nh._M_ptr = nullptr;
                    __n_elt = 1;
                } else if (__n_elt != 1)
                    --__n_elt;
            }
        }
        template <typename _Compatible_Hashtable> void _M_merge_multi(_Compatible_Hashtable &__src) noexcept         {
            static_assert(is_same_v<typename _Compatible_Hashtable::node_type, std::_Hashtable::node_type>, "Node types are compatible");
            ;
            this->reserve(this->size() + __src.size());
            for (auto __i = __src.begin(), auto __end = __src.end(); __i != __end;)
                this->_M_reinsert_node_multi(cend(), __src.extract(__i++));
        }
    private:
        void _M_rehash_aux(std::_Hashtable::size_type __bkt_count, std::true_type);
        void _M_rehash_aux(std::_Hashtable::size_type __bkt_count, std::false_type);
        void _M_rehash(std::_Hashtable::size_type __bkt_count, const std::_Hashtable::__rehash_state &__state);
    };
template<> class _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> : public __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>, public __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, public __detail::_Insert<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, public __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, public __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>, private __detail::_Hashtable_alloc<__alloc_rebind<allocator<pair<const int, int>>, __detail::_Hash_node<pair<const int, int>, _Hashtable_traits<false, false, true>::__hash_cached::value>>> {
        static_assert(is_same<typename remove_cv<pair<const int, int>>::type, pair<const int, int>>::value, "unordered container must have a non-const, non-volatile value_type");
        static_assert(is_same<typename allocator<pair<const int, int>>::value_type, std::pair<const int, int>>{}, "unordered container must have the same value_type as its allocator");
        using __traits_type = std::__detail::_Hashtable_traits<false, false, true>;
        using __hash_cached = typename __traits_type::__hash_cached;
        using __node_type = __detail::_Hash_node<pair<const int, int>, __hash_cached::value>;
        using __node_alloc_type = __alloc_rebind<std::allocator<std::pair<const int, int>>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type>;
        using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;
        using __value_alloc_traits = typename __hashtable_alloc::__value_alloc_traits;
        using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;
        using __node_base = typename __hashtable_alloc::__node_base;
        using __bucket_type = typename __hashtable_alloc::__bucket_type;
    public:
        typedef int key_type;
        typedef std::pair<const int, int> value_type;
        typedef std::allocator<std::pair<const int, int>> allocator_type;
        typedef std::equal_to<int> key_equal;
        typedef typename __value_alloc_traits::pointer pointer;
        typedef typename __value_alloc_traits::const_pointer const_pointer;
        typedef std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &reference;
        typedef const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &const_reference;
    private:
        using __rehash_type = std::__detail::_Prime_rehash_policy;
        using __rehash_state = typename __rehash_type::_State;
        using __constant_iterators = typename __traits_type::__constant_iterators;
        using __unique_keys = typename __traits_type::__unique_keys;
        using __key_extract = typename std::conditional<__constant_iterators::value, __detail::_Identity, __detail::_Select1st>::type;
        using __hashtable_base = __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>;
        using __hash_code_base = typename __hashtable_base::__hash_code_base;
        using __hash_code = typename __hashtable_base::__hash_code;
        using __ireturn_type = typename __hashtable_base::__ireturn_type;
        using __map_base = __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>;
        using __rehash_base = __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>;
        using __eq_base = __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>;
        using __reuse_or_alloc_node_gen_t = __detail::_ReuseOrAllocNode<__node_alloc_type>;
        using __alloc_node_gen_t = __detail::_AllocNode<__node_alloc_type>;
        struct _Scoped_node;
        template <typename _Ht> static constexpr typename conditional<std::is_lvalue_reference<_Ht>::value, const value_type &, value_type &&>::type __fwd_value_for(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type &__val) noexcept;
        template <typename _Cond> using __if_hash_cached = __or_<__not_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_cached>, _Cond>;
        template <typename _Cond> using __if_hash_not_cached = __or_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_cached, _Cond>;
        struct __hash_code_base_access : std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base {
            using __hash_code_base::_M_bucket_index;
        };
        static_assert(noexcept(declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code_base_access &>()._M_bucket_index((const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *)nullptr, (std::size_t)0)), "Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept");
        static_assert(__if_hash_cached<is_default_constructible<_Mod_range_hashing>>::value, "Functor used to map hash code to bucket index must be default constructible");
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Map_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa> struct _Insert_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Constant_iteratorsa = _Traits::__constant_iterators::value> struct _Insert;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Equality;
    public:
        using size_type = typename __hashtable_base::size_type;
        using difference_type = typename __hashtable_base::difference_type;
        using iterator = typename __hashtable_base::iterator;
        using const_iterator = typename __hashtable_base::const_iterator;
        using local_iterator = typename __hashtable_base::local_iterator;
        using const_local_iterator = typename __hashtable_base::const_local_iterator;
        using node_type = _Node_handle<int, std::pair<const int, int>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_alloc_type>;
        using insert_return_type = _Node_insert_return<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type>;
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *_M_buckets;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_bucket_count;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base _M_before_begin;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_element_count;
        std::__detail::_Prime_rehash_policy _M_rehash_policy;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type _M_single_bucket;
        bool _M_uses_single_bucket(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *__bkts) const;
        bool _M_uses_single_bucket() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hashtable_alloc &_M_base_alloc();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *_M_allocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count);
        void _M_deallocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__bucket_type *__bkts, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count);
        void _M_deallocate_buckets();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *_M_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *_M_begin() const;
        template <typename _Ht> void _M_assign_elements(_Ht &&);
        template <typename _Ht, typename _NodeGenerator> void _M_assign(_Ht &&, const _NodeGenerator &);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&, std::true_type);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&, std::false_type);
        void _M_reset() noexcept;
        _Hashtable(const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__h, const std::equal_to<int> &__eq, const std::__detail::_Select1st &__exk, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
    public:
        _Hashtable() = default
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        template <typename _InputIterator> _Hashtable(_InputIterator __first, _InputIterator __last, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&) noexcept;
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &);
        explicit _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        explicit _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        template <typename _InputIterator> _Hashtable(_InputIterator __f, _InputIterator __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        _Hashtable(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type> __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type &__a);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &operator=(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &operator=(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &&__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &operator=(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::value_type> __l);
        ~_Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>() noexcept;
        void swap(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>> &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator begin() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator begin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator end() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator end() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator cbegin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator cend() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type size() const noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::allocator_type get_allocator() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type max_size() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_equal key_eq() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type max_bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type bucket_size(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type bucket(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator cbegin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_local_iterator cend(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt) const;
        float load_factor() const noexcept;
        const std::__detail::_Prime_rehash_policy &__rehash_policy() const;
        void __rehash_policy(const std::__detail::_Prime_rehash_policy &__pol);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type count(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
        std::pair<iterator, iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k);
        std::pair<const_iterator, const_iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k) const;
    protected:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_bucket_index(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n) const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_bucket_index(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __c) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *_M_find_before_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *_M_find_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__key, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __c) const;
        void _M_insert_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *);
        void _M_remove_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__next_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __next_bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *_M_get_previous_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *__n);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert_unique_node(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __n_elt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert_multi_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__hint, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n);
        template <typename ..._Args> std::pair<iterator, bool> _M_emplace(std::true_type, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_emplace(std::false_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, std::true_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, std::false_type, _Args &&...__args);
        template <typename _Arg, typename _NodeGenerator> std::pair<iterator, bool> _M_insert(_Arg &&, const _NodeGenerator &, std::true_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, std::false_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, _Arg &&__arg, const _NodeGenerator &__node_gen, std::true_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, _Arg &&, const _NodeGenerator &, std::false_type);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_erase(std::true_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type _M_erase(std::false_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *__prev_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_type *__n);
    public:
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__ireturn_type emplace(_Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator emplace_hint(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator __hint, _Args &&...__args);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator __it);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type erase(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator);
        void clear() noexcept;
        void rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::insert_return_type _M_reinsert_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type &&__nh);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::iterator _M_reinsert_node_multi(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator __hint, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type &&__nh);
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type _M_extract_node(std::size_t __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__node_base *__prev_n);
    public:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type extract(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::const_iterator __pos);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::node_type extract(const int &__k);
        template <typename _Compatible_Hashtable> void _M_merge_unique(_Compatible_Hashtable &__src) noexcept;
        template <typename _Compatible_Hashtable> void _M_merge_multi(_Compatible_Hashtable &__src) noexcept;
    private:
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count, std::true_type);
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count, std::false_type);
        void _M_rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::size_type __bkt_count, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::__rehash_state &__state);
    };
template<> class _Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> : public __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, false>>, public __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, public __detail::_Insert<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, public __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, public __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>, private __detail::_Hashtable_alloc<__alloc_rebind<allocator<pair<const int, int>>, __detail::_Hash_node<pair<const int, int>, _Hashtable_traits<false, false, false>::__hash_cached::value>>> {
        static_assert(is_same<typename remove_cv<pair<const int, int>>::type, pair<const int, int>>::value, "unordered container must have a non-const, non-volatile value_type");
        static_assert(is_same<typename allocator<pair<const int, int>>::value_type, std::pair<const int, int>>{}, "unordered container must have the same value_type as its allocator");
        using __traits_type = std::__detail::_Hashtable_traits<false, false, false>;
        using __hash_cached = typename __traits_type::__hash_cached;
        using __node_type = __detail::_Hash_node<pair<const int, int>, __hash_cached::value>;
        using __node_alloc_type = __alloc_rebind<std::allocator<std::pair<const int, int>>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type>;
        using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;
        using __value_alloc_traits = typename __hashtable_alloc::__value_alloc_traits;
        using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;
        using __node_base = typename __hashtable_alloc::__node_base;
        using __bucket_type = typename __hashtable_alloc::__bucket_type;
    public:
        typedef int key_type;
        typedef std::pair<const int, int> value_type;
        typedef std::allocator<std::pair<const int, int>> allocator_type;
        typedef std::equal_to<int> key_equal;
        typedef typename __value_alloc_traits::pointer pointer;
        typedef typename __value_alloc_traits::const_pointer const_pointer;
        typedef std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &reference;
        typedef const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &const_reference;
    private:
        using __rehash_type = std::__detail::_Prime_rehash_policy;
        using __rehash_state = typename __rehash_type::_State;
        using __constant_iterators = typename __traits_type::__constant_iterators;
        using __unique_keys = typename __traits_type::__unique_keys;
        using __key_extract = typename std::conditional<__constant_iterators::value, __detail::_Identity, __detail::_Select1st>::type;
        using __hashtable_base = __detail::_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, false>>;
        using __hash_code_base = typename __hashtable_base::__hash_code_base;
        using __hash_code = typename __hashtable_base::__hash_code;
        using __ireturn_type = typename __hashtable_base::__ireturn_type;
        using __map_base = __detail::_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>;
        using __rehash_base = __detail::_Rehash_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>;
        using __eq_base = __detail::_Equality<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>;
        using __reuse_or_alloc_node_gen_t = __detail::_ReuseOrAllocNode<__node_alloc_type>;
        using __alloc_node_gen_t = __detail::_AllocNode<__node_alloc_type>;
        struct _Scoped_node;
        template <typename _Ht> static constexpr typename conditional<std::is_lvalue_reference<_Ht>::value, const value_type &, value_type &&>::type __fwd_value_for(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type &__val) noexcept;
        template <typename _Cond> using __if_hash_cached = __or_<__not_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_cached>, _Cond>;
        template <typename _Cond> using __if_hash_not_cached = __or_<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_cached, _Cond>;
        struct __hash_code_base_access : std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base {
            using __hash_code_base::_M_bucket_index;
        };
        static_assert(noexcept(declval<const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code_base_access &>()._M_bucket_index((const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *)nullptr, (std::size_t)0)), "Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept");
        static_assert(__if_hash_cached<is_default_constructible<_Mod_range_hashing>>::value, "Functor used to map hash code to bucket index must be default constructible");
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Map_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa> struct _Insert_base;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Constant_iteratorsa = _Traits::__constant_iterators::value> struct _Insert;
        friend template <typename _Keya, typename _Valuea, typename _Alloca, typename _ExtractKeya, typename _Equala, typename _H1a, typename _H2a, typename _Hasha, typename _RehashPolicya, typename _Traitsa, bool _Unique_keysa = _Traits::__unique_keys::value> struct _Equality;
    public:
        using size_type = typename __hashtable_base::size_type;
        using difference_type = typename __hashtable_base::difference_type;
        using iterator = typename __hashtable_base::iterator;
        using const_iterator = typename __hashtable_base::const_iterator;
        using local_iterator = typename __hashtable_base::local_iterator;
        using const_local_iterator = typename __hashtable_base::const_local_iterator;
        using node_type = _Node_handle<int, std::pair<const int, int>, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_alloc_type>;
        using insert_return_type = _Node_insert_return<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type>;
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *_M_buckets;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_bucket_count;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base _M_before_begin;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_element_count;
        std::__detail::_Prime_rehash_policy _M_rehash_policy;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type _M_single_bucket;
        bool _M_uses_single_bucket(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *__bkts) const;
        bool _M_uses_single_bucket() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hashtable_alloc &_M_base_alloc();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *_M_allocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count);
        void _M_deallocate_buckets(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__bucket_type *__bkts, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count);
        void _M_deallocate_buckets();
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *_M_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *_M_begin() const;
        template <typename _Ht> void _M_assign_elements(_Ht &&);
        template <typename _Ht, typename _NodeGenerator> void _M_assign(_Ht &&, const _NodeGenerator &);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&, std::true_type);
        void _M_move_assign(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&, std::false_type);
        void _M_reset() noexcept;
        _Hashtable(const std::hash<int> &__h1, const std::__detail::_Mod_range_hashing &__h2, const std::__detail::_Default_ranged_hash &__h, const std::equal_to<int> &__eq, const std::__detail::_Select1st &__exk, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
    public:
        _Hashtable() = default
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        template <typename _InputIterator> _Hashtable(_InputIterator __first, _InputIterator __last, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &, const std::__detail::_Mod_range_hashing &, const std::__detail::_Default_ranged_hash &, const std::equal_to<int> &, const std::__detail::_Select1st &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&) noexcept;
        _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &);
        explicit _Hashtable(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        explicit _Hashtable(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        template <typename _InputIterator> _Hashtable(_InputIterator __f, _InputIterator __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        _Hashtable(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type> __l, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count_hint, const std::hash<int> &__hf, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal &__eql, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type &__a);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &operator=(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &operator=(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &&__ht);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &operator=(initializer_list<std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::value_type> __l);
        ~_Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, false>>() noexcept;
        void swap(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>> &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator begin() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator begin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator end() noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator end() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator cbegin() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator cend() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type size() const noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::allocator_type get_allocator() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type max_size() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_equal key_eq() const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type max_bucket_count() const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type bucket_size(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type bucket(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator end(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator cbegin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_local_iterator cend(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt) const;
        float load_factor() const noexcept;
        const std::__detail::_Prime_rehash_policy &__rehash_policy() const;
        void __rehash_policy(const std::__detail::_Prime_rehash_policy &__pol);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator find(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type count(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
        std::pair<iterator, iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k);
        std::pair<const_iterator, const_iterator> equal_range(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k) const;
    protected:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_bucket_index(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n) const noexcept;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_bucket_index(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __c) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *_M_find_before_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code) const;
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *_M_find_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__key, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __c) const;
        void _M_insert_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *);
        void _M_remove_bucket_begin(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__next_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __next_bkt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *_M_get_previous_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *__n);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert_unique_node(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __n_elt);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert_multi_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__hint, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__hash_code __code, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n);
        template <typename ..._Args> std::pair<iterator, bool> _M_emplace(std::true_type, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_emplace(std::false_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, std::true_type __uk, _Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_emplace(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, std::false_type, _Args &&...__args);
        template <typename _Arg, typename _NodeGenerator> std::pair<iterator, bool> _M_insert(_Arg &&, const _NodeGenerator &, std::true_type, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, std::false_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, _Arg &&__arg, const _NodeGenerator &__node_gen, std::true_type __uk);
        template <typename _Arg, typename _NodeGenerator> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_insert(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, _Arg &&, const _NodeGenerator &, std::false_type);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_erase(std::true_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type _M_erase(std::false_type, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *__prev_n, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_type *__n);
    public:
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__ireturn_type emplace(_Args &&...__args);
        template <typename ..._Args> std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator emplace_hint(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator __hint, _Args &&...__args);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator __it);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type erase(const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::key_type &__k);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator erase(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator);
        void clear() noexcept;
        void rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::insert_return_type _M_reinsert_node(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type &&__nh);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::iterator _M_reinsert_node_multi(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator __hint, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type &&__nh);
    private:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type _M_extract_node(std::size_t __bkt, std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__node_base *__prev_n);
    public:
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type extract(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::const_iterator __pos);
        std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::node_type extract(const int &__k);
        template <typename _Compatible_Hashtable> void _M_merge_unique(_Compatible_Hashtable &__src) noexcept;
        template <typename _Compatible_Hashtable> void _M_merge_multi(_Compatible_Hashtable &__src) noexcept;
    private:
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count, std::true_type);
        void _M_rehash_aux(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count, std::false_type);
        void _M_rehash(std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::size_type __bkt_count, const std::_Hashtable<int, std::pair<const int, int>, std::allocator<std::pair<const int, int>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, false>>::__rehash_state &__state);
    };
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_bucket_begin(std::_Hashtable::size_type __bkt) const -> std::_Hashtable::__node_type *     {
        std::_Hashtable::__node_base *__n = this->_M_buckets[__bkt];
        return __n ? static_cast<std::_Hashtable::__node_type *>(__n->_M_nxt) : nullptr;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(std::_Hashtable::size_type __bkt_count_hint, const _H1 &__h1, const _H2 &__h2, const _Hash &__h, const _Equal &__eq, const _ExtractKey &__exk, const std::_Hashtable::allocator_type &__a) : _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(__h1, __h2, __h, __eq, __exk, __a)     {
        auto __bkt_count = this->_M_rehash_policy._M_next_bkt(__bkt_count_hint);
        if (__bkt_count > this->_M_bucket_count) {
            this->_M_buckets = this->_M_allocate_buckets(__bkt_count);
            this->_M_bucket_count = __bkt_count;
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename _InputIterator> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(_InputIterator __f, _InputIterator __l, std::_Hashtable::size_type __bkt_count_hint, const _H1 &__h1, const _H2 &__h2, const _Hash &__h, const _Equal &__eq, const _ExtractKey &__exk, const std::_Hashtable::allocator_type &__a) : _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(__h1, __h2, __h, __eq, __exk, __a)     {
        auto __nb_elems = __detail::__distance_fw(__f, __l);
        auto __bkt_count = this->_M_rehash_policy._M_next_bkt(std::max(this->_M_rehash_policy._M_bkt_for_elements(__nb_elems), __bkt_count_hint));
        if (__bkt_count > this->_M_bucket_count) {
            this->_M_buckets = this->_M_allocate_buckets(__bkt_count);
            this->_M_bucket_count = __bkt_count;
        }
        for (; __f != __l; ++__f)
            this->insert(*__f);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::operator=(const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &__ht) -> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &     {
        if (& __ht == this)
            return *this;
        if (__node_alloc_traits::_S_propagate_on_copy_assign()) {
            auto &__this_alloc = this->_M_node_allocator();
            auto &__that_alloc = __ht._M_node_allocator();
            if (!__node_alloc_traits::_S_always_equal() && __this_alloc != __that_alloc) {
                this->_M_deallocate_nodes(this->_M_begin());
                this->_M_before_begin._M_nxt = nullptr;
                _M_deallocate_buckets();
                this->_M_buckets = nullptr;
                std::__alloc_on_copy(__this_alloc, __that_alloc);
                __hashtable_base::operator=(__ht);
                this->_M_bucket_count = __ht._M_bucket_count;
                this->_M_element_count = __ht._M_element_count;
                this->_M_rehash_policy = __ht._M_rehash_policy;
                std::_Hashtable::__alloc_node_gen_t __alloc_node_gen(*this);
                try {
                    _M_assign(__ht, __alloc_node_gen);
                } catch (...) {
                    this->_M_reset();
                    throw;
                }
                return *this;
            }
            std::__alloc_on_copy(__this_alloc, __that_alloc);
        }
        _M_assign_elements(__ht);
        return *this;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename _Ht> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_assign_elements(_Ht &&__ht)     {
        std::_Hashtable::__bucket_type *__former_buckets = nullptr;
        std::size_t __former_bucket_count = this->_M_bucket_count;
        const std::_Hashtable::__rehash_state &__former_state = this->_M_rehash_policy._M_state();
        if (this->_M_bucket_count != __ht._M_bucket_count) {
            __former_buckets = this->_M_buckets;
            this->_M_buckets = this->_M_allocate_buckets(__ht._M_bucket_count);
            this->_M_bucket_count = __ht._M_bucket_count;
        } else
            __builtin_memset(this->_M_buckets, 0, this->_M_bucket_count * sizeof(std::_Hashtable::__bucket_type));
        try {
            __hashtable_base::operator=(std::forward<_Ht>(__ht));
            this->_M_element_count = __ht._M_element_count;
            this->_M_rehash_policy = __ht._M_rehash_policy;
            std::_Hashtable::__reuse_or_alloc_node_gen_t __roan(this->_M_begin(), *this);
            this->_M_before_begin._M_nxt = nullptr;
            _M_assign(std::forward<_Ht>(__ht), __roan);
            if (__former_buckets)
                _M_deallocate_buckets(__former_buckets, __former_bucket_count);
        } catch (...) {
            if (__former_buckets) {
                _M_deallocate_buckets();
                this->_M_rehash_policy._M_reset(__former_state);
                this->_M_buckets = __former_buckets;
                this->_M_bucket_count = __former_bucket_count;
            }
            __builtin_memset(this->_M_buckets, 0, this->_M_bucket_count * sizeof(std::_Hashtable::__bucket_type));
            throw;
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename _Ht, typename _NodeGenerator> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_assign(_Ht &&__ht, const _NodeGenerator &__node_gen)     {
        std::_Hashtable::__bucket_type *__buckets = nullptr;
        if (!this->_M_buckets)
            this->_M_buckets = __buckets = this->_M_allocate_buckets(this->_M_bucket_count);
        try {
            if (!__ht._M_before_begin._M_nxt)
                return;
            std::_Hashtable::__node_type *__ht_n = __ht._M_begin();
            std::_Hashtable::__node_type *__this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
            this->_M_copy_code(__this_n, __ht_n);
            this->_M_before_begin._M_nxt = __this_n;
            this->_M_buckets[_M_bucket_index(__this_n)] = & this->_M_before_begin;
            std::_Hashtable::__node_base *__prev_n = __this_n;
            for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next()) {
                __this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
                __prev_n->_M_nxt = __this_n;
                this->_M_copy_code(__this_n, __ht_n);
                std::_Hashtable::size_type __bkt = _M_bucket_index(__this_n);
                if (!this->_M_buckets[__bkt])
                    this->_M_buckets[__bkt] = __prev_n;
                __prev_n = __this_n;
            }
        } catch (...) {
            this->clear();
            if (__buckets)
                _M_deallocate_buckets();
            throw;
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_reset() noexcept     {
        this->_M_rehash_policy._M_reset();
        this->_M_bucket_count = 1;
        this->_M_single_bucket = nullptr;
        this->_M_buckets = & this->_M_single_bucket;
        this->_M_before_begin._M_nxt = nullptr;
        this->_M_element_count = 0;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_move_assign(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&__ht, std::true_type)     {
        this->_M_deallocate_nodes(this->_M_begin());
        _M_deallocate_buckets();
        __hashtable_base::operator=(std::move(__ht));
        this->_M_rehash_policy = __ht._M_rehash_policy;
        if (!__ht._M_uses_single_bucket())
            this->_M_buckets = __ht._M_buckets;
        else {
            this->_M_buckets = & this->_M_single_bucket;
            this->_M_single_bucket = __ht._M_single_bucket;
        }
        this->_M_bucket_count = __ht._M_bucket_count;
        this->_M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
        this->_M_element_count = __ht._M_element_count;
        std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());
        if (this->_M_begin())
            this->_M_buckets[_M_bucket_index(this->_M_begin())] = & this->_M_before_begin;
        __ht._M_reset();
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_move_assign(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&__ht, std::false_type)     {
        if (__ht._M_node_allocator() == this->_M_node_allocator())
            _M_move_assign(std::move(__ht), std::true_type());
        else {
            _M_assign_elements(std::move(__ht));
            __ht.clear();
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &__ht) : std::_Hashtable::__hashtable_base(__ht), std::_Hashtable::__map_base(__ht), std::_Hashtable::__rehash_base(__ht), std::_Hashtable::__hashtable_alloc(__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())), _M_buckets(nullptr), _M_bucket_count(__ht._M_bucket_count), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy)     {
        std::_Hashtable::__alloc_node_gen_t __alloc_node_gen(*this);
        _M_assign(__ht, __alloc_node_gen);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&__ht) noexcept : std::_Hashtable::__hashtable_base(__ht), std::_Hashtable::__map_base(__ht), std::_Hashtable::__rehash_base(__ht), std::_Hashtable::__hashtable_alloc(std::move(__ht._M_base_alloc())), _M_buckets(__ht._M_buckets), _M_bucket_count(__ht._M_bucket_count), _M_before_begin(__ht._M_before_begin._M_nxt), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy)     {
        if (__ht._M_uses_single_bucket()) {
            this->_M_buckets = & this->_M_single_bucket;
            this->_M_single_bucket = __ht._M_single_bucket;
        }
        if (this->_M_begin())
            this->_M_buckets[_M_bucket_index(this->_M_begin())] = & this->_M_before_begin;
        __ht._M_reset();
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &__ht, const std::_Hashtable::allocator_type &__a) : std::_Hashtable::__hashtable_base(__ht), std::_Hashtable::__map_base(__ht), std::_Hashtable::__rehash_base(__ht), std::_Hashtable::__hashtable_alloc(std::_Hashtable::__node_alloc_type(__a)), _M_buckets(), _M_bucket_count(__ht._M_bucket_count), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy)     {
        std::_Hashtable::__alloc_node_gen_t __alloc_node_gen(*this);
        _M_assign(__ht, __alloc_node_gen);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&__ht, const std::_Hashtable::allocator_type &__a) : std::_Hashtable::__hashtable_base(__ht), std::_Hashtable::__map_base(__ht), std::_Hashtable::__rehash_base(__ht), std::_Hashtable::__hashtable_alloc(std::_Hashtable::__node_alloc_type(__a)), _M_buckets(nullptr), _M_bucket_count(__ht._M_bucket_count), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy)     {
        if (__ht._M_node_allocator() == this->_M_node_allocator()) {
            if (__ht._M_uses_single_bucket()) {
                this->_M_buckets = & this->_M_single_bucket;
                this->_M_single_bucket = __ht._M_single_bucket;
            } else
                this->_M_buckets = __ht._M_buckets;
            this->_M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
            if (this->_M_begin())
                this->_M_buckets[_M_bucket_index(this->_M_begin())] = & this->_M_before_begin;
            __ht._M_reset();
        } else {
            std::_Hashtable::__alloc_node_gen_t __alloc_gen(*this);
            using _Fwd_Ht = typename conditional<__move_if_noexcept_cond<value_type>::value, const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &, _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&>::type;
            _M_assign(std::forward<_Fwd_Ht>(__ht), __alloc_gen);
            __ht.clear();
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::~_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>() noexcept     {
        this->clear();
        _M_deallocate_buckets();
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::swap(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &__x) noexcept(__and_<__is_nothrow_swappable<_H1>, __is_nothrow_swappable<_Equal>>::value_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::swap(_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &__x) noexcept(__and_<__is_nothrow_swappable<_H1>, __is_nothrow_swappable<_Equal>>::value)     {
        this->_M_swap(__x);
        std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
        std::swap(this->_M_rehash_policy, __x._M_rehash_policy);
        if (this->_M_uses_single_bucket()) {
            if (!__x._M_uses_single_bucket()) {
                this->_M_buckets = __x._M_buckets;
                __x._M_buckets = & __x._M_single_bucket;
            }
        } else if (__x._M_uses_single_bucket()) {
            __x._M_buckets = this->_M_buckets;
            this->_M_buckets = & this->_M_single_bucket;
        } else
            std::swap(this->_M_buckets, __x._M_buckets);
        std::swap(this->_M_bucket_count, __x._M_bucket_count);
        std::swap(this->_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
        std::swap(this->_M_element_count, __x._M_element_count);
        std::swap(this->_M_single_bucket, __x._M_single_bucket);
        if (this->_M_begin())
            this->_M_buckets[_M_bucket_index(this->_M_begin())] = & this->_M_before_begin;
        if (__x._M_begin())
            __x._M_buckets[__x._M_bucket_index(__x._M_begin())] = & __x._M_before_begin;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::find(const std::_Hashtable::key_type &__k) -> std::_Hashtable::iterator     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::size_t __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_type *__p = this->_M_find_node(__bkt, __k, __code);
        return __p ? std::_Hashtable::iterator(__p) : end();
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::find(const std::_Hashtable::key_type &__k) const -> std::_Hashtable::const_iterator     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::size_t __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_type *__p = this->_M_find_node(__bkt, __k, __code);
        return __p ? std::_Hashtable::const_iterator(__p) : end();
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::count(const std::_Hashtable::key_type &__k) const -> std::_Hashtable::size_type     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::size_t __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_type *__p = this->_M_bucket_begin(__bkt);
        if (!__p)
            return 0;
        std::size_t __result = 0;
        for (;; __p = __p->_M_next()) {
            if (this->_M_equals(__k, __code, __p))
                ++__result;
            else if (__result)
                break;
            if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)
                break;
        }
        return __result;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::equal_range(const std::_Hashtable::key_type &__k) -> pair<std::_Hashtable::iterator, std::_Hashtable::iterator>     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::size_t __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_type *__p = this->_M_find_node(__bkt, __k, __code);
        if (__p) {
            std::_Hashtable::__node_type *__p1 = __p->_M_next();
            while (__p1 && _M_bucket_index(__p1) == __bkt && this->_M_equals(__k, __code, __p1))
                __p1 = __p1->_M_next();
            return std::make_pair(std::_Hashtable::iterator(__p), std::_Hashtable::iterator(__p1));
        } else
            return std::make_pair(end(), end());
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::equal_range(const std::_Hashtable::key_type &__k) const -> pair<std::_Hashtable::const_iterator, std::_Hashtable::const_iterator>     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::size_t __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_type *__p = this->_M_find_node(__bkt, __k, __code);
        if (__p) {
            std::_Hashtable::__node_type *__p1 = __p->_M_next();
            while (__p1 && _M_bucket_index(__p1) == __bkt && this->_M_equals(__k, __code, __p1))
                __p1 = __p1->_M_next();
            return std::make_pair(std::_Hashtable::const_iterator(__p), std::_Hashtable::const_iterator(__p1));
        } else
            return std::make_pair(end(), end());
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_find_before_node(std::_Hashtable::size_type __bkt, const std::_Hashtable::key_type &__k, std::_Hashtable::__hash_code __code) const -> std::_Hashtable::__node_base *     {
        std::_Hashtable::__node_base *__prev_p = this->_M_buckets[__bkt];
        if (!__prev_p)
            return nullptr;
        for (std::_Hashtable::__node_type *__p = static_cast<std::_Hashtable::__node_type *>(__prev_p->_M_nxt); ; __p = __p->_M_next()) {
            if (this->_M_equals(__k, __code, __p))
                return __prev_p;
            if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)
                break;
            __prev_p = __p;
        }
        return nullptr;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_insert_bucket_begin(std::_Hashtable::size_type __bkt, std::_Hashtable::__node_type *__node)     {
        if (this->_M_buckets[__bkt]) {
            __node->_M_nxt = this->_M_buckets[__bkt]->_M_nxt;
            this->_M_buckets[__bkt]->_M_nxt = __node;
        } else {
            __node->_M_nxt = this->_M_before_begin._M_nxt;
            this->_M_before_begin._M_nxt = __node;
            if (__node->_M_nxt)
                this->_M_buckets[_M_bucket_index(__node->_M_next())] = __node;
            this->_M_buckets[__bkt] = & this->_M_before_begin;
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_remove_bucket_begin(std::_Hashtable::size_type __bkt, std::_Hashtable::__node_type *__next, std::_Hashtable::size_type __next_bkt)     {
        if (!__next || __next_bkt != __bkt) {
            if (__next)
                this->_M_buckets[__next_bkt] = this->_M_buckets[__bkt];
            if (& this->_M_before_begin == this->_M_buckets[__bkt])
                this->_M_before_begin._M_nxt = __next;
            this->_M_buckets[__bkt] = nullptr;
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_get_previous_node(std::_Hashtable::size_type __bkt, std::_Hashtable::__node_base *__n) -> std::_Hashtable::__node_base *     {
        std::_Hashtable::__node_base *__prev_n = this->_M_buckets[__bkt];
        while (__prev_n->_M_nxt != __n)
            __prev_n = __prev_n->_M_nxt;
        return __prev_n;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename ..._Args> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_emplace(std::true_type, _Args &&...__args) -> pair<std::_Hashtable::iterator, bool>     {
        std::_Hashtable::_Scoped_node __node{this, std::forward<_Args>(__args)...};
        const std::_Hashtable::key_type &__k = this->_M_extract()(__node._M_node->_M_v());
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::_Hashtable::size_type __bkt = _M_bucket_index(__k, __code);
        if (std::_Hashtable::__node_type *__p = this->_M_find_node(__bkt, __k, __code))
            return std::make_pair(std::_Hashtable::iterator(__p), false);
        auto __pos = this->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);
        __node._M_node = nullptr;
        return {__pos, true};
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename ..._Args> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_emplace(std::_Hashtable::const_iterator __hint, std::false_type, _Args &&...__args) -> std::_Hashtable::iterator     {
        std::_Hashtable::_Scoped_node __node{this, std::forward<_Args>(__args)...};
        const std::_Hashtable::key_type &__k = this->_M_extract()(__node._M_node->_M_v());
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        auto __pos = this->_M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);
        __node._M_node = nullptr;
        return __pos;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_insert_unique_node(const std::_Hashtable::key_type &__k, std::_Hashtable::size_type __bkt, std::_Hashtable::__hash_code __code, std::_Hashtable::__node_type *__node, std::_Hashtable::size_type __n_elt = 1) -> std::_Hashtable::iterator     {
        const std::_Hashtable::__rehash_state &__saved_state = this->_M_rehash_policy._M_state();
        std::pair<bool, std::size_t> __do_rehash = this->_M_rehash_policy._M_need_rehash(this->_M_bucket_count, this->_M_element_count, __n_elt);
        if (__do_rehash.first) {
            this->_M_rehash(__do_rehash.second, __saved_state);
            __bkt = _M_bucket_index(__k, __code);
        }
        this->_M_store_code(__node, __code);
        this->_M_insert_bucket_begin(__bkt, __node);
        ++this->_M_element_count;
        return std::_Hashtable::iterator(__node);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_insert_multi_node(std::_Hashtable::__node_type *__hint, const std::_Hashtable::key_type &__k, std::_Hashtable::__hash_code __code, std::_Hashtable::__node_type *__node) -> std::_Hashtable::iterator     {
        const std::_Hashtable::__rehash_state &__saved_state = this->_M_rehash_policy._M_state();
        std::pair<bool, std::size_t> __do_rehash = this->_M_rehash_policy._M_need_rehash(this->_M_bucket_count, this->_M_element_count, 1);
        if (__do_rehash.first)
            this->_M_rehash(__do_rehash.second, __saved_state);
        this->_M_store_code(__node, __code);
        std::_Hashtable::size_type __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_base *__prev = __builtin_expect(__hint != nullptr, false) && this->_M_equals(__k, __code, __hint) ? __hint : this->_M_find_before_node(__bkt, __k, __code);
        if (__prev) {
            __node->_M_nxt = __prev->_M_nxt;
            __prev->_M_nxt = __node;
            if (__builtin_expect(__prev == __hint, false))
                if (__node->_M_nxt && !this->_M_equals(__k, __code, __node->_M_next())) {
                    std::_Hashtable::size_type __next_bkt = _M_bucket_index(__node->_M_next());
                    if (__next_bkt != __bkt)
                        this->_M_buckets[__next_bkt] = __node;
                }
        } else
            this->_M_insert_bucket_begin(__bkt, __node);
        ++this->_M_element_count;
        return std::_Hashtable::iterator(__node);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename _Arg, typename _NodeGenerator> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_insert(_Arg &&__v, const _NodeGenerator &__node_gen, std::true_type, std::_Hashtable::size_type __n_elt = 1) -> pair<std::_Hashtable::iterator, bool>     {
        const std::_Hashtable::key_type &__k = this->_M_extract()(__v);
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::_Hashtable::size_type __bkt = _M_bucket_index(__k, __code);
        if (std::_Hashtable::__node_type *__node = this->_M_find_node(__bkt, __k, __code))
            return {std::_Hashtable::iterator(__node), false};
        std::_Hashtable::_Scoped_node __node{__node_gen(std::forward<_Arg>(__v)), this};
        auto __pos = this->_M_insert_unique_node(__k, __bkt, __code, __node._M_node, __n_elt);
        __node._M_node = nullptr;
        return {__pos, true};
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> template <typename _Arg, typename _NodeGenerator> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_insert(std::_Hashtable::const_iterator __hint, _Arg &&__v, const _NodeGenerator &__node_gen, std::false_type) -> std::_Hashtable::iterator     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));
        std::_Hashtable::_Scoped_node __node{__node_gen(std::forward<_Arg>(__v)), this};
        const std::_Hashtable::key_type &__k = this->_M_extract()(__node._M_node->_M_v());
        auto __pos = this->_M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);
        __node._M_node = nullptr;
        return __pos;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::erase(std::_Hashtable::const_iterator __it) -> std::_Hashtable::iterator     {
        std::_Hashtable::__node_type *__n = __it._M_cur;
        std::size_t __bkt = _M_bucket_index(__n);
        std::_Hashtable::__node_base *__prev_n = this->_M_get_previous_node(__bkt, __n);
        return _M_erase(__bkt, __prev_n, __n);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_erase(std::_Hashtable::size_type __bkt, std::_Hashtable::__node_base *__prev_n, std::_Hashtable::__node_type *__n) -> std::_Hashtable::iterator     {
        if (__prev_n == this->_M_buckets[__bkt])
            this->_M_remove_bucket_begin(__bkt, __n->_M_next(), __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
        else if (__n->_M_nxt) {
            std::_Hashtable::size_type __next_bkt = _M_bucket_index(__n->_M_next());
            if (__next_bkt != __bkt)
                this->_M_buckets[__next_bkt] = __prev_n;
        }
        __prev_n->_M_nxt = __n->_M_nxt;
        std::_Hashtable::iterator __result(__n->_M_next());
        this->_M_deallocate_node(__n);
        --this->_M_element_count;
        return __result;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_erase(std::true_type, const std::_Hashtable::key_type &__k) -> std::_Hashtable::size_type     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::size_t __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_base *__prev_n = this->_M_find_before_node(__bkt, __k, __code);
        if (!__prev_n)
            return 0;
        std::_Hashtable::__node_type *__n = static_cast<std::_Hashtable::__node_type *>(__prev_n->_M_nxt);
        _M_erase(__bkt, __prev_n, __n);
        return 1;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_erase(std::false_type, const std::_Hashtable::key_type &__k) -> std::_Hashtable::size_type     {
        std::_Hashtable::__hash_code __code = this->_M_hash_code(__k);
        std::size_t __bkt = _M_bucket_index(__k, __code);
        std::_Hashtable::__node_base *__prev_n = this->_M_find_before_node(__bkt, __k, __code);
        if (!__prev_n)
            return 0;
        std::_Hashtable::__node_type *__n = static_cast<std::_Hashtable::__node_type *>(__prev_n->_M_nxt);
        std::_Hashtable::__node_type *__n_last = __n;
        std::size_t __n_last_bkt = __bkt;
        do {
            __n_last = __n_last->_M_next();
            if (!__n_last)
                break;
            __n_last_bkt = _M_bucket_index(__n_last);
        } while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));
        std::_Hashtable::size_type __result = 0;
        do {
            std::_Hashtable::__node_type *__p = __n->_M_next();
            this->_M_deallocate_node(__n);
            __n = __p;
            ++__result;
            --this->_M_element_count;
        } while (__n != __n_last);
        if (__prev_n == this->_M_buckets[__bkt])
            this->_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
        else if (__n_last && __n_last_bkt != __bkt)
            this->_M_buckets[__n_last_bkt] = __prev_n;
        __prev_n->_M_nxt = __n_last;
        return __result;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::erase(std::_Hashtable::const_iterator __first, std::_Hashtable::const_iterator __last) -> std::_Hashtable::iterator     {
        std::_Hashtable::__node_type *__n = __first._M_cur;
        std::_Hashtable::__node_type *__last_n = __last._M_cur;
        if (__n == __last_n)
            return std::_Hashtable::iterator(__n);
        std::size_t __bkt = _M_bucket_index(__n);
        std::_Hashtable::__node_base *__prev_n = this->_M_get_previous_node(__bkt, __n);
        bool __is_bucket_begin = __n == this->_M_bucket_begin(__bkt);
        std::size_t __n_bkt = __bkt;
        for (;;) {
            do {
                std::_Hashtable::__node_type *__tmp = __n;
                __n = __n->_M_next();
                this->_M_deallocate_node(__tmp);
                --this->_M_element_count;
                if (!__n)
                    break;
                __n_bkt = _M_bucket_index(__n);
            } while (__n != __last_n && __n_bkt == __bkt);
            if (__is_bucket_begin)
                this->_M_remove_bucket_begin(__bkt, __n, __n_bkt);
            if (__n == __last_n)
                break;
            __is_bucket_begin = true;
            __bkt = __n_bkt;
        }
        if (__n && (__n_bkt != __bkt || __is_bucket_begin))
            this->_M_buckets[__n_bkt] = __prev_n;
        __prev_n->_M_nxt = __n;
        return std::_Hashtable::iterator(__n);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::clear() noexcept     {
        this->_M_deallocate_nodes(this->_M_begin());
        __builtin_memset(this->_M_buckets, 0, this->_M_bucket_count * sizeof(std::_Hashtable::__bucket_type));
        this->_M_element_count = 0;
        this->_M_before_begin._M_nxt = nullptr;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::rehash(std::_Hashtable::size_type __bkt_count)     {
        const std::_Hashtable::__rehash_state &__saved_state = this->_M_rehash_policy._M_state();
        __bkt_count = std::max(this->_M_rehash_policy._M_bkt_for_elements(this->_M_element_count + 1), __bkt_count);
        __bkt_count = this->_M_rehash_policy._M_next_bkt(__bkt_count);
        if (__bkt_count != this->_M_bucket_count)
            this->_M_rehash(__bkt_count, __saved_state);
        else
            this->_M_rehash_policy._M_reset(__saved_state);
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_rehash(std::_Hashtable::size_type __bkt_count, const std::_Hashtable::__rehash_state &__state)     {
        try {
            _M_rehash_aux(__bkt_count, std::_Hashtable::__unique_keys());
        } catch (...) {
            this->_M_rehash_policy._M_reset(__state);
            throw;
        }
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_rehash_aux(std::_Hashtable::size_type __bkt_count, std::true_type)     {
        std::_Hashtable::__bucket_type *__new_buckets = this->_M_allocate_buckets(__bkt_count);
        std::_Hashtable::__node_type *__p = this->_M_begin();
        this->_M_before_begin._M_nxt = nullptr;
        std::size_t __bbegin_bkt = 0;
        while (__p)
            {
                std::_Hashtable::__node_type *__next = __p->_M_next();
                std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __bkt_count);
                if (!__new_buckets[__bkt]) {
                    __p->_M_nxt = this->_M_before_begin._M_nxt;
                    this->_M_before_begin._M_nxt = __p;
                    __new_buckets[__bkt] = & this->_M_before_begin;
                    if (__p->_M_nxt)
                        __new_buckets[__bbegin_bkt] = __p;
                    __bbegin_bkt = __bkt;
                } else {
                    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
                    __new_buckets[__bkt]->_M_nxt = __p;
                }
                __p = __next;
            }
        _M_deallocate_buckets();
        this->_M_bucket_count = __bkt_count;
        this->_M_buckets = __new_buckets;
    }
    template <typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits> void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>::_M_rehash_aux(std::_Hashtable::size_type __bkt_count, std::false_type)     {
        std::_Hashtable::__bucket_type *__new_buckets = this->_M_allocate_buckets(__bkt_count);
        std::_Hashtable::__node_type *__p = this->_M_begin();
        this->_M_before_begin._M_nxt = nullptr;
        std::size_t __bbegin_bkt = 0;
        std::size_t __prev_bkt = 0;
        std::_Hashtable::__node_type *__prev_p = nullptr;
        bool __check_bucket = false;
        while (__p)
            {
                std::_Hashtable::__node_type *__next = __p->_M_next();
                std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __bkt_count);
                if (__prev_p && __prev_bkt == __bkt) {
                    __p->_M_nxt = __prev_p->_M_nxt;
                    __prev_p->_M_nxt = __p;
                    __check_bucket = true;
                } else {
                    if (__check_bucket) {
                        if (__prev_p->_M_nxt) {
                            std::size_t __next_bkt = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __bkt_count);
                            if (__next_bkt != __prev_bkt)
                                __new_buckets[__next_bkt] = __prev_p;
                        }
                        __check_bucket = false;
                    }
                    if (!__new_buckets[__bkt]) {
                        __p->_M_nxt = this->_M_before_begin._M_nxt;
                        this->_M_before_begin._M_nxt = __p;
                        __new_buckets[__bkt] = & this->_M_before_begin;
                        if (__p->_M_nxt)
                            __new_buckets[__bbegin_bkt] = __p;
                        __bbegin_bkt = __bkt;
                    } else {
                        __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
                        __new_buckets[__bkt]->_M_nxt = __p;
                    }
                }
                __prev_p = __p;
                __prev_bkt = __bkt;
                __p = __next;
            }
        if (__check_bucket && __prev_p->_M_nxt) {
            std::size_t __next_bkt = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __bkt_count);
            if (__next_bkt != __prev_bkt)
                __new_buckets[__next_bkt] = __prev_p;
        }
        _M_deallocate_buckets();
        this->_M_bucket_count = __bkt_count;
        this->_M_buckets = __new_buckets;
    }
    template <typename, typename, typename> class _Hash_merge_helper {
    };
    template <typename _Hash> using _RequireNotAllocatorOrIntegral = __enable_if_t<!__or_<is_integral<_Hash>, __is_allocator<_Hash>>::value>;
}
namespace std {
    template <bool _Cache> using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;
    template <typename _Key, typename _Tp, typename _Hash = hash<_Key>, typename _Pred = std::equal_to<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp>>, typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>> using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, _Tr>;
    template <bool _Cache> using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;
    template <typename _Key, typename _Tp, typename _Hash = hash<_Key>, typename _Pred = std::equal_to<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp>>, typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>> using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, _Tr>;
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> class unordered_multimap
template<> class unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> {
        typedef __ummap_hashtable<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> _Hashtable;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::_Hashtable _M_h;
    public:
        typedef typename _Hashtable::key_type key_type;
        typedef typename _Hashtable::value_type value_type;
        typedef typename _Hashtable::mapped_type mapped_type;
        typedef typename _Hashtable::hasher hasher;
        typedef typename _Hashtable::key_equal key_equal;
        typedef typename _Hashtable::allocator_type allocator_type;
        typedef typename _Hashtable::pointer pointer;
        typedef typename _Hashtable::const_pointer const_pointer;
        typedef typename _Hashtable::reference reference;
        typedef typename _Hashtable::const_reference const_reference;
        typedef typename _Hashtable::iterator iterator;
        typedef typename _Hashtable::const_iterator const_iterator;
        typedef typename _Hashtable::local_iterator local_iterator;
        typedef typename _Hashtable::const_local_iterator const_local_iterator;
        typedef typename _Hashtable::size_type size_type;
        typedef typename _Hashtable::difference_type difference_type;
        using node_type = typename _Hashtable::node_type;
        unordered_multimap() = default
        explicit unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_multimap(_InputIterator __first, _InputIterator __last, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &) = default
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&) = default
        explicit unordered_multimap(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &__ummap, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&__ummap, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_multimap(_InputIterator __first, _InputIterator __last, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_multimap(_InputIterator __first, _InputIterator __last, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &) = default
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&) = default
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type get_allocator() const noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type size() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type max_size() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator begin() noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator begin() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator cbegin() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator end() noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator end() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator cend() const noexcept;
        template <typename ..._Args> std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator emplace(_Args &&...__args);
        template <typename ..._Args> std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator emplace_hint(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __pos, _Args &&...__args);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &&__x);
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator> insert(_Pair &&__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &&__x);
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator> insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, _Pair &&__x);
        template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last);
        void insert(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type extract(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __pos);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type extract(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__key);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type &&__nh);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type &&__nh);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __position);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator __position);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type erase(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __first, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __last);
        void clear() noexcept;
        void swap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &__x);
        friend template <typename, typename, typename> class _Hash_merge_helper;
        template <typename _H2, typename _P2> void merge(unordered_multimap<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &__source);
        template <typename _H2, typename _P2> void merge(unordered_multimap<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &&__source);
        template <typename _H2, typename _P2> void merge(unordered_map<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &__source);
        template <typename _H2, typename _P2> void merge(unordered_map<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &&__source);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher hash_function() const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal key_eq() const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator find(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator find(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type count(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::pair<iterator, iterator> equal_range(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::pair<const_iterator, const_iterator> equal_range(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket_count() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type max_bucket_count() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket_size(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__key) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::local_iterator begin(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator begin(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator cbegin(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::local_iterator end(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator end(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator cend(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        float load_factor() const noexcept;
        float max_load_factor() const noexcept;
        void max_load_factor(float __z);
        void rehash(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        void reserve(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        friend template <typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1, typename _Alloc1> bool operator==(const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &, const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &);
    };
    template <typename _Key, typename _Tp, typename _Hash = hash<_Key>, typename _Pred = equal_to<_Key>, typename _Alloc = allocator<std::pair<const _Key, _Tp>>> class unordered_map {
        typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
        std::unordered_map::_Hashtable _M_h;
    public:
        typedef typename _Hashtable::key_type key_type;
        typedef typename _Hashtable::value_type value_type;
        typedef typename _Hashtable::mapped_type mapped_type;
        typedef typename _Hashtable::hasher hasher;
        typedef typename _Hashtable::key_equal key_equal;
        typedef typename _Hashtable::allocator_type allocator_type;
        typedef typename _Hashtable::pointer pointer;
        typedef typename _Hashtable::const_pointer const_pointer;
        typedef typename _Hashtable::reference reference;
        typedef typename _Hashtable::const_reference const_reference;
        typedef typename _Hashtable::iterator iterator;
        typedef typename _Hashtable::const_iterator const_iterator;
        typedef typename _Hashtable::local_iterator local_iterator;
        typedef typename _Hashtable::const_local_iterator const_local_iterator;
        typedef typename _Hashtable::size_type size_type;
        typedef typename _Hashtable::difference_type difference_type;
        using node_type = typename _Hashtable::node_type;
        using insert_return_type = typename _Hashtable::insert_return_type;
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>() = default
        explicit unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(std::unordered_map::size_type __n, const std::unordered_map::hasher &__hf = std::unordered_map::hasher(), const std::unordered_map::key_equal &__eql = std::unordered_map::key_equal(), const std::unordered_map::allocator_type &__a = std::unordered_map::allocator_type()) : _M_h(__n, __hf, __eql, __a)         {
        }
        template <typename _InputIterator> unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(_InputIterator __first, _InputIterator __last, std::unordered_map::size_type __n = 0, const std::unordered_map::hasher &__hf = std::unordered_map::hasher(), const std::unordered_map::key_equal &__eql = std::unordered_map::key_equal(), const std::unordered_map::allocator_type &__a = std::unordered_map::allocator_type()) : _M_h(__first, __last, __n, __hf, __eql, __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &) = default
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &&) = default
        explicit unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(const std::unordered_map::allocator_type &__a) : _M_h(__a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__umap, const std::unordered_map::allocator_type &__a) : _M_h(__umap._M_h, __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &&__umap, const std::unordered_map::allocator_type &__a) : _M_h(std::move(__umap._M_h), __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(initializer_list<std::unordered_map::value_type> __l, std::unordered_map::size_type __n = 0, const std::unordered_map::hasher &__hf = std::unordered_map::hasher(), const std::unordered_map::key_equal &__eql = std::unordered_map::key_equal(), const std::unordered_map::allocator_type &__a = std::unordered_map::allocator_type()) : _M_h(__l, __n, __hf, __eql, __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(std::unordered_map::size_type __n, const std::unordered_map::allocator_type &__a) : unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(__n, std::unordered_map::hasher(), std::unordered_map::key_equal(), __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(std::unordered_map::size_type __n, const std::unordered_map::hasher &__hf, const std::unordered_map::allocator_type &__a) : unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(__n, __hf, std::unordered_map::key_equal(), __a)         {
        }
        template <typename _InputIterator> unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(_InputIterator __first, _InputIterator __last, std::unordered_map::size_type __n, const std::unordered_map::allocator_type &__a) : unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(__first, __last, __n, std::unordered_map::hasher(), std::unordered_map::key_equal(), __a)         {
        }
        template <typename _InputIterator> unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(_InputIterator __first, _InputIterator __last, std::unordered_map::size_type __n, const std::unordered_map::hasher &__hf, const std::unordered_map::allocator_type &__a) : unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(__first, __last, __n, __hf, std::unordered_map::key_equal(), __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(initializer_list<std::unordered_map::value_type> __l, std::unordered_map::size_type __n, const std::unordered_map::allocator_type &__a) : unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(__l, __n, std::unordered_map::hasher(), std::unordered_map::key_equal(), __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(initializer_list<std::unordered_map::value_type> __l, std::unordered_map::size_type __n, const std::unordered_map::hasher &__hf, const std::unordered_map::allocator_type &__a) : unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>(__l, __n, __hf, std::unordered_map::key_equal(), __a)         {
        }
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &operator=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &) = default
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &operator=(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &&) = default
        unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &operator=(initializer_list<std::unordered_map::value_type> __l)         {
            this->_M_h = __l;
            return *this;
        }
        std::unordered_map::allocator_type get_allocator() const noexcept         {
            return this->_M_h.get_allocator();
        }
        bool empty() const noexcept [[nodiscard("")]]         {
            return this->_M_h.empty();
        }
        std::unordered_map::size_type size() const noexcept         {
            return this->_M_h.size();
        }
        std::unordered_map::size_type max_size() const noexcept         {
            return this->_M_h.max_size();
        }
        std::unordered_map::iterator begin() noexcept         {
            return this->_M_h.begin();
        }
        std::unordered_map::const_iterator begin() const noexcept         {
            return this->_M_h.begin();
        }
        std::unordered_map::const_iterator cbegin() const noexcept         {
            return this->_M_h.begin();
        }
        std::unordered_map::iterator end() noexcept         {
            return this->_M_h.end();
        }
        std::unordered_map::const_iterator end() const noexcept         {
            return this->_M_h.end();
        }
        std::unordered_map::const_iterator cend() const noexcept         {
            return this->_M_h.end();
        }
        template <typename ..._Args> std::pair<iterator, bool> emplace(_Args &&...__args)         {
            return this->_M_h.emplace(std::forward<_Args>(__args)...);
        }
        template <typename ..._Args> std::unordered_map::iterator emplace_hint(std::unordered_map::const_iterator __pos, _Args &&...__args)         {
            return this->_M_h.emplace_hint(__pos, std::forward<_Args>(__args)...);
        }
        std::unordered_map::node_type extract(std::unordered_map::const_iterator __pos)         {
            ;
            return this->_M_h.extract(__pos);
        }
        std::unordered_map::node_type extract(const std::unordered_map::key_type &__key)         {
            return this->_M_h.extract(__key);
        }
        std::unordered_map::insert_return_type insert(std::unordered_map::node_type &&__nh)         {
            return this->_M_h._M_reinsert_node(std::move(__nh));
        }
        std::unordered_map::iterator insert(std::unordered_map::const_iterator, std::unordered_map::node_type &&__nh)         {
            return this->_M_h._M_reinsert_node(std::move(__nh)).position;
        }
        template <typename ..._Args> pair<std::unordered_map::iterator, bool> try_emplace(const std::unordered_map::key_type &__k, _Args &&...__args)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end()) {
                __i = emplace(std::piecewise_construct, std::forward_as_tuple(__k), std::forward_as_tuple(std::forward<_Args>(__args)...)).first;
                return {__i, true};
            }
            return {__i, false};
        }
        template <typename ..._Args> pair<std::unordered_map::iterator, bool> try_emplace(std::unordered_map::key_type &&__k, _Args &&...__args)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end()) {
                __i = emplace(std::piecewise_construct, std::forward_as_tuple(std::move(__k)), std::forward_as_tuple(std::forward<_Args>(__args)...)).first;
                return {__i, true};
            }
            return {__i, false};
        }
        template <typename ..._Args> std::unordered_map::iterator try_emplace(std::unordered_map::const_iterator __hint, const std::unordered_map::key_type &__k, _Args &&...__args)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end())
                __i = emplace_hint(__hint, std::piecewise_construct, std::forward_as_tuple(__k), std::forward_as_tuple(std::forward<_Args>(__args)...));
            return __i;
        }
        template <typename ..._Args> std::unordered_map::iterator try_emplace(std::unordered_map::const_iterator __hint, std::unordered_map::key_type &&__k, _Args &&...__args)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end())
                __i = emplace_hint(__hint, std::piecewise_construct, std::forward_as_tuple(std::move(__k)), std::forward_as_tuple(std::forward<_Args>(__args)...));
            return __i;
        }
        std::pair<iterator, bool> insert(const std::unordered_map::value_type &__x)         {
            return this->_M_h.insert(__x);
        }
        std::pair<iterator, bool> insert(std::unordered_map::value_type &&__x)         {
            return this->_M_h.insert(std::move(__x));
        }
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, pair<std::unordered_map::iterator, bool>> insert(_Pair &&__x)         {
            return this->_M_h.emplace(std::forward<_Pair>(__x));
        }
        std::unordered_map::iterator insert(std::unordered_map::const_iterator __hint, const std::unordered_map::value_type &__x)         {
            return this->_M_h.insert(__hint, __x);
        }
        std::unordered_map::iterator insert(std::unordered_map::const_iterator __hint, std::unordered_map::value_type &&__x)         {
            return this->_M_h.insert(__hint, std::move(__x));
        }
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_map::iterator> insert(std::unordered_map::const_iterator __hint, _Pair &&__x)         {
            return this->_M_h.emplace_hint(__hint, std::forward<_Pair>(__x));
        }
        template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last)         {
            this->_M_h.insert(__first, __last);
        }
        void insert(initializer_list<std::unordered_map::value_type> __l)         {
            this->_M_h.insert(__l);
        }
        template <typename _Obj> pair<std::unordered_map::iterator, bool> insert_or_assign(const std::unordered_map::key_type &__k, _Obj &&__obj)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end()) {
                __i = emplace(std::piecewise_construct, std::forward_as_tuple(__k), std::forward_as_tuple(std::forward<_Obj>(__obj))).first;
                return {__i, true};
            }
            (*__i).second = std::forward<_Obj>(__obj);
            return {__i, false};
        }
        template <typename _Obj> pair<std::unordered_map::iterator, bool> insert_or_assign(std::unordered_map::key_type &&__k, _Obj &&__obj)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end()) {
                __i = emplace(std::piecewise_construct, std::forward_as_tuple(std::move(__k)), std::forward_as_tuple(std::forward<_Obj>(__obj))).first;
                return {__i, true};
            }
            (*__i).second = std::forward<_Obj>(__obj);
            return {__i, false};
        }
        template <typename _Obj> std::unordered_map::iterator insert_or_assign(std::unordered_map::const_iterator __hint, const std::unordered_map::key_type &__k, _Obj &&__obj)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end()) {
                return emplace_hint(__hint, std::piecewise_construct, std::forward_as_tuple(__k), std::forward_as_tuple(std::forward<_Obj>(__obj)));
            }
            (*__i).second = std::forward<_Obj>(__obj);
            return __i;
        }
        template <typename _Obj> std::unordered_map::iterator insert_or_assign(std::unordered_map::const_iterator __hint, std::unordered_map::key_type &&__k, _Obj &&__obj)         {
            std::unordered_map::iterator __i = find(__k);
            if (__i == end()) {
                return emplace_hint(__hint, std::piecewise_construct, std::forward_as_tuple(std::move(__k)), std::forward_as_tuple(std::forward<_Obj>(__obj)));
            }
            (*__i).second = std::forward<_Obj>(__obj);
            return __i;
        }
        std::unordered_map::iterator erase(std::unordered_map::const_iterator __position)         {
            return this->_M_h.erase(__position);
        }
        std::unordered_map::iterator erase(std::unordered_map::iterator __position)         {
            return this->_M_h.erase(__position);
        }
        std::unordered_map::size_type erase(const std::unordered_map::key_type &__x)         {
            return this->_M_h.erase(__x);
        }
        std::unordered_map::iterator erase(std::unordered_map::const_iterator __first, std::unordered_map::const_iterator __last)         {
            return this->_M_h.erase(__first, __last);
        }
        void clear() noexcept         {
            this->_M_h.clear();
        }
        void swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x) noexcept(noexcept(this->_M_h.swap(__x._M_h))swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x) noexcept(noexcept(this->_M_h.swap(__x._M_h)))         {
            this->_M_h.swap(__x._M_h);
        }
        friend template <typename, typename, typename> class _Hash_merge_helper;
        template <typename _H2, typename _P2> void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &__source)         {
            using _Merge_helper = _Hash_merge_helper<unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>, _H2, _P2>;
            this->_M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
        }
        template <typename _H2, typename _P2> void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &&__source)         {
            merge(__source);
        }
        template <typename _H2, typename _P2> void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &__source)         {
            using _Merge_helper = _Hash_merge_helper<unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>, _H2, _P2>;
            this->_M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
        }
        template <typename _H2, typename _P2> void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &&__source)         {
            merge(__source);
        }
        std::unordered_map::hasher hash_function() const         {
            return this->_M_h.hash_function();
        }
        std::unordered_map::key_equal key_eq() const         {
            return this->_M_h.key_eq();
        }
        std::unordered_map::iterator find(const std::unordered_map::key_type &__x)         {
            return this->_M_h.find(__x);
        }
        std::unordered_map::const_iterator find(const std::unordered_map::key_type &__x) const         {
            return this->_M_h.find(__x);
        }
        std::unordered_map::size_type count(const std::unordered_map::key_type &__x) const         {
            return this->_M_h.count(__x);
        }
        std::pair<iterator, iterator> equal_range(const std::unordered_map::key_type &__x)         {
            return this->_M_h.equal_range(__x);
        }
        std::pair<const_iterator, const_iterator> equal_range(const std::unordered_map::key_type &__x) const         {
            return this->_M_h.equal_range(__x);
        }
        std::unordered_map::mapped_type &operator[](const std::unordered_map::key_type &__k)         {
            return this->_M_h[__k];
        }
        std::unordered_map::mapped_type &operator[](std::unordered_map::key_type &&__k)         {
            return this->_M_h[std::move(__k)];
        }
        std::unordered_map::mapped_type &at(const std::unordered_map::key_type &__k)         {
            return this->_M_h.at(__k);
        }
        const std::unordered_map::mapped_type &at(const std::unordered_map::key_type &__k) const         {
            return this->_M_h.at(__k);
        }
        std::unordered_map::size_type bucket_count() const noexcept         {
            return this->_M_h.bucket_count();
        }
        std::unordered_map::size_type max_bucket_count() const noexcept         {
            return this->_M_h.max_bucket_count();
        }
        std::unordered_map::size_type bucket_size(std::unordered_map::size_type __n) const         {
            return this->_M_h.bucket_size(__n);
        }
        std::unordered_map::size_type bucket(const std::unordered_map::key_type &__key) const         {
            return this->_M_h.bucket(__key);
        }
        std::unordered_map::local_iterator begin(std::unordered_map::size_type __n)         {
            return this->_M_h.begin(__n);
        }
        std::unordered_map::const_local_iterator begin(std::unordered_map::size_type __n) const         {
            return this->_M_h.begin(__n);
        }
        std::unordered_map::const_local_iterator cbegin(std::unordered_map::size_type __n) const         {
            return this->_M_h.cbegin(__n);
        }
        std::unordered_map::local_iterator end(std::unordered_map::size_type __n)         {
            return this->_M_h.end(__n);
        }
        std::unordered_map::const_local_iterator end(std::unordered_map::size_type __n) const         {
            return this->_M_h.end(__n);
        }
        std::unordered_map::const_local_iterator cend(std::unordered_map::size_type __n) const         {
            return this->_M_h.cend(__n);
        }
        float load_factor() const noexcept         {
            return this->_M_h.load_factor();
        }
        float max_load_factor() const noexcept         {
            return this->_M_h.max_load_factor();
        }
        void max_load_factor(float __z)         {
            this->_M_h.max_load_factor(__z);
        }
        void rehash(std::unordered_map::size_type __n)         {
            this->_M_h.rehash(__n);
        }
        void reserve(std::unordered_map::size_type __n)         {
            this->_M_h.reserve(__n);
        }
        friend template <typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1, typename _Alloc1> bool operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &, const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &);
    };
template<> class unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> {
        typedef __umap_hashtable<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> _Hashtable;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::_Hashtable _M_h;
    public:
        typedef typename _Hashtable::key_type key_type;
        typedef typename _Hashtable::value_type value_type;
        typedef typename _Hashtable::mapped_type mapped_type;
        typedef typename _Hashtable::hasher hasher;
        typedef typename _Hashtable::key_equal key_equal;
        typedef typename _Hashtable::allocator_type allocator_type;
        typedef typename _Hashtable::pointer pointer;
        typedef typename _Hashtable::const_pointer const_pointer;
        typedef typename _Hashtable::reference reference;
        typedef typename _Hashtable::const_reference const_reference;
        typedef typename _Hashtable::iterator iterator;
        typedef typename _Hashtable::const_iterator const_iterator;
        typedef typename _Hashtable::local_iterator local_iterator;
        typedef typename _Hashtable::const_local_iterator const_local_iterator;
        typedef typename _Hashtable::size_type size_type;
        typedef typename _Hashtable::difference_type difference_type;
        using node_type = typename _Hashtable::node_type;
        using insert_return_type = typename _Hashtable::insert_return_type;
        unordered_map() = default
        explicit unordered_map(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_map(_InputIterator __first, _InputIterator __last, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &) = default
        unordered_map(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&) = default
        explicit unordered_map(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &__umap, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&__umap, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(initializer_list<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_map(_InputIterator __first, _InputIterator __last, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_map(_InputIterator __first, _InputIterator __last, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(initializer_list<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_map(initializer_list<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &) = default
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&) = default
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(initializer_list<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type get_allocator() const noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type size() const noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type max_size() const noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator begin() noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator begin() const noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator cbegin() const noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator end() noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator end() const noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator cend() const noexcept;
        template <typename ..._Args> std::pair<iterator, bool> emplace(_Args &&...__args);
        template <typename ..._Args> std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator emplace_hint(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __pos, _Args &&...__args);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type extract(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __pos);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type extract(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__key);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::insert_return_type insert(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type &&__nh);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type &&__nh);
        template <typename ..._Args> pair<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator, bool> try_emplace(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__k, _Args &&...__args);
        template <typename ..._Args> pair<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator, bool> try_emplace(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &&__k, _Args &&...__args);
        template <typename ..._Args> std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator try_emplace(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__k, _Args &&...__args);
        template <typename ..._Args> std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator try_emplace(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &&__k, _Args &&...__args);
        std::pair<iterator, bool> insert(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &__x);
        std::pair<iterator, bool> insert(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &&__x);
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, pair<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator, bool>> insert(_Pair &&__x);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &__x);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &&__x);
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator> insert(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, _Pair &&__x);
        template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last);
        void insert(initializer_list<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l);
        template <typename _Obj> pair<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator, bool> insert_or_assign(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__k, _Obj &&__obj);
        template <typename _Obj> pair<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator, bool> insert_or_assign(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &&__k, _Obj &&__obj);
        template <typename _Obj> std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert_or_assign(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__k, _Obj &&__obj);
        template <typename _Obj> std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert_or_assign(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &&__k, _Obj &&__obj);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __position);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator __position);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type erase(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __first, std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __last);
        void clear() noexcept;
        void swap(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &__x);
        friend template <typename, typename, typename> class _Hash_merge_helper;
        template <typename _H2, typename _P2> void merge(unordered_map<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &__source);
        template <typename _H2, typename _P2> void merge(unordered_map<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &&__source);
        template <typename _H2, typename _P2> void merge(unordered_multimap<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &__source);
        template <typename _H2, typename _P2> void merge(unordered_multimap<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &&__source);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher hash_function() const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal key_eq() const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator find(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator find(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type count(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::pair<iterator, iterator> equal_range(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::pair<const_iterator, const_iterator> equal_range(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::mapped_type &operator[](const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__k);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::mapped_type &operator[](std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &&__k);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::mapped_type &at(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__k);
        const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::mapped_type &at(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__k) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket_count() const noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type max_bucket_count() const noexcept;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket_size(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket(const std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__key) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::local_iterator begin(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator begin(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator cbegin(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::local_iterator end(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator end(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator cend(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        float load_factor() const noexcept;
        float max_load_factor() const noexcept;
        void max_load_factor(float __z);
        void rehash(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        void reserve(std::unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        friend template <typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1, typename _Alloc1> bool operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &, const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &);
    };
    template <typename _InputIterator, typename _Hash = hash<__iter_key_t<_InputIterator>>, typename _Pred = equal_to<__iter_key_t<_InputIterator>>, typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>, typename = _RequireInputIter<_InputIterator>, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireNotAllocator<_Pred>, typename = _RequireAllocator<_Allocator>> unordered_map(_InputIterator, _InputIterator, typename unordered_map<int, int>::size_type = {}, _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator()) -> unordered_map<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, _Pred, _Allocator>;
    template <typename _Key, typename _Tp, typename _Hash = hash<_Key>, typename _Pred = equal_to<_Key>, typename _Allocator = allocator<pair<const _Key, _Tp>>, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireNotAllocator<_Pred>, typename = _RequireAllocator<_Allocator>> unordered_map(initializer_list<pair<_Key, _Tp>>, typename unordered_map<int, int>::size_type = {}, _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator()) -> unordered_map<_Key, _Tp, _Hash, _Pred, _Allocator>;
    template <typename _InputIterator, typename _Allocator, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> unordered_map(_InputIterator, _InputIterator, typename unordered_map<int, int>::size_type, _Allocator) -> unordered_map<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, hash<__iter_key_t<_InputIterator>>, equal_to<__iter_key_t<_InputIterator>>, _Allocator>;
    template <typename _InputIterator, typename _Allocator, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> unordered_map(_InputIterator, _InputIterator, _Allocator) -> unordered_map<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, hash<__iter_key_t<_InputIterator>>, equal_to<__iter_key_t<_InputIterator>>, _Allocator>;
    template <typename _InputIterator, typename _Hash, typename _Allocator, typename = _RequireInputIter<_InputIterator>, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireAllocator<_Allocator>> unordered_map(_InputIterator, _InputIterator, typename unordered_map<int, int>::size_type, _Hash, _Allocator) -> unordered_map<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, equal_to<__iter_key_t<_InputIterator>>, _Allocator>;
    template <typename _Key, typename _Tp, typename _Allocator, typename = _RequireAllocator<_Allocator>> unordered_map(initializer_list<pair<_Key, _Tp>>, typename unordered_map<int, int>::size_type, _Allocator) -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;
    template <typename _Key, typename _Tp, typename _Allocator, typename = _RequireAllocator<_Allocator>> unordered_map(initializer_list<pair<_Key, _Tp>>, _Allocator) -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;
    template <typename _Key, typename _Tp, typename _Hash, typename _Allocator, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireAllocator<_Allocator>> unordered_map(initializer_list<pair<_Key, _Tp>>, typename unordered_map<int, int>::size_type, _Hash, _Allocator) -> unordered_map<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;
    template <typename _Key, typename _Tp, typename _Hash = hash<_Key>, typename _Pred = equal_to<_Key>, typename _Alloc = allocator<std::pair<const _Key, _Tp>>> class unordered_multimap {
        typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
        std::unordered_multimap::_Hashtable _M_h;
    public:
        typedef typename _Hashtable::key_type key_type;
        typedef typename _Hashtable::value_type value_type;
        typedef typename _Hashtable::mapped_type mapped_type;
        typedef typename _Hashtable::hasher hasher;
        typedef typename _Hashtable::key_equal key_equal;
        typedef typename _Hashtable::allocator_type allocator_type;
        typedef typename _Hashtable::pointer pointer;
        typedef typename _Hashtable::const_pointer const_pointer;
        typedef typename _Hashtable::reference reference;
        typedef typename _Hashtable::const_reference const_reference;
        typedef typename _Hashtable::iterator iterator;
        typedef typename _Hashtable::const_iterator const_iterator;
        typedef typename _Hashtable::local_iterator local_iterator;
        typedef typename _Hashtable::const_local_iterator const_local_iterator;
        typedef typename _Hashtable::size_type size_type;
        typedef typename _Hashtable::difference_type difference_type;
        using node_type = typename _Hashtable::node_type;
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>() = default
        explicit unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(std::unordered_multimap::size_type __n, const std::unordered_multimap::hasher &__hf = std::unordered_multimap::hasher(), const std::unordered_multimap::key_equal &__eql = std::unordered_multimap::key_equal(), const std::unordered_multimap::allocator_type &__a = std::unordered_multimap::allocator_type()) : _M_h(__n, __hf, __eql, __a)         {
        }
        template <typename _InputIterator> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(_InputIterator __first, _InputIterator __last, std::unordered_multimap::size_type __n = 0, const std::unordered_multimap::hasher &__hf = std::unordered_multimap::hasher(), const std::unordered_multimap::key_equal &__eql = std::unordered_multimap::key_equal(), const std::unordered_multimap::allocator_type &__a = std::unordered_multimap::allocator_type()) : _M_h(__first, __last, __n, __hf, __eql, __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &) = default
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &&) = default
        explicit unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(const std::unordered_multimap::allocator_type &__a) : _M_h(__a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__ummap, const std::unordered_multimap::allocator_type &__a) : _M_h(__ummap._M_h, __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &&__ummap, const std::unordered_multimap::allocator_type &__a) : _M_h(std::move(__ummap._M_h), __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(initializer_list<std::unordered_multimap::value_type> __l, std::unordered_multimap::size_type __n = 0, const std::unordered_multimap::hasher &__hf = std::unordered_multimap::hasher(), const std::unordered_multimap::key_equal &__eql = std::unordered_multimap::key_equal(), const std::unordered_multimap::allocator_type &__a = std::unordered_multimap::allocator_type()) : _M_h(__l, __n, __hf, __eql, __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(std::unordered_multimap::size_type __n, const std::unordered_multimap::allocator_type &__a) : unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(__n, std::unordered_multimap::hasher(), std::unordered_multimap::key_equal(), __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(std::unordered_multimap::size_type __n, const std::unordered_multimap::hasher &__hf, const std::unordered_multimap::allocator_type &__a) : unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(__n, __hf, std::unordered_multimap::key_equal(), __a)         {
        }
        template <typename _InputIterator> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(_InputIterator __first, _InputIterator __last, std::unordered_multimap::size_type __n, const std::unordered_multimap::allocator_type &__a) : unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(__first, __last, __n, std::unordered_multimap::hasher(), std::unordered_multimap::key_equal(), __a)         {
        }
        template <typename _InputIterator> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(_InputIterator __first, _InputIterator __last, std::unordered_multimap::size_type __n, const std::unordered_multimap::hasher &__hf, const std::unordered_multimap::allocator_type &__a) : unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(__first, __last, __n, __hf, std::unordered_multimap::key_equal(), __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(initializer_list<std::unordered_multimap::value_type> __l, std::unordered_multimap::size_type __n, const std::unordered_multimap::allocator_type &__a) : unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(__l, __n, std::unordered_multimap::hasher(), std::unordered_multimap::key_equal(), __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(initializer_list<std::unordered_multimap::value_type> __l, std::unordered_multimap::size_type __n, const std::unordered_multimap::hasher &__hf, const std::unordered_multimap::allocator_type &__a) : unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>(__l, __n, __hf, std::unordered_multimap::key_equal(), __a)         {
        }
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &operator=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &) = default
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &operator=(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &&) = default
        unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &operator=(initializer_list<std::unordered_multimap::value_type> __l)         {
            this->_M_h = __l;
            return *this;
        }
        std::unordered_multimap::allocator_type get_allocator() const noexcept         {
            return this->_M_h.get_allocator();
        }
        bool empty() const noexcept [[nodiscard("")]]         {
            return this->_M_h.empty();
        }
        std::unordered_multimap::size_type size() const noexcept         {
            return this->_M_h.size();
        }
        std::unordered_multimap::size_type max_size() const noexcept         {
            return this->_M_h.max_size();
        }
        std::unordered_multimap::iterator begin() noexcept         {
            return this->_M_h.begin();
        }
        std::unordered_multimap::const_iterator begin() const noexcept         {
            return this->_M_h.begin();
        }
        std::unordered_multimap::const_iterator cbegin() const noexcept         {
            return this->_M_h.begin();
        }
        std::unordered_multimap::iterator end() noexcept         {
            return this->_M_h.end();
        }
        std::unordered_multimap::const_iterator end() const noexcept         {
            return this->_M_h.end();
        }
        std::unordered_multimap::const_iterator cend() const noexcept         {
            return this->_M_h.end();
        }
        template <typename ..._Args> std::unordered_multimap::iterator emplace(_Args &&...__args)         {
            return this->_M_h.emplace(std::forward<_Args>(__args)...);
        }
        template <typename ..._Args> std::unordered_multimap::iterator emplace_hint(std::unordered_multimap::const_iterator __pos, _Args &&...__args)         {
            return this->_M_h.emplace_hint(__pos, std::forward<_Args>(__args)...);
        }
        std::unordered_multimap::iterator insert(const std::unordered_multimap::value_type &__x)         {
            return this->_M_h.insert(__x);
        }
        std::unordered_multimap::iterator insert(std::unordered_multimap::value_type &&__x)         {
            return this->_M_h.insert(std::move(__x));
        }
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_multimap::iterator> insert(_Pair &&__x)         {
            return this->_M_h.emplace(std::forward<_Pair>(__x));
        }
        std::unordered_multimap::iterator insert(std::unordered_multimap::const_iterator __hint, const std::unordered_multimap::value_type &__x)         {
            return this->_M_h.insert(__hint, __x);
        }
        std::unordered_multimap::iterator insert(std::unordered_multimap::const_iterator __hint, std::unordered_multimap::value_type &&__x)         {
            return this->_M_h.insert(__hint, std::move(__x));
        }
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_multimap::iterator> insert(std::unordered_multimap::const_iterator __hint, _Pair &&__x)         {
            return this->_M_h.emplace_hint(__hint, std::forward<_Pair>(__x));
        }
        template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last)         {
            this->_M_h.insert(__first, __last);
        }
        void insert(initializer_list<std::unordered_multimap::value_type> __l)         {
            this->_M_h.insert(__l);
        }
        std::unordered_multimap::node_type extract(std::unordered_multimap::const_iterator __pos)         {
            ;
            return this->_M_h.extract(__pos);
        }
        std::unordered_multimap::node_type extract(const std::unordered_multimap::key_type &__key)         {
            return this->_M_h.extract(__key);
        }
        std::unordered_multimap::iterator insert(std::unordered_multimap::node_type &&__nh)         {
            return this->_M_h._M_reinsert_node_multi(cend(), std::move(__nh));
        }
        std::unordered_multimap::iterator insert(std::unordered_multimap::const_iterator __hint, std::unordered_multimap::node_type &&__nh)         {
            return this->_M_h._M_reinsert_node_multi(__hint, std::move(__nh));
        }
        std::unordered_multimap::iterator erase(std::unordered_multimap::const_iterator __position)         {
            return this->_M_h.erase(__position);
        }
        std::unordered_multimap::iterator erase(std::unordered_multimap::iterator __position)         {
            return this->_M_h.erase(__position);
        }
        std::unordered_multimap::size_type erase(const std::unordered_multimap::key_type &__x)         {
            return this->_M_h.erase(__x);
        }
        std::unordered_multimap::iterator erase(std::unordered_multimap::const_iterator __first, std::unordered_multimap::const_iterator __last)         {
            return this->_M_h.erase(__first, __last);
        }
        void clear() noexcept         {
            this->_M_h.clear();
        }
        void swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x) noexcept(noexcept(this->_M_h.swap(__x._M_h))swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x) noexcept(noexcept(this->_M_h.swap(__x._M_h)))         {
            this->_M_h.swap(__x._M_h);
        }
        friend template <typename, typename, typename> class _Hash_merge_helper;
        template <typename _H2, typename _P2> void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &__source)         {
            using _Merge_helper = _Hash_merge_helper<unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>, _H2, _P2>;
            this->_M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
        }
        template <typename _H2, typename _P2> void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &&__source)         {
            merge(__source);
        }
        template <typename _H2, typename _P2> void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &__source)         {
            using _Merge_helper = _Hash_merge_helper<unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>, _H2, _P2>;
            this->_M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
        }
        template <typename _H2, typename _P2> void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &&__source)         {
            merge(__source);
        }
        std::unordered_multimap::hasher hash_function() const         {
            return this->_M_h.hash_function();
        }
        std::unordered_multimap::key_equal key_eq() const         {
            return this->_M_h.key_eq();
        }
        std::unordered_multimap::iterator find(const std::unordered_multimap::key_type &__x)         {
            return this->_M_h.find(__x);
        }
        std::unordered_multimap::const_iterator find(const std::unordered_multimap::key_type &__x) const         {
            return this->_M_h.find(__x);
        }
        std::unordered_multimap::size_type count(const std::unordered_multimap::key_type &__x) const         {
            return this->_M_h.count(__x);
        }
        std::pair<iterator, iterator> equal_range(const std::unordered_multimap::key_type &__x)         {
            return this->_M_h.equal_range(__x);
        }
        std::pair<const_iterator, const_iterator> equal_range(const std::unordered_multimap::key_type &__x) const         {
            return this->_M_h.equal_range(__x);
        }
        std::unordered_multimap::size_type bucket_count() const noexcept         {
            return this->_M_h.bucket_count();
        }
        std::unordered_multimap::size_type max_bucket_count() const noexcept         {
            return this->_M_h.max_bucket_count();
        }
        std::unordered_multimap::size_type bucket_size(std::unordered_multimap::size_type __n) const         {
            return this->_M_h.bucket_size(__n);
        }
        std::unordered_multimap::size_type bucket(const std::unordered_multimap::key_type &__key) const         {
            return this->_M_h.bucket(__key);
        }
        std::unordered_multimap::local_iterator begin(std::unordered_multimap::size_type __n)         {
            return this->_M_h.begin(__n);
        }
        std::unordered_multimap::const_local_iterator begin(std::unordered_multimap::size_type __n) const         {
            return this->_M_h.begin(__n);
        }
        std::unordered_multimap::const_local_iterator cbegin(std::unordered_multimap::size_type __n) const         {
            return this->_M_h.cbegin(__n);
        }
        std::unordered_multimap::local_iterator end(std::unordered_multimap::size_type __n)         {
            return this->_M_h.end(__n);
        }
        std::unordered_multimap::const_local_iterator end(std::unordered_multimap::size_type __n) const         {
            return this->_M_h.end(__n);
        }
        std::unordered_multimap::const_local_iterator cend(std::unordered_multimap::size_type __n) const         {
            return this->_M_h.cend(__n);
        }
        float load_factor() const noexcept         {
            return this->_M_h.load_factor();
        }
        float max_load_factor() const noexcept         {
            return this->_M_h.max_load_factor();
        }
        void max_load_factor(float __z)         {
            this->_M_h.max_load_factor(__z);
        }
        void rehash(std::unordered_multimap::size_type __n)         {
            this->_M_h.rehash(__n);
        }
        void reserve(std::unordered_multimap::size_type __n)         {
            this->_M_h.reserve(__n);
        }
        friend template <typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1, typename _Alloc1> bool operator==(const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &, const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &);
    };
template<> class unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> {
        typedef __ummap_hashtable<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> _Hashtable;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::_Hashtable _M_h;
    public:
        typedef typename _Hashtable::key_type key_type;
        typedef typename _Hashtable::value_type value_type;
        typedef typename _Hashtable::mapped_type mapped_type;
        typedef typename _Hashtable::hasher hasher;
        typedef typename _Hashtable::key_equal key_equal;
        typedef typename _Hashtable::allocator_type allocator_type;
        typedef typename _Hashtable::pointer pointer;
        typedef typename _Hashtable::const_pointer const_pointer;
        typedef typename _Hashtable::reference reference;
        typedef typename _Hashtable::const_reference const_reference;
        typedef typename _Hashtable::iterator iterator;
        typedef typename _Hashtable::const_iterator const_iterator;
        typedef typename _Hashtable::local_iterator local_iterator;
        typedef typename _Hashtable::const_local_iterator const_local_iterator;
        typedef typename _Hashtable::size_type size_type;
        typedef typename _Hashtable::difference_type difference_type;
        using node_type = typename _Hashtable::node_type;
        unordered_multimap() = default
        explicit unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_multimap(_InputIterator __first, _InputIterator __last, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &) = default
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&) = default
        explicit unordered_multimap(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &__ummap, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&__ummap, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal &__eql, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_multimap(_InputIterator __first, _InputIterator __last, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        template <typename _InputIterator> unordered_multimap(_InputIterator __first, _InputIterator __last, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        unordered_multimap(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher &__hf, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type &__a);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &) = default
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &&) = default
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &operator=(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::allocator_type get_allocator() const noexcept;
        bool empty() const noexcept [[nodiscard("")]];
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type size() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type max_size() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator begin() noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator begin() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator cbegin() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator end() noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator end() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator cend() const noexcept;
        template <typename ..._Args> std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator emplace(_Args &&...__args);
        template <typename ..._Args> std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator emplace_hint(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __pos, _Args &&...__args);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &&__x);
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator> insert(_Pair &&__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type &&__x);
        template <typename _Pair> __enable_if_t<is_constructible<value_type, _Pair &&>::value, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator> insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, _Pair &&__x);
        template <typename _InputIterator> void insert(_InputIterator __first, _InputIterator __last);
        void insert(initializer_list<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::value_type> __l);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type extract(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __pos);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type extract(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__key);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type &&__nh);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator insert(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __hint, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::node_type &&__nh);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __position);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator __position);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type erase(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator erase(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __first, std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator __last);
        void clear() noexcept;
        void swap(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> &__x);
        friend template <typename, typename, typename> class _Hash_merge_helper;
        template <typename _H2, typename _P2> void merge(unordered_multimap<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &__source);
        template <typename _H2, typename _P2> void merge(unordered_multimap<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &&__source);
        template <typename _H2, typename _P2> void merge(unordered_map<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &__source);
        template <typename _H2, typename _P2> void merge(unordered_map<int, int, _H2, _P2, std::allocator<std::pair<const int, int>>> &&__source);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::hasher hash_function() const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_equal key_eq() const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::iterator find(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_iterator find(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type count(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::pair<iterator, iterator> equal_range(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x);
        std::pair<const_iterator, const_iterator> equal_range(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__x) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket_count() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type max_bucket_count() const noexcept;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket_size(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type bucket(const std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::key_type &__key) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::local_iterator begin(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator begin(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator cbegin(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::local_iterator end(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator end(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::const_local_iterator cend(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n) const;
        float load_factor() const noexcept;
        float max_load_factor() const noexcept;
        void max_load_factor(float __z);
        void rehash(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        void reserve(std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>>::size_type __n);
        friend template <typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1, typename _Alloc1> bool operator==(const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &, const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &);
    };
    template <typename _InputIterator, typename _Hash = hash<__iter_key_t<_InputIterator>>, typename _Pred = equal_to<__iter_key_t<_InputIterator>>, typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>, typename = _RequireInputIter<_InputIterator>, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireNotAllocator<_Pred>, typename = _RequireAllocator<_Allocator>> unordered_multimap(_InputIterator, _InputIterator, unordered_multimap<int, int>::size_type = {}, _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator()) -> unordered_multimap<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, _Pred, _Allocator>;
    template <typename _Key, typename _Tp, typename _Hash = hash<_Key>, typename _Pred = equal_to<_Key>, typename _Allocator = allocator<pair<const _Key, _Tp>>, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireNotAllocator<_Pred>, typename = _RequireAllocator<_Allocator>> unordered_multimap(initializer_list<pair<_Key, _Tp>>, unordered_multimap<int, int>::size_type = {}, _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator()) -> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Allocator>;
    template <typename _InputIterator, typename _Allocator, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> unordered_multimap(_InputIterator, _InputIterator, unordered_multimap<int, int>::size_type, _Allocator) -> unordered_multimap<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, hash<__iter_key_t<_InputIterator>>, equal_to<__iter_key_t<_InputIterator>>, _Allocator>;
    template <typename _InputIterator, typename _Allocator, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> unordered_multimap(_InputIterator, _InputIterator, _Allocator) -> unordered_multimap<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, hash<__iter_key_t<_InputIterator>>, equal_to<__iter_key_t<_InputIterator>>, _Allocator>;
    template <typename _InputIterator, typename _Hash, typename _Allocator, typename = _RequireInputIter<_InputIterator>, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireAllocator<_Allocator>> unordered_multimap(_InputIterator, _InputIterator, unordered_multimap<int, int>::size_type, _Hash, _Allocator) -> unordered_multimap<__iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>, _Hash, equal_to<__iter_key_t<_InputIterator>>, _Allocator>;
    template <typename _Key, typename _Tp, typename _Allocator, typename = _RequireAllocator<_Allocator>> unordered_multimap(initializer_list<pair<_Key, _Tp>>, unordered_multimap<int, int>::size_type, _Allocator) -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;
    template <typename _Key, typename _Tp, typename _Allocator, typename = _RequireAllocator<_Allocator>> unordered_multimap(initializer_list<pair<_Key, _Tp>>, _Allocator) -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;
    template <typename _Key, typename _Tp, typename _Hash, typename _Allocator, typename = _RequireNotAllocatorOrIntegral<_Hash>, typename = _RequireAllocator<_Allocator>> unordered_multimap(initializer_list<pair<_Key, _Tp>>, unordered_multimap<int, int>::size_type, _Hash, _Allocator) -> unordered_multimap<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline void swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y) noexcept(noexcept(__x.swap(__y))swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y) noexcept(noexcept(__x.swap(__y)))     {
        __x.swap(__y);
    }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline void swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y) noexcept(noexcept(__x.swap(__y))swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y) noexcept(noexcept(__x.swap(__y)))     {
        __x.swap(__y);
    }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)     {
        return __x._M_h._M_equal(__y._M_h);
    }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)     {
        return !(__x == __y);
    }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)     {
        return __x._M_h._M_equal(__y._M_h);
    }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x, const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y)     {
        return !(__x == __y);
    }
    template <typename _Key, typename _Val, typename _Hash1, typename _Eq1, typename _Alloc, typename _Hash2, typename _Eq2> struct _Hash_merge_helper<std::unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2> {
    private:
        template <typename ..._Tp> using unordered_map = std::unordered_map<_Tp...>;
        template <typename ..._Tp> using unordered_multimap = std::unordered_multimap<_Tp...>;
        friend  unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>;
        static auto &_S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map)         {
            return __map._M_h;
        }
        static auto &_S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map)         {
            return __map._M_h;
        }
    };
    template <typename _Key, typename _Val, typename _Hash1, typename _Eq1, typename _Alloc, typename _Hash2, typename _Eq2> struct _Hash_merge_helper<std::unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2> {
    private:
        template <typename ..._Tp> using unordered_map = std::unordered_map<_Tp...>;
        template <typename ..._Tp> using unordered_multimap = std::unordered_multimap<_Tp...>;
        friend  unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>;
        static auto &_S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map)         {
            return __map._M_h;
        }
        static auto &_S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map)         {
            return __map._M_h;
        }
    };
}
namespace std {
    namespace __detail {
        template <typename _Container, typename _Predicate> typename _Container::size_type __erase_nodes_if(_Container &__cont, _Predicate __pred)         {
            typename _Container::size_type __num = 0;
            for (auto __iter = __cont.begin(), auto __last = __cont.end(); __iter != __last;) {
                if (__pred(*__iter)) {
                    __iter = __cont.erase(__iter);
                    ++__num;
                } else
                    ++__iter;
            }
            return __num;
        }
    }
}
namespace std {
    namespace pmr {
        template <typename _Tp> class polymorphic_allocator;
        template <typename _Key, typename _Tp, typename _Hash = std::hash<_Key>, typename _Pred = std::equal_to<_Key>> using unordered_map = std::unordered_map<_Key, _Tp, _Hash, _Pred, polymorphic_allocator<pair<const _Key, _Tp>>>;
        template <typename _Key, typename _Tp, typename _Hash = std::hash<_Key>, typename _Pred = std::equal_to<_Key>> using unordered_multimap = std::unordered_multimap<_Key, _Tp, _Hash, _Pred, polymorphic_allocator<pair<const _Key, _Tp>>>;
    }
}
template <typename T1, typename T2, typename T3> struct detector {
    using value_t = std::false_type;
};
template<> struct detector<void, int, Success> {
    using value_t = std::true_type;
};
template<> struct detector<void, int, Failure> {
    using value_t = std::false_type;
};
template <typename T> struct detector<typename std::enable_if<T::status>::type, int, T> {
    using value_t = std::true_type;
};
struct Failure {
    static constexpr bool status = false;
};
struct Success {
    static constexpr bool status = true;
};
int main() {
    using AType = detector<void, int, Success>::value_t;
    constexpr bool status1 = AType::value;
    std::cout << "status1 = " << (status1 ? "true" : "false") << std::endl;
    using BType = detector<void, int, Failure>::value_t;
    constexpr bool status2 = BType::value;
    std::cout << "status2 = " << (status2 ? "true" : "false") << std::endl;
}
